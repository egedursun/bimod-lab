Contents of ../../apps/organization/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .organization import *
from .balance import *


Contents of ../../apps/organization/views/organization/delete_organization_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_organization_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_transaction.models import TransactionInvoice
from apps.llm_transaction.utils import InvoiceTypesNames, AcceptedMethodsOfPaymentNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class OrganizationView_OrganizationDelete(DeleteView, LoginRequiredMixin):
    model = Organization
    context_object_name = 'organization'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['user_organizations'] = user_orgs
        context['user_organizations_count'] = user_orgs.count()
        return context

    def post(self, request, *args, **kwargs):
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - DELETE_ORGANIZATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ORGANIZATIONS):
            messages.error(self.request, "You do not have permission to delete organizations.")
            return redirect('organization:list')
        ##############################

        org = self.get_object()
        transfer_org_id = request.POST.get('transfer_organization_id')

        try:
            transfer_org = get_object_or_404(Organization, id=transfer_org_id, users__in=[context_user])
            src_org_balance = org.balance
            transfer_org.balance += org.balance
            transfer_org.save()

            TransactionInvoice.objects.create(
                organization=org, responsible_user=context_user,
                transaction_type=InvoiceTypesNames.TRANSFERRED_CREDITS,
                amount_added=src_org_balance, payment_method=AcceptedMethodsOfPaymentNames.INTERNAL_TRANSFER)
            org.delete()
        except Exception as e:
            logger.error(f"Failed to delete organization: {org.id} by User: {context_user.id}. Error: {str(e)}")
            messages.error(request, "Failed to delete organization.")
            return redirect('organization:list')

        logger.info(f"Organization: {org.id} was deleted by User: {context_user.id}.")
        messages.success(request,
                         f'Organization "{org.name}" has been deleted and the balance has been transferred to "{transfer_org.name}".')
        return redirect('organization:list')

    def get_queryset(self):
        context_user = self.request.user
        return Organization.objects.filter(users__in=[context_user])


Contents of ../../apps/organization/views/organization/__init__.py:

#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .create_organization_views import *
from .delete_organization_views import *
from .update_organization_views import *
from .list_organization_views import *


Contents of ../../apps/organization/views/organization/create_organization_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_organization_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.forms import OrganizationForm
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class OrganizationView_OrganizationCreate(TemplateView, LoginRequiredMixin):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = OrganizationForm()
        return context

    def post(self, request, *args, **kwargs):
        form = OrganizationForm(request.POST, request.FILES)

        ##############################
        # PERMISSION CHECK FOR - ADD_ORGANIZATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_ORGANIZATIONS):
            messages.error(self.request, "You do not have permission to add organizations.")
            return redirect('organization:list')
        ##############################

        if form.is_valid():
            org = form.save(commit=False)
            org.created_by_user = request.user
            org.save()
            org.users.clear()
            org.users.add(request.user)
            logger.info(f"Organization was created by User: {self.request.user.id}.")
            return redirect('organization:list')
        else:
            error_msgs = form.errors
            context = self.get_context_data(**kwargs)
            context['form'] = form
            context['error_messages'] = error_msgs
            logger.error(f"Organization creation failed by User: {self.request.user.id}.")
            return self.render_to_response(context)


Contents of ../../apps/organization/views/organization/list_organization_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_organization_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class OrganizationView_OrganizationList(TemplateView, LoginRequiredMixin):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ORGANIZATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ORGANIZATIONS):
            messages.error(self.request, "You do not have permission to list organizations.")
            return context
        ##############################

        context_user = self.request.user
        orgs = Organization.objects.filter(users__in=[context_user])
        paginator = Paginator(orgs, 10)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        logger.info(f"Organization list was viewed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/organization/views/organization/update_organization_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_organization_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.forms import OrganizationForm
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class OrganizationView_OrganizationUpdate(TemplateView, LoginRequiredMixin):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user
        org = Organization.objects.filter(users__in=[context_user], id=kwargs['pk']).first()
        context['organization'] = org
        context['user'] = context_user
        context['form'] = OrganizationForm(instance=org)
        return context

    def post(self, request, *args, **kwargs):
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - UPDATE_ORGANIZATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_ORGANIZATIONS):
            messages.error(self.request, "You do not have permission to update organizations.")
            return redirect('organization:list')
        ##############################

        org = get_object_or_404(Organization, users__in=[context_user], id=kwargs['pk'])
        form = OrganizationForm(request.POST, request.FILES, instance=org)
        if form.is_valid():
            form.save()
            logger.info(f"Organization was updated by User: {self.request.user.id}.")
            return redirect('organization:list')
        else:
            context = self.get_context_data(**kwargs)
            context['form'] = form
            error_msgs = form.errors
            context['error_messages'] = error_msgs
            logger.error(f"Organization update failed by User: {self.request.user.id}.")
            return self.render_to_response(context)


Contents of ../../apps/organization/views/balance/add_gift_balance_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: add_gift_balance_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import decimal
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_transaction.models import TransactionInvoice
from apps.llm_transaction.utils import InvoiceTypesNames, AcceptedMethodsOfPaymentNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class OrganizationView_AddGiftCredits(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_BALANCE_TO_ORGANIZATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_BALANCE_TO_ORGANIZATION):
            messages.error(self.request, "You do not have permission to add balance to organizations.")
            return redirect('llm_transaction:list')
        ##############################

        org_id = request.POST.get('org_id')
        user = request.user
        org = get_object_or_404(Organization, id=org_id, users__in=[request.user])
        user = User.objects.get(id=user.id)
        try:
            if user.profile.free_credits != 0:
                free_credits = user.profile.free_credits
                user.profile.free_credits = 0
                user.profile.save()
                user.save()
                org.balance += decimal.Decimal.from_float(free_credits)
                org.save()

                TransactionInvoice.objects.create(
                    organization=org,
                    responsible_user=request.user,
                    transaction_type=InvoiceTypesNames.GIFT_CREDITS,
                    amount_added=decimal.Decimal.from_float(round(free_credits, 6)),
                    payment_method=AcceptedMethodsOfPaymentNames.INTERNAL_TRANSFER,
                )
                logger.info(f"Gift credits were added to Organization: {org.id} by User: {user.id}.")
                messages.success(request, f"Gift credits successfully added to {org.name}.")
            else:
                logger.error(f"User: {user.id} tried to add gift credits but had none available.")
                messages.error(request, "No gift credits available to add.")
        except Exception as e:
            logger.error(f"Error adding gift credits to Organization: {org.id} by User: {user.id}.")
            messages.error(request, f"Error adding gift credits: {str(e)}")
        return redirect('llm_transaction:list')


Contents of ../../apps/organization/views/balance/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .add_balance_views import *
from .add_gift_balance_views import *
from .transfer_balance_views import *


Contents of ../../apps/organization/views/balance/add_balance_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: add_balance_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import decimal
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_transaction.models import TransactionInvoice
from apps.llm_transaction.utils import InvoiceTypesNames, AcceptedMethodsOfPaymentNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from auth.models import PromoCode
from config.settings import BALANCE_ADDITION_BONUS_THRESHOLD__SPECIFIER_1, \
    BALANCE_ADDITION_BONUS_PERCENTAGE__GTE_1000_LT_5000, BALANCE_ADDITION_BONUS_THRESHOLD__SPECIFIER_2, \
    BALANCE_ADDITION_BONUS_PERCENTAGE__GTE_5000_LT_10000, BALANCE_ADDITION_BONUS_THRESHOLD__SPECIFIER_3, \
    BALANCE_ADDITION_BONUS_PERCENTAGE__GTE_10000_LT_50000, BALANCE_ADDITION_BONUS_THRESHOLD__SPECIFIER_4, \
    BALANCE_ADDITION_BONUS_PERCENTAGE__GTE_50000

logger = logging.getLogger(__name__)


class OrganizationView_AddBalanceCredits(TemplateView, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - ADD_BALANCE_TO_ORGANIZATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_BALANCE_TO_ORGANIZATION):
            messages.error(self.request, "You do not have permission to add balance to organizations.")
            return redirect('llm_transaction:list')
        ##############################

        org_id = request.POST.get('org_id')
        org = get_object_or_404(Organization, id=org_id, users__in=[context_user])
        topup_amount = float(request.POST.get('topup_amount'))
        promo_code = request.POST.get('promo_code')
        if float(topup_amount) <= 0:
            logger.error(f"User: {context_user.id} tried to top up with an invalid amount: {topup_amount}")
            messages.error(request, 'Top up amount must be greater than zero.')
            return redirect('llm_transaction:list')

        # Addition bonuses
        bulk_addition_bonus_percentage = 0
        if topup_amount >= int(BALANCE_ADDITION_BONUS_THRESHOLD__SPECIFIER_1):
            bulk_addition_bonus_percentage = int(BALANCE_ADDITION_BONUS_PERCENTAGE__GTE_1000_LT_5000)
        if topup_amount >= int(BALANCE_ADDITION_BONUS_THRESHOLD__SPECIFIER_2):
            bulk_addition_bonus_percentage = int(BALANCE_ADDITION_BONUS_PERCENTAGE__GTE_5000_LT_10000)
        if topup_amount >= int(BALANCE_ADDITION_BONUS_THRESHOLD__SPECIFIER_3):
            bulk_addition_bonus_percentage = int(BALANCE_ADDITION_BONUS_PERCENTAGE__GTE_10000_LT_50000)
        if topup_amount >= int(BALANCE_ADDITION_BONUS_THRESHOLD__SPECIFIER_4):
            bulk_addition_bonus_percentage = int(BALANCE_ADDITION_BONUS_PERCENTAGE__GTE_50000)
        bulk_addition_bonus = float(float(topup_amount) * (bulk_addition_bonus_percentage) / 100)
        messages.success(request, f'You have received a {bulk_addition_bonus_percentage}% (${round(bulk_addition_bonus, 2)}) bonus for adding ${topup_amount} to your account.')
        topup_amount += bulk_addition_bonus

        bonus_pct_referrer, bonus_pct_referee = 0, 0
        promo_code = PromoCode.objects.filter(code=promo_code).first()
        if promo_code is None:
            bonus_pct_referee = 0
        else:
            referrer = promo_code.user
            if promo_code.current_referrals + 1 > promo_code.max_referral_limit:
                promo_code.is_active = False
                promo_code.save()
            else:
                promo_code.current_referrals += 1
                bonus_pct_referrer = promo_code.bonus_percentage_referrer
                bonus_pct_referee = promo_code.bonus_percentage_referee
                promo_code.save()
                referrer_organization = Organization.objects.filter(users__in=[referrer]).first()
                referrer_organization.balance += decimal.Decimal.from_float(
                    float(float(topup_amount) * ((bonus_pct_referrer) / 100)))
                referrer_organization.save()

                TransactionInvoice.objects.create(
                    organization=referrer_organization,
                    responsible_user=context_user,
                    transaction_type=InvoiceTypesNames.GIFT_CREDITS,
                    amount_added=decimal.Decimal.from_float(
                        float(float(topup_amount) * ((bonus_pct_referrer) / 100))),
                    payment_method=AcceptedMethodsOfPaymentNames.INTERNAL_TRANSFER,
                )
        try:
            topup_amount = float(topup_amount)
            topup_amount_without_bonus = topup_amount
            topup_amount += float(float(topup_amount) * (bonus_pct_referee) / 100)
            org.balance += decimal.Decimal.from_float(topup_amount)
            org.balance = round(org.balance, 4)
            org.save()

            TransactionInvoice.objects.create(
                organization=org, responsible_user=context_user, transaction_type=InvoiceTypesNames.TOP_UP,
                amount_added=topup_amount_without_bonus, payment_method=AcceptedMethodsOfPaymentNames.CREDIT_CARD)

            if topup_amount_without_bonus != topup_amount:
                TransactionInvoice.objects.create(
                    organization=org, responsible_user=context_user, transaction_type=InvoiceTypesNames.GIFT_CREDITS,
                    amount_added=(topup_amount - topup_amount_without_bonus),
                    payment_method=AcceptedMethodsOfPaymentNames.INTERNAL_TRANSFER,
                )
            logger.info(f"User: {context_user.id} added ${topup_amount} to Organization: {org.id}.")
            messages.success(request, f'Credits successfully added. New balance: ${org.balance}')
        except ValueError:
            logger.error(f"User: {context_user.id} tried to top up with an invalid amount: {topup_amount}")
            messages.error(request, 'Invalid amount entered. Please enter a valid number.')
        return redirect('llm_transaction:list')


Contents of ../../apps/organization/views/balance/transfer_balance_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: transfer_balance_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import decimal
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_transaction.models import TransactionInvoice
from apps.llm_transaction.utils import InvoiceTypesNames, AcceptedMethodsOfPaymentNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class OrganizationView_TransferBalance(LoginRequiredMixin, View):

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - TRANSFER_BALANCE_BETWEEN_ORGANIZATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.TRANSFER_BALANCE_BETWEEN_ORGANIZATIONS):
            messages.error(self.request, "You do not have permission to transfer balance between organizations.")
            return redirect('llm_transaction:list')
        ##############################

        source_org_id = request.POST.get('source_org')
        destination_org_id = request.POST.get('destination_org')
        transfer_amount = request.POST.get('transfer_amount')
        if transfer_amount is None:
            logger.error(f"User: {request.user.id} tried to transfer with an invalid amount: {transfer_amount}")
            messages.error(request, "Invalid transfer amount.")
            return redirect('llm_transaction:list')
        try:
            transfer_amount = decimal.Decimal(transfer_amount)
        except decimal.InvalidOperation:
            logger.error(f"User: {request.user.id} tried to transfer with an invalid amount: {transfer_amount}")
            messages.error(request, "Invalid transfer amount.")
            return redirect('llm_transaction:list')
        if transfer_amount <= 0:
            logger.error(f"User: {request.user.id} tried to transfer with an invalid amount: {transfer_amount}")
            messages.error(request, "Transfer amount must be greater than zero.")
            return redirect('llm_transaction:list')
        if source_org_id == destination_org_id:
            logger.error(f"User: {request.user.id} tried to transfer to the same organization.")
            messages.error(request, "Source and destination organizations cannot be the same.")
            return redirect('llm_transaction:list')

        source_org = get_object_or_404(Organization, id=source_org_id, users__in=[request.user])
        destination_org = get_object_or_404(Organization, id=destination_org_id, users__in=[request.user])
        if source_org.balance < transfer_amount:
            logger.error(f"User: {request.user.id} tried to transfer with insufficient balance: {transfer_amount}")
            messages.error(request, "Insufficient balance in the source organization.")
            return redirect('llm_transaction:list')

        source_org.balance -= transfer_amount
        destination_org.balance += transfer_amount
        source_org.save()
        destination_org.save()
        TransactionInvoice.objects.create(
            organization=destination_org, responsible_user=request.user,
            transaction_type=InvoiceTypesNames.TRANSFERRED_CREDITS, amount_added=transfer_amount,
            payment_method=AcceptedMethodsOfPaymentNames.INTERNAL_TRANSFER,)
        logger.info(f"Balance transferred from Organization: {source_org.id} to Organization: {destination_org.id} "
                    f"by User: {request.user.id}.")
        messages.success(request,
                         f"${transfer_amount} successfully transferred from {source_org.name} to {destination_org.name}.")
        return redirect('llm_transaction:list')


Contents of ../../apps/harmoniq/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .harmoniq import *
from .internal import *


Contents of ../../apps/harmoniq/views/harmoniq/list_harmoniq_agents_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_harmoniq_agents_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.harmoniq.models import Harmoniq
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class HarmoniqView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_HARMONIQ_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_HARMONIQ_AGENTS):
            messages.error(self.request, "You do not have permission to list Harmoniq Agents.")
            return context
            ##############################

        orgs = Organization.objects.filter(users__in=[self.request.user])
        org_agents = {}
        for org in orgs:
            agents = Harmoniq.objects.filter(organization=org)
            org_agents[org] = agents
        context['org_assistants'] = org_agents
        logger.info(f"Harmoniq Agents were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/harmoniq/views/harmoniq/use_harmoniq_agent_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: use_harmoniq_agent_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import base64
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.views.generic import TemplateView

from apps.core.harmoniq.harmoniq_executor import OpenAIRealtimeAPIClient, sync_request_communication
from apps.core.harmoniq.harmoniq_tool_manager import HarmoniqToolManager
from apps.core.harmoniq.utils import find_tool_call_from_json, MAX_ATTEMPTS_TOOL_CALL
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.harmoniq.models import Harmoniq
from apps.leanmod.models import ExpertNetwork, ExpertNetworkAssistantReference
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HarmoniqView_Use(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - CHAT_WITH_HARMONIQ_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CHAT_WITH_HARMONIQ_AGENTS):
            messages.error(self.request, "You do not have permission to chat with Harmoniq Agents.")
            return context
        ##############################

        agents = Harmoniq.objects.filter(organization__users=self.request.user)
        context['agents'] = agents
        context['audio'] = None
        context['transcript'] = None
        return context


class HarmoniqCommunicationView(View):
    @csrf_exempt
    def post(self, request, *args, **kwargs):
        try:
            data = request.POST
            agent_id = data.get('agentPicker')
            msg = data.get('messageInput')
            if not agent_id or not msg:
                return JsonResponse({'error': 'Agent ID or message is missing'}, status=400)

            harmoniq_agent = Harmoniq.objects.get(id=agent_id)
            org = harmoniq_agent.organization
            user = self.request.user

            org_data = {
                "org_id": org.id,
                "org_name": org.name,
                "org_address": org.address,
                "org_phone": org.phone,
                "org_city": org.city,
                "org_country": org.country,
                "org_postal_code": org.postal_code,
                "org_industry": org.industry,
            }

            user_data = {
                "username": user.username,
                "email": user.email,
                "first_name": user.profile.first_name,
                "last_name": user.profile.last_name,
                "phone": user.profile.phone_number,
                "address": user.profile.address,
                "city": user.profile.city,
                "country": user.profile.country,
                "postal_code": user.profile.postal_code
            }

            expert_net_and_refs = {}
            for expert_net in harmoniq_agent.consultant_expert_networks.all():
                expert_net: ExpertNetwork
                expert_net_and_refs[expert_net.name] = {
                    "expert_network_name": expert_net.name,
                    "meta_description": expert_net.meta_description,
                    "assistant_references": {}
                }
                for ref in expert_net.assistant_references.all():
                    ref: ExpertNetworkAssistantReference
                    expert_net_and_refs[expert_net.name]["assistant_references"][ref.id] = {
                        "assistant_id": ref.id,
                        "assistant_name": ref.assistant.name,
                        "context_instructions": ref.context_instructions
                    }

            api_client = OpenAIRealtimeAPIClient(
                harmoniq_agent=harmoniq_agent, llm_model=harmoniq_agent.llm_model,
                expert_net_and_refs=expert_net_and_refs, org_data=org_data,  user_data=user_data)

            sync_request_communication(api_client, msg)
            audio_data = base64.b64encode(api_client.audio_buffer).decode('utf-8')
            transcript_data = api_client.transcript

            def process_tool_calls(transcript, audio, attempt=0):
                if attempt > MAX_ATTEMPTS_TOOL_CALL:
                    logger.error(f"Tool calls are not successful after {MAX_ATTEMPTS_TOOL_CALL} attempts.")
                    return transcript, audio
                json_content_of_resp = find_tool_call_from_json(transcript)
                if not json_content_of_resp:
                    logger.info("No tool call found in the transcript.")
                    return transcript, audio

                tool_resp_list = []
                for i, tool_call in enumerate(json_content_of_resp):
                    tool_xc = HarmoniqToolManager(agent=harmoniq_agent, tool_usage_json_str=tool_call)
                    tool_resp, tool_name, file_uris, image_uris = tool_xc.call_internal_tool_service_harmoniq()
                    tool_resp_list.append(f"""
                            [{i}] "tool_name": {tool_name},
                                [{i}a.] "tool_response": {tool_resp},
                                [{i}b.] "file_uris": {file_uris},
                                [{i}c.] "image_uris": {image_uris}
                        """)
                tool_msg = f"""
                    ---
                    Tool Response List:

                    ### **VERY IMPORTANT NOTE:**

                    (Although you don't remember, you have requested for this output in your previous response, and
                    you wanted this to answer the user's questions. Thus, don't attempt to do another tool call, as
                    if you see data below, this means that the tool response is already achieved, and answer
                    accordingly.

                    ---

                    {str(tool_resp_list)}

                    ---
                """
                updated_msg = (msg + tool_msg)
                sync_request_communication(api_client, updated_msg)
                updated_audio_data = base64.b64encode(api_client.audio_buffer).decode('utf-8')
                updated_transcript_data = api_client.transcript
                logger.info(f"Tool calls are successful after {attempt + 1} attempts.")
                return process_tool_calls(updated_transcript_data, updated_audio_data, attempt + 1)

            final_transcript, final_audio = process_tool_calls(transcript_data, audio_data)
            logger.info(f"Communication is successful.")
            return JsonResponse({'transcript': final_transcript, 'audio': final_audio})
        except Exception as e:
            logger.error(f"Communication is not successful. Error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=400)


Contents of ../../apps/harmoniq/views/harmoniq/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .list_harmoniq_agents_views import *
from .create_harmoniq_agent_views import *
from .update_harmoniq_agent_views import *
from .confirm_delete_harmoniq_agent_views import *
from .use_harmoniq_agent_views import *


Contents of ../../apps/harmoniq/views/harmoniq/update_harmoniq_agent_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_harmoniq_agent_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.harmoniq.models import Harmoniq
from apps.harmoniq.utils import HARMONIQ_DEITIES
from apps.leanmod.models import ExpertNetwork
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HarmoniqView_Update(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        harmoniq_agent = get_object_or_404(Harmoniq, id=self.kwargs['pk'])
        context['harmoniq_agent'] = harmoniq_agent
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['llm_models'] = LLMCore.objects.filter(organization__in=context['organizations'])
        context['harmoniq_deities'] = HARMONIQ_DEITIES
        context['expert_networks'] = ExpertNetwork.objects.filter(organization__in=context['organizations'])
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_HARMONIQ_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_HARMONIQ_AGENTS):
            messages.error(self.request, "You do not have permission to update Harmoniq Agents.")
            return redirect('harmoniq:list')
        ##############################

        harmoniq_agent = get_object_or_404(Harmoniq, id=self.kwargs['pk'])
        org = request.POST.get('organization')
        llm_model = request.POST.get('llm_model')
        name = request.POST.get('name')
        desc = request.POST.get('description')
        harmoniq_deity = request.POST.get('harmoniq_deity')
        optional_instructions = request.POST.get('optional_instructions')
        nw_ids = request.POST.getlist('expert_networks')

        try:
            if org and llm_model and name and desc and harmoniq_deity:
                harmoniq_agent.organization_id = org
                harmoniq_agent.llm_model_id = llm_model
                harmoniq_agent.name = name
                harmoniq_agent.description = desc
                harmoniq_agent.harmoniq_deity = harmoniq_deity
                harmoniq_agent.optional_instructions = optional_instructions

                harmoniq_agent.consultant_expert_networks.clear()
                if nw_ids:
                    for expert_network_id in nw_ids:
                        expert_network = ExpertNetwork.objects.get(id=expert_network_id)
                        harmoniq_agent.consultant_expert_networks.add(expert_network)

                harmoniq_agent.save()
                logger.info(f"Harmoniq Agent was updated by User: {request.user.id}.")
                messages.success(request, "Harmoniq Agent updated successfully.")
                return redirect('harmoniq:list')
            else:
                logger.error(f"Harmoniq Agent was not updated by User: {request.user.id}.")
                messages.error(request, "All required fields must be filled.")
                return self.get(request, *args, **kwargs)
        except Exception as e:
            logger.error(f"Error updating Harmoniq Agent: {e}")
            messages.error(request, f"Error updating Harmoniq Agent: {e}")
            return redirect('harmoniq:list')


Contents of ../../apps/harmoniq/views/harmoniq/confirm_delete_harmoniq_agent_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: confirm_delete_harmoniq_agent_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.harmoniq.models import Harmoniq
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HarmoniqView_ConfirmDelete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        harmoniq_agent = get_object_or_404(Harmoniq, id=self.kwargs['pk'])
        context['assistant'] = harmoniq_agent
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_HARMONIQ_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HARMONIQ_AGENTS):
            messages.error(self.request, "You do not have permission to delete Harmoniq Agents.")
            return redirect('harmoniq:list')
        ##############################

        harmoniq_agent = get_object_or_404(Harmoniq, id=self.kwargs['pk'])

        try:
            harmoniq_agent.delete()
        except Exception as e:
            logger.error(f"Error deleting Harmoniq agent: {e}")
            messages.error(request, f"Error deleting Harmoniq agent: {e}")
            return redirect('harmoniq:detail', pk=self.kwargs['pk'])

        logger.info(f"The Harmoniq agent was deleted by User: {request.user.id}.")
        messages.success(request, f'The Harmoniq agent "{harmoniq_agent.name}" has been successfully deleted.')
        return redirect('harmoniq:list')


Contents of ../../apps/harmoniq/views/harmoniq/create_harmoniq_agent_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_harmoniq_agent_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.harmoniq.models import Harmoniq
from apps.harmoniq.utils import HARMONIQ_DEITIES
from apps.leanmod.models import ExpertNetwork
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HarmoniqView_Create(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['llm_models'] = LLMCore.objects.filter(organization__in=context['organizations'])
        context['harmoniq_deities'] = HARMONIQ_DEITIES
        context['expert_networks'] = ExpertNetwork.objects.filter(organization__in=context['organizations'])
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_HARMONIQ_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_HARMONIQ_AGENTS):
            messages.error(self.request, "You do not have permission to add Harmoniq Agents.")
            return redirect('harmoniq:list')
        ##############################

        org = request.POST.get('organization')
        llm_model = request.POST.get('llm_model')
        name = request.POST.get('name')
        desc = request.POST.get('description')
        harmoniq_deity = request.POST.get('harmoniq_deity')
        optional_instructions = request.POST.get('optional_instructions')
        nw_ids = request.POST.getlist('expert_networks')

        try:
            if org and llm_model and name and desc and harmoniq_deity:
                harmoniq_agent = Harmoniq.objects.create(
                    organization_id=org, llm_model_id=llm_model, name=name, description=desc,
                    harmoniq_deity=harmoniq_deity, optional_instructions=optional_instructions,
                    created_by_user=request.user)
                if nw_ids:
                    for nw_id in nw_ids:
                        nw = ExpertNetwork.objects.get(id=nw_id)
                        harmoniq_agent.consultant_expert_networks.add(nw)
                harmoniq_agent.save()
                logger.info(f"Harmoniq Agent was created by User: {request.user.id}.")
                messages.success(request, "Harmoniq Agent created successfully.")
                return redirect('harmoniq:list')
            else:
                logger.error(f"Harmoniq Agent was not created by User: {request.user.id}.")
                messages.error(request, "All required fields must be filled.")
                return self.get(request, *args, **kwargs)
        except Exception as e:
            logger.error(f"Error creating Harmoniq Agent: {e}")
            messages.error(request, f"Error creating Harmoniq Agent: {e}")
            return self.get(request, *args, **kwargs)


Contents of ../../apps/harmoniq/views/internal/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-07 01:00:22
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-07 01:00:23
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#




Contents of ../../apps/harmoniq/views/internal/internal_test_harmoniq_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: internal_test_harmoniq_views.py
#  Last Modified: 2024-10-07 01:00:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-07 01:00:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class HarmoniqView_TestInternal(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        logger.info(f"Internal Test Harmoniq View was accessed by User: {self.request.user.id}.")
        return context



Contents of ../../apps/blog_app/views/list_blog_posts_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_blog_posts_views.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.core.paginator import Paginator
from django.db.models import Q
from django.views.generic import TemplateView

from apps.blog_app.models import BlogPost
from web_project import TemplateLayout, TemplateHelper

logger = logging.getLogger(__name__)


class BlogPostView_List(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            'layout_content': "compact",
        })

        try:
            search_query = self.request.GET.get('search', '')

            if search_query:
                posts = BlogPost.objects.filter(
                    Q(title__icontains=search_query) |
                    Q(content__icontains=search_query) |
                    Q(tags__name__icontains=search_query),
                ).order_by('-published_at')
            else:
                posts = BlogPost.objects.filter(status='published').order_by('-published_at')

            paginator = Paginator(posts, 9)
            page_number = self.request.GET.get('page')
            page_obj = paginator.get_page(page_number)
            context['page_obj'] = page_obj
            context['search_query'] = search_query
        except Exception as e:
            logger.error(f"[BlogPostView_List] Error listing the Blog Posts: {e}")
            return context

        logger.info(f"Blog Posts were listed. User authenticated: {self.request.user.is_authenticated}")
        return context


Contents of ../../apps/blog_app/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .detail_blog_post_view import *
from .list_blog_posts_views import *


Contents of ../../apps/blog_app/views/detail_blog_post_view.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_blog_post_view.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.blog_app.models import BlogPost
from web_project import TemplateLayout, TemplateHelper

logger = logging.getLogger(__name__)


class BlogPostView_Detail(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
        })

        try:
            post_slug = self.kwargs.get('slug')
            post = get_object_or_404(BlogPost, slug=post_slug, status='published')
            context['post'] = post
            if hasattr(post, 'seo_meta'):
                context['seo_meta'] = post.seo_meta
            related_posts = BlogPost.objects.filter(tags__in=post.tags.all()).exclude(id=post.id).distinct()[:3]
            context['related_posts'] = related_posts
        except Exception as e:
            logger.error(f"[BlogPostView_Detail] Error fetching the Blog Post: {e}")
            return context

        logger.info(f"Blog Post {post.title} was viewed.")
        return context


Contents of ../../apps/datasource_knowledge_base/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .document import *
from .knowledge_base import *


Contents of ../../apps/datasource_knowledge_base/views/document/list_documents_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_documents_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection, KnowledgeBaseDocument, \
    DocumentProcessingLog
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class DocumentView_List(LoginRequiredMixin, TemplateView):
    def get(self, request, *args, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_KNOWLEDGE_BASE_DOCS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_KNOWLEDGE_BASE_DOCS):
            messages.error(self.request, "You do not have permission to list Knowledge Base documents.")
            return context
        ##############################

        try:
            orgs = Organization.objects.filter(users__in=[request.user])
            data = []
            for org in orgs:
                agents = Assistant.objects.filter(organization=org)
                agent_data_list = []
                for agent in agents:
                    vector_stores = DocumentKnowledgeBaseConnection.objects.filter(assistant=agent)
                    kb_data_list = []
                    for kb in vector_stores:
                        docs = KnowledgeBaseDocument.objects.filter(knowledge_base=kb).order_by('-created_at')
                        paginator = Paginator(docs, 5)  # 5 documents per page
                        page_number = request.GET.get('page')
                        page_obj = paginator.get_page(page_number)
                        doc_data_list = []
                        for doc in page_obj:
                            log_entries = DocumentProcessingLog.objects.filter(document_full_uri=doc.document_uri)
                            proc_statuses = [log.log_message for log in log_entries]
                            doc_data_list.append({'document': doc, 'current_statuses': proc_statuses})
                        kb_data_list.append({
                            'knowledge_base': kb, 'documents': page_obj, 'document_data': doc_data_list,
                        })
                    agent_data_list.append({'assistant': agent, 'knowledge_bases': kb_data_list})
                data.append({'organization': org, 'assistants': agent_data_list})

            context['data'] = data
            context['document_statuses'] = ['staged', 'uploaded', 'loaded', 'chunked', 'embedded_document',
                                            'saved_document', 'processed_document', 'embedded_chunks', 'saved_chunks',
                                            'processed_chunks', 'completed']
        except Exception as e:
            messages.error(request, 'An error occurred while listing Knowledge Base documents.')
            return self.render_to_response(context)

        context['failed_statuses'] = ['failed']
        context['partially_failed_statuses'] = ['partially_failed']
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_KNOWLEDGE_BASE_DOCS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_KNOWLEDGE_BASE_DOCS):
            messages.error(self.request, "You do not have permission to delete Knowledge Base documents.")
            return redirect('datasource_knowledge_base:list_documents')
        ##############################

        try:
            doc_ids = request.POST.getlist('selected_documents')
            if doc_ids:
                KnowledgeBaseDocument.objects.filter(id__in=doc_ids).delete()
        except Exception as e:
            messages.error(request, 'An error occurred while deleting selected documents.')
            return redirect('datasource_knowledge_base:list_documents')

        messages.success(request, 'Selected documents deleted successfully.')
        return redirect('datasource_knowledge_base:list_documents')


Contents of ../../apps/datasource_knowledge_base/views/document/__init__.py:

#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .delete_all_documents_views import *
from .list_documents_views import *
from .create_document_views import *


Contents of ../../apps/datasource_knowledge_base/views/document/delete_all_documents_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_documents_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_knowledge_base.models import KnowledgeBaseDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DocumentView_DeleteAll(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.post(request, *args, **kwargs)
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_KNOWLEDGE_BASE_DOCS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_KNOWLEDGE_BASE_DOCS):
            messages.error(self.request, "You do not have permission to delete Knowledge Base documents.")
            return redirect('datasource_knowledge_base:list_documents')
        ##############################

        try:
            vs_id = kwargs.get('kb_id')
            KnowledgeBaseDocument.objects.filter(knowledge_base_id=vs_id).delete()
        except Exception as e:
            logger.error(f"User: {request.user} - Document - Delete All Error: {e}")
            messages.error(request, 'An error occurred while deleting all documents.')
            return redirect('datasource_knowledge_base:list_documents')

        messages.success(request, 'All documents in the selected knowledge base have been deleted successfully.')
        logger.info(
            f"[views.delete_all_documents] All documents in the selected knowledge base have been deleted successfully.")
        return redirect('datasource_knowledge_base:list_documents')


Contents of ../../apps/datasource_knowledge_base/views/document/create_document_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_document_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

import boto3
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView
from slugify import slugify

from apps.core.vector_operations.vector_document.vector_store_decoder import KnowledgeBaseSystemDecoder
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection
from apps.datasource_knowledge_base.tasks import add_vector_store_doc_loaded_log
from apps.datasource_knowledge_base.utils import generate_document_uri, VectorStoreDocProcessingStatusNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from config import settings
from config.settings import MEDIA_URL
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class DocumentView_Create(LoginRequiredMixin, TemplateView):
    def get(self, request, *args, **kwargs):
        user_agents = Assistant.objects.filter(organization__users__in=[request.user])
        vector_stores = DocumentKnowledgeBaseConnection.objects.filter(assistant__in=user_agents)
        orgs = Organization.objects.filter(users__in=[request.user])
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = list(orgs.values('id', 'name'))
        context['assistants'] = list(user_agents.values('id', 'name', 'organization_id'))
        context['knowledge_bases'] = list(vector_stores.values('id', 'name', 'assistant_id'))
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        vs_id = request.POST.get('knowledge_base') or None

        ##############################
        # PERMISSION CHECK FOR - ADD_KNOWLEDGE_BASE_DOCS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_KNOWLEDGE_BASE_DOCS):
            messages.error(self.request, "You do not have permission to add Knowledge Base documents.")
            return redirect('datasource_knowledge_base:list_documents')
        ##############################

        if not vs_id:
            logger.error('Please select a knowledge base.')
            messages.error(request, 'Please select a knowledge base.')
            return redirect('datasource_knowledge_base:create_documents')

        vector_store = DocumentKnowledgeBaseConnection.objects.get(pk=vs_id)
        fs = request.FILES.getlist('document_files')
        if vs_id and fs:
            agent_base_dir = vector_store.assistant.document_base_directory
            f_paths = []
            for file in fs:
                file_type = file.name.split('.')[-1]
                structured_file_name = slugify(file.name)
                doc_uri = generate_document_uri(agent_base_dir, structured_file_name, file_type)
                f_paths.append(doc_uri)
                add_vector_store_doc_loaded_log(document_full_uri=doc_uri, log_name=VectorStoreDocProcessingStatusNames.STAGED)
                s3c = boto3.client('s3')
                bucket = settings.AWS_STORAGE_BUCKET_NAME
                bucket_path = f"{doc_uri.split(MEDIA_URL)[1]}"
                s3c.put_object(Bucket=bucket, Key=bucket_path, Body=file)
                add_vector_store_doc_loaded_log(document_full_uri=doc_uri, log_name=VectorStoreDocProcessingStatusNames.UPLOADED)

            KnowledgeBaseSystemDecoder.get(vector_store).index_documents(document_paths=f_paths)
            logger.info('Documents uploaded successfully.')
            messages.success(request, 'Documents uploaded successfully.')
            return redirect('datasource_knowledge_base:list_documents')
        else:
            logger.error('Please select a knowledge base and upload documents.')
            messages.error(request, 'Please select a knowledge base and upload documents.')
        return redirect('datasource_knowledge_base:create_documents')


Contents of ../../apps/datasource_knowledge_base/views/knowledge_base/update_knowledge_base_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_knowledge_base_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_knowledge_base.forms import DocumentKnowledgeBaseForm
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection
from apps.datasource_knowledge_base.utils import VECTORSTORE_SYSTEMS, EMBEDDING_VECTORIZER_MODELS
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VectorStoreView_Update(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        try:
            context_user = self.request.user
            vector_store = get_object_or_404(DocumentKnowledgeBaseConnection, pk=kwargs['pk'])
            context['user'] = context_user
            context['knowledge_base_systems'] = VECTORSTORE_SYSTEMS
            context['vectorizers'] = EMBEDDING_VECTORIZER_MODELS
            user_orgs = context_user.organizations.all()
            agents_of_orgs = Assistant.objects.filter(organization__in=user_orgs)
            context['assistants'] = agents_of_orgs
            context['connection'] = vector_store
            context['form'] = DocumentKnowledgeBaseForm(instance=vector_store)
        except Exception as e:
            logger.error(f"User: {self.request.user} - Knowledge Base - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating the knowledge base.')

        return context

    def post(self, request, *args, **kwargs):
        vector_store = get_object_or_404(DocumentKnowledgeBaseConnection, pk=kwargs['pk'])

        ##############################
        # PERMISSION CHECK FOR - ADD_KNOWLEDGE_BASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_KNOWLEDGE_BASES):
            messages.error(self.request, "You do not have permission to update Knowledge Bases.")
            return redirect('datasource_knowledge_base:list')
        ##############################

        form = DocumentKnowledgeBaseForm(request.POST, instance=vector_store)
        if form.is_valid():
            form.save()
            logger.info(f"[views.update_knowledge_base] Knowledge Base updated successfully.")
            messages.success(request, "Knowledge Base updated successfully.")
            return redirect('datasource_knowledge_base:list')
        else:
            logger.error(
                f"[views.update_knowledge_base] Error updating Knowledge Base. Please check the form for errors.")
            messages.error(request, "Error updating Knowledge Base. Please check the form for errors.")
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_knowledge_base/views/knowledge_base/list_knowledge_bases_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_knowledge_bases_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VectorStoreView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_KNOWLEDGE_BASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_KNOWLEDGE_BASES):
            messages.error(self.request, "You do not have permission to list Knowledge Bases.")
            return context
        ##############################

        try:
            context_user = self.request.user
            user_orgs = Organization.objects.filter(users__in=[context_user])
            conns_by_orgs = {}
            for org in user_orgs:
                agents = org.assistants.all()
                agents_conns = {}
                for agent in agents:
                    conn = DocumentKnowledgeBaseConnection.objects.filter(assistant=agent)
                    if conn.exists():
                        agents_conns[agent] = conn
                if agents_conns:
                    conns_by_orgs[org] = agents_conns
        except Exception as e:
            logger.error(f"User: {self.request.user} - Knowledge Base - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing the knowledge bases.')
            return context

        context['connections_by_organization'] = conns_by_orgs
        context['user'] = context_user
        logger.info(f"Knowledge Bases were listed.")
        return context


Contents of ../../apps/datasource_knowledge_base/views/knowledge_base/create_knowledge_base_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_knowledge_base_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_knowledge_base.forms import DocumentKnowledgeBaseForm
from apps.datasource_knowledge_base.utils import VECTORSTORE_SYSTEMS, EMBEDDING_VECTORIZER_MODELS
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VectorStoreView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        try:
            context_user = self.request.user
            context['user'] = context_user
            context['knowledge_base_systems'] = VECTORSTORE_SYSTEMS
            context['vectorizers'] = EMBEDDING_VECTORIZER_MODELS
            user_orgs = context_user.organizations.all()
            agents_of_orgs = Assistant.objects.filter(organization__in=user_orgs)
            context['assistants'] = agents_of_orgs
            context['form'] = DocumentKnowledgeBaseForm()
        except Exception as e:
            logger.error(f"User: {self.request.user} - Knowledge Base - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating the knowledge base.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        form = DocumentKnowledgeBaseForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_KNOWLEDGE_BASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_KNOWLEDGE_BASES):
            messages.error(self.request, "You do not have permission to create Knowledge Bases.")
            return redirect('datasource_knowledge_base:list')
        ##############################

        if form.is_valid():
            form.save()
            logger.info(f"[views.create_knowledge_base] Knowledge Base created successfully.")
            messages.success(request, "Knowledge Base created successfully.")
            return redirect('datasource_knowledge_base:list')
        else:
            logger.error(
                f"[views.create_knowledge_base] Error creating Knowledge Base. Please check the form for errors: {form.errors}")
            messages.error(request,
                           "Error creating Knowledge Base. Please check the form for errors: %s" % form.errors)
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_knowledge_base/views/knowledge_base/__init__.py:

#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .update_knowledge_base_views import *
from .list_knowledge_bases_views import *
from .create_knowledge_base_views import *
from .delete_knowledge_base_views import *


Contents of ../../apps/datasource_knowledge_base/views/knowledge_base/delete_knowledge_base_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_knowledge_base_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VectorStoreView_Delete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['knowledge_base'] = DocumentKnowledgeBaseConnection.objects.get(pk=self.kwargs['pk'])
        return context

    def post(self, request, *args, **kwargs):
        vector_store = DocumentKnowledgeBaseConnection.objects.get(pk=self.kwargs['pk'])
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - DELETE_KNOWLEDGE_BASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_KNOWLEDGE_BASES):
            messages.error(self.request, "You do not have permission to delete Knowledge Bases.")
            return redirect('datasource_knowledge_base:list')
        ##############################

        try:
            vector_store.delete()
        except Exception as e:
            logger.error(f"User: {context_user} - Knowledge Base - Delete Error: {e}")
            messages.error(request, 'An error occurred while deleting the knowledge base.')
            return redirect('datasource_knowledge_base:list')

        logger.info(f"[views.delete_knowledge_base] Knowledge Base deleted successfully.")
        messages.success(request, "Knowledge Base deleted successfully.")
        return redirect('datasource_knowledge_base:list')


Contents of ../../apps/drafting/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-14 13:52:59
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 13:53:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .folder import *
from .document import *
from .drafting_commands import *
from .public import *
from .google_apps_connection import *


Contents of ../../apps/drafting/views/folder/drafting_folders_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_folders_list_views.py
#  Last Modified: 2024-10-14 18:46:52
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:46:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingFolder
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DraftingView_FolderList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_DRAFTING_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_DRAFTING_FOLDERS):
            messages.error(self.request, "You do not have permission to list Drafting Folders.")
            return context
        ##############################

        # Get organizations and paginate folders for each

        try:
            user_orgs = Organization.objects.filter(users__in=[self.request.user])
            org_folders = []
            for org in user_orgs:
                folders = DraftingFolder.objects.filter(organization=org)
                paginator = Paginator(folders, 10)
                page_number = self.request.GET.get(f'page_{org.id}', 1)
                page_obj = paginator.get_page(page_number)
                org_folders.append({
                    'organization': org,
                    'page_obj': page_obj,
                })
            context['org_folders'] = org_folders
            context['organizations'] = user_orgs
        except Exception as e:
            logger.error(f"Error listing Drafting Folders: {e}")
            messages.error(self.request, 'An error occurred while listing Drafting Folders.')
            return context

        logger.info(f"Drafting Folders were listed for User: {self.request.user.id}.")
        return context


Contents of ../../apps/drafting/views/folder/drafting_folders_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_folders_update_views.py
#  Last Modified: 2024-10-14 18:45:38
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:45:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingFolder
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DraftingView_FolderUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']

        try:
            folder = get_object_or_404(DraftingFolder, id=folder_id)
            organizations = Organization.objects.filter(users__in=[self.request.user])
            context['folder'] = folder
            context['organizations'] = organizations
        except Exception as e:
            logger.error(f"Error getting Drafting Folder: {e}")
            messages.error(self.request, 'An error occurred while getting Drafting Folder.')
            return context

        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_FOLDERS):
            messages.error(self.request, "You do not have permission to update Drafting Folders.")
            return redirect('drafting:folders_list')
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(DraftingFolder, id=folder_id)

        try:
            folder.name = request.POST.get('name')
            folder.description = request.POST.get('description', '')
            folder.meta_context_instructions = request.POST.get('meta_context_instructions', '')
            organization_id = request.POST.get('organization')
            if organization_id:
                folder.organization_id = organization_id
            folder.save()
        except Exception as e:
            logger.error(f"Error updating Drafting Folder: {e}")
            messages.error(self.request, 'An error occurred while updating Drafting Folder.')
            return redirect('drafting:folders_list')

        logger.info(f"Drafting Folder was updated by User: {request.user.id}.")
        return redirect('drafting:folders_list')


Contents of ../../apps/drafting/views/folder/drafting_folders_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_folders_create_views.py
#  Last Modified: 2024-10-14 18:45:30
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:45:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingFolder
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_FolderCreate(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_DRAFTING_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_DRAFTING_FOLDERS):
            messages.error(self.request, "You do not have permission to add Drafting Folders.")
            return redirect('drafting:folders_list')
        ##############################

        organization_id = request.POST.get('organization')
        folder_name = request.POST.get('name')
        description = request.POST.get('description', '')
        meta_context_instructions = request.POST.get('meta_context_instructions', '')

        try:
            if organization_id and folder_name:
                organization = Organization.objects.get(id=organization_id)
                DraftingFolder.objects.create(
                    organization=organization, name=folder_name, description=description,
                    meta_context_instructions=meta_context_instructions, created_by_user=request.user
                )
        except Exception as e:
            logger.error(f"Error creating Drafting Folder: {e}")
            messages.error(self.request, 'An error occurred while creating Drafting Folder.')
            return redirect('drafting:folders_list')

        logger.info(f"Drafting Folder was created by User: {request.user.id}.")
        return redirect('drafting:folders_list')


Contents of ../../apps/drafting/views/folder/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-14 18:45:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:45:17
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .drafting_folders_list_views import *
from .drafting_folders_create_views import *
from .drafting_folders_delete_views import *
from .drafting_folders_update_views import *


Contents of ../../apps/drafting/views/folder/drafting_folders_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_folders_delete_views.py
#  Last Modified: 2024-10-14 18:45:45
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:45:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingFolder
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DraftingView_FolderDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(DraftingFolder, id=folder_id)
        context['folder'] = folder
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_DRAFTING_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_DRAFTING_FOLDERS):
            messages.error(self.request, "You do not have permission to delete Drafting Folders.")
            return redirect('drafting:folders_list')
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(DraftingFolder, id=folder_id)

        try:
            folder.delete()
        except Exception as e:
            logger.error(f"Error deleting Drafting Folder: {e}")
            messages.error(self.request, 'An error occurred while deleting Drafting Folder.')
            return redirect('drafting:folders_list')

        logger.info(f"Drafting Folder was deleted by User: {request.user.id}.")
        return redirect('drafting:folders_list')


Contents of ../../apps/drafting/views/document/drafting_documents_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_documents_update_views.py
#  Last Modified: 2024-10-15 20:05:04
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 20:05:05
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingFolder, DraftingDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DraftingView_DocumentUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']

        try:
            folder = get_object_or_404(DraftingFolder, id=folder_id)
            document = get_object_or_404(DraftingDocument, id=document_id, document_folder=folder)
            available_folders = DraftingFolder.objects.filter(organization=folder.organization)
            assistants = Assistant.objects.filter(organization=folder.organization)
            context['folder'] = folder
            context['document'] = document
            context['available_folders'] = available_folders
            context['assistants'] = assistants
        except Exception as e:
            logger.error(f"Error getting Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while getting Drafting Document.')
            return context

        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']

        try:
            folder = get_object_or_404(DraftingFolder, id=folder_id)
            document = get_object_or_404(DraftingDocument, id=document_id, document_folder=folder)
            document.document_title = request.POST.get('document_title')
            document.copilot_assistant_id = request.POST.get('copilot_assistant')
            document.document_folder_id = request.POST.get('document_folder')
            document.context_instructions = request.POST.get('context_instructions', '')
            document.target_audience = request.POST.get('target_audience', '')
            document.tone = request.POST.get('tone', '')
            document.last_updated_by_user = request.user
            document.save()
        except Exception as e:
            logger.error(f"Error updating Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while updating Drafting Document.')
            return redirect('drafting:documents_list', folder_id=folder_id)

        logger.info(f"Drafting Document {document.document_title} was updated.")
        return redirect('drafting:documents_list', folder_id=folder_id)


Contents of ../../apps/drafting/views/document/drafting_documents_save_content_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_documents_save_content_views.py
#  Last Modified: 2024-10-15 21:18:30
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 21:18:31
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_SaveContent(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        document = get_object_or_404(DraftingDocument, id=document_id)

        try:
            document_content = request.POST.get('draft_text')
            if document_content:
                document.document_content_json_quill = document_content
                document.save()
        except Exception as e:
            logger.error(f"Error updating Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while updating Drafting Document.')
            return redirect('drafting:documents_detail', folder_id=folder_id, document_id=document_id)

        logger.info(f"Drafting Document {document.document_title} was updated.")
        return redirect('drafting:documents_detail', folder_id=folder_id, document_id=document_id)


Contents of ../../apps/drafting/views/document/drafting_documents_detail_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_documents_create_update_views.py
#  Last Modified: 2024-10-14 14:03:21
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 14:03:22
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DraftingView_DocumentDetail(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to list Drafting Documents.")
            return context
        ##############################

        try:
            user_orgs = Organization.objects.filter(users__in=[self.request.user])
            document_id = self.kwargs.get('document_id')
            document = DraftingDocument.objects.get(id=document_id)
            context['document'] = document
            context['folder'] = document.document_folder
            content = document.document_content_json_quill
        except Exception as e:
            logger.error(f"Error getting Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while getting Drafting Document.')
            return context

        context['content'] = content
        logger.info(f"Drafting Document {document.document_title} was viewed.")
        return context


Contents of ../../apps/drafting/views/document/drafting_documents_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_documents_create_views.py
#  Last Modified: 2024-10-14 18:48:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:48:19
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingFolder, DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_DocumentCreate(LoginRequiredMixin, View):

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to add Drafting Documents.")
            return redirect('drafting:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        try:
            folder = get_object_or_404(DraftingFolder, id=folder_id)
            document = DraftingDocument.objects.create(
                organization=folder.organization,
                document_folder=folder,
                document_title=request.POST.get('document_title'),
                copilot_assistant_id=request.POST.get('copilot_assistant'),
                context_instructions=request.POST.get('context_instructions', ''),
                target_audience=request.POST.get('target_audience', ''),
                tone=request.POST.get('tone', ''),
                created_by_user=request.user,
                last_updated_by_user=request.user
            )
        except Exception as e:
            logger.error(f"Error creating Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while creating Drafting Document.')
            return redirect('drafting:documents_list', folder_id=folder_id)

        logger.info(f"Drafting Document {document.document_title} was created.")
        return redirect('drafting:documents_detail', folder_id=folder.id, document_id=document.id)


Contents of ../../apps/drafting/views/document/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-14 18:44:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:44:36
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .drafting_documents_create_views import *
from .drafting_documents_detail_views import *
from .drafting_documents_delete_views import *
from .drafting_documents_list_views import *
from .drafting_documents_update_views import *
from .drafting_documents_save_content_views import *


Contents of ../../apps/drafting/views/document/drafting_documents_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_documents_delete_views.py
#  Last Modified: 2024-10-14 14:07:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:52:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_DocumentDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to delete Drafting Documents.")
            return redirect('drafting:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        document = get_object_or_404(DraftingDocument, id=document_id)

        try:
            document.delete()
        except Exception as e:
            logger.error(f"Error deleting Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while deleting Drafting Document.')
            return redirect('drafting:documents_list', folder_id=folder_id)

        logger.info(f"Drafting Document {document.document_title} was deleted.")
        return redirect('drafting:documents_list', folder_id=folder_id)


Contents of ../../apps/drafting/views/document/drafting_documents_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: drafting_documents_list_views.py
#  Last Modified: 2024-10-14 14:07:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-14 18:54:06
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingFolder, DraftingDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DraftingView_DocumentList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to list Drafting Documents.")
            return context
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(DraftingFolder, id=folder_id)

        documents = DraftingDocument.objects.filter(document_folder=folder)
        assistants = Assistant.objects.filter(organization=folder.organization)
        paginator = Paginator(documents, 10)
        page = self.request.GET.get('page')

        try:
            documents = paginator.page(page)
        except PageNotAnInteger:
            documents = paginator.page(1)
        except EmptyPage:
            documents = paginator.page(paginator.num_pages)

        context['folder'] = folder
        context['documents'] = documents
        context['assistants'] = assistants
        logger.info(f"Drafting Documents in Folder {folder.name} were listed.")
        return context


Contents of ../../apps/drafting/views/public/public_repo_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_repo_commands_views.py
#  Last Modified: 2024-10-31 03:06:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaRepoCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Repo Command is required.")
            return JsonResponse({"output": None, "message": "Repo Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_repo_command(command=command)
        logger.info(f"Repo Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/public_select_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_select_commands_views.py
#  Last Modified: 2024-10-31 03:06:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:58
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaSelectCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        selected_text = request.POST.get('selected_text', "")
        if selected_text is None:
            logger.error(f"Selected Text is required.")
            return JsonResponse({"output": None, "message": "Selected Text is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        command = request.POST.get('command')
        if command is None:
            logger.error(f"Select Command is required.")
            return JsonResponse({"output": None, "message": "Select Command is required."})

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_select_command(selected_text=selected_text, command=command)
        logger.info(f"Select Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/public_auto_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_auto_commands_views.py
#  Last Modified: 2024-10-31 03:06:10
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:10
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaAutoCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_auto_command()
        logger.info(f"Auto Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/public_sql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_sql_commands_views.py
#  Last Modified: 2024-10-31 03:07:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaSQLCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"SQL Command is required.")
            return JsonResponse({"output": None, "message": "SQL Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_sql_command(command=command)
        logger.info(f"SQL Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 03:04:50
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:04:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .public_img_commands_views import *
from .public_sql_commands_views import *
from .public_ssh_commands_views import *
from .public_web_commands_views import *
from .public_ai_command_views import *
from .public_repo_commands_views import *
from .public_vect_commands_views import *
from .public_auto_commands_views import *
from .public_nosql_commands_views import *
from .public_select_commands_views import *


Contents of ../../apps/drafting/views/public/public_web_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_web_commands_views.py
#  Last Modified: 2024-10-31 03:07:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaWebCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Web Command is required.")
            return JsonResponse({"output": None, "message": "Web Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_web_command(command=command)
        logger.info(f"Web Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/public_ai_command_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_ai_command_views.py
#  Last Modified: 2024-10-31 03:05:30
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:05:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaAICommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"AI Command is required.")
            return JsonResponse({"output": None, "message": "AI Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_ai_command(command=command)
        logger.info(f"AI Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/public_nosql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_nosql_commands_views.py
#  Last Modified: 2024-10-31 03:06:43
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaNoSQLCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"NoSQL Command is required.")
            return JsonResponse({"output": None, "message": "NoSQL Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_nosql_command(command=command)
        logger.info(f"NoSQL Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/public_img_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_img_commands_views.py
#  Last Modified: 2024-10-31 03:06:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaImgCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Img Command is required.")
            return JsonResponse({"output": None, "message": "Img Command is required for image generation."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_img_command(command=command)
        logger.info(f"Img Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/public_ssh_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_ssh_commands_views.py
#  Last Modified: 2024-10-31 03:07:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaSSHCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"SSH Command is required.")
            return JsonResponse({"output": None, "message": "SSH Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_ssh_command(command=command)
        logger.info(f"SSH Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/public/public_vect_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_vect_commands_views.py
#  Last Modified: 2024-10-31 03:07:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:27
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.drafting.drafting_executor_public import DraftingExecutionManager_Public
from apps.drafting.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class DraftingView_PublicGenerateViaVectCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Vect Command is required.")
            return JsonResponse({"output": None, "message": "Vect Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = DraftingExecutionManager_Public(drafting_google_apps_connection=connection_object,
                                             text_content=text_content)
        response_json = xc.execute_vect_command(command=command)
        logger.info(f"Vect Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/ssh_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: ssh_commands.py
#  Last Modified: 2024-10-15 23:19:20
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:19:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaSSHCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_ssh_command(command=command)
        except Exception as e:
            logger.error(f"Error executing SSH Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing SSH Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"SSH Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/vect_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: vect_commands.py
#  Last Modified: 2024-10-15 23:19:29
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:19:29
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaVectCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_vect_command(command=command)
        except Exception as e:
            logger.error(f"Error executing Vect Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing Vect Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Vect Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/img_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: gen_commands.py
#  Last Modified: 2024-10-15 23:18:09
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:18:10
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaImgCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_img_command(command=command)
        except Exception as e:
            logger.error(f"Error executing Img Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing Img Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Img Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/web_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: web_commands.py
#  Last Modified: 2024-10-15 23:18:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:18:49
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaWebCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_web_command(command=command)
        except Exception as e:
            logger.error(f"Error executing Web Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing Web Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Web Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-15 23:16:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:16:49
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .ai_commands_views import *
from .img_commands_views import *
from .sql_commands_views import *
from .ssh_commands_views import *
from .web_commands_views import *
from .nosql_commands_views import *
from .auto_commands_views import *
from .vect_commands_views import *
from .select_commands_views import *


Contents of ../../apps/drafting/views/drafting_commands/nosql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: nosql_commands.py
#  Last Modified: 2024-10-15 23:19:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:19:06
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaNoSQLCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_nosql_command(command=command)
        except Exception as e:
            logger.error(f"Error executing NoSQL Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing NoSQL Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"NoSQL Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/ai_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: ai_commands.py
#  Last Modified: 2024-10-15 23:16:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:16:59
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaAICommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_ai_command(command=command)
        except Exception as e:
            logger.error(f"Error executing AI Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing AI Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"AI Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/sql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sql_commands.py
#  Last Modified: 2024-10-15 23:18:57
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:18:57
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaSQLCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_sql_command(command=command)
        except Exception as e:
            logger.error(f"Error executing SQL Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing SQL Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"SQL Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/repo_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: repo_commands_views.py
#  Last Modified: 2024-10-16 23:32:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-16 23:32:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaRepoCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_repo_command(command=command)
        except Exception as e:
            logger.error(f"Error executing Repo Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing Repo Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Repo Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/auto_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: auto_commands.py
#  Last Modified: 2024-10-15 23:18:00
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:18:01
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaAutoCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_auto_command()
        except Exception as e:
            logger.error(f"Error executing Auto Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing Auto Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Auto Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/drafting_commands/select_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: select_commands.py
#  Last Modified: 2024-10-15 23:17:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:17:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.drafting.drafting_executor import DraftingExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class DraftingView_GenerateViaSelectCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(DraftingDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Drafting Documents.")
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            selected_text = request.POST.get('selected_text', "")
            command = request.POST.get('command')
            xc = DraftingExecutionManager(drafting_document=document)
            response_json = xc.execute_select_command(selected_text=selected_text, command=command)
        except Exception as e:
            logger.error(f"Error executing Select Command for Drafting Document: {e}")
            messages.error(self.request, 'An error occurred while executing Select Command.')
            return redirect('drafting:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Select Command was executed for Drafting Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/drafting/views/google_apps_connection/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 03:23:07
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:23:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .google_apps_connection_list_views import *
from .google_apps_connection_create_views import *
from .google_apps_connection_delete_views import *
from .google_apps_connection_update_views import *


Contents of ../../apps/drafting/views/google_apps_connection/google_apps_connection_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_create_views.py
#  Last Modified: 2024-10-31 03:23:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:23:17
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingGoogleAppsConnection
from apps.drafting.utils import generate_google_apps_connection_api_key
from apps.user_permissions.utils import PermissionNames


class DraftingView_GoogleAppsConnectionCreate(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_DRAFTING_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_DRAFTING_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to add Drafting Google Apps Connections.")
            return redirect('drafting:google_apps_connections_list')
        ##############################

        assistant_id = request.POST.get('assistant')
        if not assistant_id:
            messages.error(request, "Assistant field is required.")
            return redirect('drafting:google_apps_connections_list')

        try:
            assistant = get_object_or_404(Assistant, id=assistant_id)

            connection, created = DraftingGoogleAppsConnection.objects.get_or_create(
                owner_user=request.user, drafting_assistant=assistant,
                defaults={'connection_api_key': generate_google_apps_connection_api_key()}
            )

            if not created:
                messages.warning(request, "A connection for this model already exists. Please renew if necessary.")
            else:
                messages.success(request, "Connection successfully created.")
        except Exception as e:
            messages.error(request, "An error occurred while creating connection: " + str(e))
            return redirect('drafting:google_apps_connections_list')

        return redirect('drafting:google_apps_connections_list')


Contents of ../../apps/drafting/views/google_apps_connection/google_apps_connection_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_delete_views.py
#  Last Modified: 2024-10-31 03:23:40
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:23:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingGoogleAppsConnection
from apps.user_permissions.utils import PermissionNames


class DraftingView_GoogleAppsConnectionDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_DRAFTING_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_DRAFTING_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete Drafting Google Apps Connections.")
            return redirect('drafting:google_apps_connections_list')
        ##############################

        connection = get_object_or_404(DraftingGoogleAppsConnection, id=connection_id, owner_user=request.user)

        try:
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection.")
            return redirect('drafting:google_apps_connections_list')

        messages.success(request, "Connection successfully deleted.")
        return redirect('drafting:google_apps_connections_list')


Contents of ../../apps/drafting/views/google_apps_connection/google_apps_connection_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_manage_views.py
#  Last Modified: 2024-10-31 03:23:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:23:26
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingGoogleAppsConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class DraftingView_GoogleAppsConnectionList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_DRAFTING_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_DRAFTING_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to list Drafting Google Apps Connections.")
            return context
        ##############################

        try:
            context['connections'] = DraftingGoogleAppsConnection.objects.filter(owner_user=self.request.user)
            user_orgs = Organization.objects.filter(users__in=[self.request.user])
            context['assistants'] = Assistant.objects.filter(organization__in=user_orgs)
        except Exception as e:
            messages.error(self.request, 'An error occurred while getting assistants.')
            return context

        return context


Contents of ../../apps/drafting/views/google_apps_connection/google_apps_connection_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_update_views.py
#  Last Modified: 2024-10-31 03:23:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:23:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingGoogleAppsConnection
from apps.drafting.utils import generate_google_apps_connection_api_key
from apps.user_permissions.utils import PermissionNames


class DraftingView_GoogleAppsConnectionUpdate(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('pk')
        assistant_id = request.POST.get('assistant')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_DRAFTING_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DRAFTING_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to update Drafting Google Apps Connections.")
            return redirect('drafting:google_apps_connections_list')
        ##############################

        try:
            connection = get_object_or_404(DraftingGoogleAppsConnection, id=connection_id, owner_user=request.user)
            connection.connection_api_key = generate_google_apps_connection_api_key()
            new_assistant = Assistant.objects.get(id=assistant_id)
            connection.drafting_assistant = new_assistant
            connection.save()
        except Exception as e:
            messages.error(request, "An error occurred while updating the API key.")
            return redirect('drafting:google_apps_connections_list')

        messages.success(request, "API key successfully updated.")
        return redirect('drafting:google_apps_connections_list')


Contents of ../../apps/landing/views/faq_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: faq_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.views.generic import TemplateView

from web_project import TemplateLayout, TemplateHelper


class LandingView_FAQ(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            "display_customizer": False})
        TemplateHelper.map_context(context)
        return context


Contents of ../../apps/landing/views/landing_page_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: landing_page_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.views.generic import TemplateView

from web_project import TemplateLayout, TemplateHelper


class LandingView_Index(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            "display_customizer": False})
        TemplateHelper.map_context(context)
        return context


Contents of ../../apps/landing/views/integration_to_organizations_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: integration_to_organizations_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.views.generic import TemplateView

from web_project import TemplateLayout, TemplateHelper


class LandingView_IntegrationToOrganizations(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            "display_customizer": False})
        TemplateHelper.map_context(context)
        return context


Contents of ../../apps/landing/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .faq_views import *
from .endeavours_views import *
from .landing_page_views import *
from .contact_form_submit_views import *
from .not_accredited_admin_views import *
from .integration_to_organizations_views import *
from .electron_copilot_releases_views import *


Contents of ../../apps/landing/views/contact_form_submit_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: contact_form_submit_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.models import User
from django.shortcuts import redirect
from django.views.generic import TemplateView
from django.core.mail import send_mail

from config import settings
from web_project import TemplateLayout, TemplateHelper


logger = logging.getLogger(__name__)


class LandingView_ContactFormSubmit(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            "display_customizer": False,})
        TemplateHelper.map_context(context)
        return context

    def post(self, request, *args, **kwargs):
        full_name = request.POST['fullname']
        email = request.POST['email']
        msg = request.POST['message']
        username = request.POST['username']
        usernames = User.objects.values_list('username', flat=True)
        email_msg = f"""
        Full Name: {full_name}
        Email: {email}

        Message:

        ```
        {msg}
        ```
        """

        if username and username in usernames:
            client = User.objects.get(username=username)
            if client.email == email:
                subject = f"[IMPORTANT] VERIFIED CLIENT QUERY: Message from {username} ({full_name})"
            else:
                subject = f"[IMPORTANT] UNVERIFIED CLIENT QUERY: Message from {username} ({full_name}) - Email Mismatch"
                email_msg += f"""
                [WARNING:] The email address provided does not match the email address in the database.
                Database Email: {client.email}
                Provided Email: {email}
                ------------------
                """

            email_msg += f"""

                CLIENT SIGNATURE:
                -----------------
                User: {client.username}
                First Name: {client.profile.first_name}
                Last Name: {client.profile.last_name}
                Email: {client.email}
                Phone: {client.profile.phone_number}
                Address: {client.profile.address}
                City: {client.profile.city}
                Country: {client.profile.country}
                Postal Code: {client.profile.postal_code}
                ------------------
                """
        else:
            subject = f"VISITOR QUERY: Message from {full_name}"
        send_mail(
            subject, email_msg, settings.DEFAULT_FROM_EMAIL, [settings.DEFAULT_FROM_EMAIL, email],
            fail_silently=False,
        )

        logger.info(f"Contact Form was submitted by User: {request.user.id}.")
        return redirect("landing:contact_form_submit", )


Contents of ../../apps/landing/views/endeavours_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: endeavours_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.views.generic import TemplateView

from web_project import TemplateLayout, TemplateHelper


class LandingView_Endeavours(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            "display_customizer": False})
        TemplateHelper.map_context(context)
        return context


Contents of ../../apps/landing/views/electron_copilot_releases_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: electron_copilot_releases_views.py
#  Last Modified: 2024-10-30 18:05:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 18:05:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.views.generic import TemplateView

from web_project import TemplateLayout, TemplateHelper


class LandingView_ElectronCopilotReleases(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            "display_customizer": False})
        TemplateHelper.map_context(context)
        return context


Contents of ../../apps/landing/views/not_accredited_admin_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: not_accredited_admin_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.views.generic import TemplateView

from web_project import TemplateLayout, TemplateHelper


class LandingView_AdminNotAccredited(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            "display_customizer": False})
        TemplateHelper.map_context(context)
        return context


Contents of ../../apps/formica/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-02 12:58:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 12:58:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .google_apps_connection import *
from .public import *


Contents of ../../apps/formica/views/public/public_repo_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_repo_commands_views.py
#  Last Modified: 2024-10-31 03:06:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaRepoCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Repo Command is required.")
            return JsonResponse({"output": None, "message": "Repo Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_repo_command(command=command)
        logger.info(f"Repo Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/public_select_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_select_commands_views.py
#  Last Modified: 2024-10-31 03:06:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:58
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaSelectCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        selected_text = request.POST.get('selected_text', "")
        if selected_text is None:
            logger.error(f"Selected Text is required.")
            return JsonResponse({"output": None, "message": "Selected Text is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        command = request.POST.get('command')
        if command is None:
            logger.error(f"Select Command is required.")
            return JsonResponse({"output": None, "message": "Select Command is required."})

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_select_command(selected_text=selected_text, command=command)
        logger.info(f"Select Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/public_auto_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_auto_commands_views.py
#  Last Modified: 2024-10-31 03:06:10
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:10
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaAutoCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_auto_command()
        logger.info(f"Auto Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/public_sql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_sql_commands_views.py
#  Last Modified: 2024-10-31 03:07:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaSQLCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"SQL Command is required.")
            return JsonResponse({"output": None, "message": "SQL Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_sql_command(command=command)
        logger.info(f"SQL Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 03:04:50
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:04:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .public_img_commands_views import *
from .public_sql_commands_views import *
from .public_ssh_commands_views import *
from .public_web_commands_views import *
from .public_ai_command_views import *
from .public_repo_commands_views import *
from .public_vect_commands_views import *
from .public_auto_commands_views import *
from .public_nosql_commands_views import *
from .public_select_commands_views import *


Contents of ../../apps/formica/views/public/public_web_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_web_commands_views.py
#  Last Modified: 2024-10-31 03:07:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaWebCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Web Command is required.")
            return JsonResponse({"output": None, "message": "Web Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_web_command(command=command)
        logger.info(f"Web Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/public_ai_command_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_ai_command_views.py
#  Last Modified: 2024-10-31 03:05:30
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:05:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaAICommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"AI Command is required.")
            return JsonResponse({"output": None, "message": "AI Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_ai_command(command=command)
        logger.info(f"AI Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/public_nosql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_nosql_commands_views.py
#  Last Modified: 2024-10-31 03:06:43
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaNoSQLCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"NoSQL Command is required.")
            return JsonResponse({"output": None, "message": "NoSQL Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_nosql_command(command=command)
        logger.info(f"NoSQL Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/public_img_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_img_commands_views.py
#  Last Modified: 2024-10-31 03:06:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaImgCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Img Command is required.")
            return JsonResponse({"output": None, "message": "Img Command is required for image generation."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_img_command(command=command)
        logger.info(f"Img Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/public_ssh_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_ssh_commands_views.py
#  Last Modified: 2024-10-31 03:07:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaSSHCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"SSH Command is required.")
            return JsonResponse({"output": None, "message": "SSH Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_ssh_command(command=command)
        logger.info(f"SSH Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/public/public_vect_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_vect_commands_views.py
#  Last Modified: 2024-10-31 03:07:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:27
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.formica.formica_executor_public import FormicaExecutionManager_Public
from apps.formica.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class FormicaView_PublicGenerateViaVectCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Vect Command is required.")
            return JsonResponse({"output": None, "message": "Vect Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = FormicaExecutionManager_Public(formica_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_vect_command(command=command)
        logger.info(f"Vect Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/formica/views/google_apps_connection/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-02 12:45:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 12:45:17
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .google_apps_connection_list_views import *
from .google_apps_connection_create_views import *
from .google_apps_connection_update_views import *
from .google_apps_connection_delete_views import *


Contents of ../../apps/formica/views/google_apps_connection/google_apps_connection_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_create_views.py
#  Last Modified: 2024-11-02 14:57:08
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 19:38:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.formica.models import FormicaGoogleAppsConnection
from apps.formica.utils import generate_google_apps_connection_api_key
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class FormicaView_GoogleAppsConnectionCreate(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_FORMICA_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_FORMICA_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to add Formica Google Apps Connections.")
            return redirect('formica:google_apps_connections_list')
        ##############################

        assistant_id = request.POST.get('assistant')
        if not assistant_id:
            messages.error(request, "Assistant field is required.")
            return redirect('formica:google_apps_connections_list')

        try:
            assistant = get_object_or_404(Assistant, id=assistant_id)
            connection, created = FormicaGoogleAppsConnection.objects.get_or_create(
                owner_user=request.user, formica_assistant=assistant,
                defaults={'connection_api_key': generate_google_apps_connection_api_key()}
            )

            if not created:
                messages.warning(request, "A connection for this model already exists. Please renew if necessary.")
            else:
                messages.success(request, "Connection successfully created.")
        except Exception as e:
            logger.error(f"Error creating Google Apps Connection: {e}")
            messages.error(request, "Error creating Google Apps Connection.")
            return redirect('formica:google_apps_connections_list')

        logger.info(f"Google Apps Connection was created by User: {request.user.id}.")
        return redirect('formica:google_apps_connections_list')


Contents of ../../apps/formica/views/google_apps_connection/google_apps_connection_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_delete_views.py
#  Last Modified: 2024-11-02 14:57:08
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 19:39:14
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.formica.models import FormicaGoogleAppsConnection
from apps.user_permissions.utils import PermissionNames


class FormicaView_GoogleAppsConnectionDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_FORMICA_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_FORMICA_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete Formica Google Apps Connections.")
            return redirect('formica:google_apps_connections_list')
        ##############################

        connection = get_object_or_404(FormicaGoogleAppsConnection, id=connection_id, owner_user=request.user)

        try:
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection.")
            return redirect('formica:google_apps_connections_list')

        messages.success(request, "Connection successfully deleted.")
        return redirect('formica:google_apps_connections_list')


Contents of ../../apps/formica/views/google_apps_connection/google_apps_connection_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_list_views.py
#  Last Modified: 2024-11-02 14:57:08
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 19:40:11
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.formica.models import FormicaGoogleAppsConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class FormicaView_GoogleAppsConnectionList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_FORMICA_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_FORMICA_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to list Formica Google Apps Connections.")
            return context
        ##############################

        try:
            context['connections'] = FormicaGoogleAppsConnection.objects.filter(owner_user=self.request.user)
            user_orgs = Organization.objects.filter(users__in=[self.request.user])
            context['assistants'] = Assistant.objects.filter(organization__in=user_orgs)
        except Exception as e:
            messages.error(self.request, "Error listing Formica Google Apps Connections.")
            return context

        return context


Contents of ../../apps/formica/views/google_apps_connection/google_apps_connection_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_update_views.py
#  Last Modified: 2024-11-02 13:00:22
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 13:08:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.


from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.formica.models import FormicaGoogleAppsConnection
from apps.formica.utils import generate_google_apps_connection_api_key
from apps.user_permissions.utils import PermissionNames


class FormicaView_GoogleAppsConnectionUpdate(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('pk')
        assistant_id = request.POST.get('assistant')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_FORMICA_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_FORMICA_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to update Formica Google Apps Connections.")
            return redirect('formica:google_apps_connections_list')
        ##############################

        try:
            connection = get_object_or_404(FormicaGoogleAppsConnection, id=connection_id, owner_user=request.user)
            connection.connection_api_key = generate_google_apps_connection_api_key()
            new_assistant = Assistant.objects.get(id=assistant_id)
            connection.formica_assistant = new_assistant
            connection.save()
        except Exception as e:
            messages.error(request, "An error occurred while updating the API key.")
            return redirect('formica:google_apps_connections_list')

        messages.success(request, "API key successfully updated.")
        return redirect('formica:google_apps_connections_list')


Contents of ../../apps/binexus/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-22 02:04:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 02:04:58
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .process import *
from .elite_agent import *


Contents of ../../apps/binexus/views/elite_agent/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-22 21:58:14
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 21:58:14
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .elite_agent_delete_views import *


Contents of ../../apps/binexus/views/elite_agent/elite_agent_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: elite_agent_delete_views.py
#  Last Modified: 2024-10-22 21:58:08
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 21:58:09
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.binexus.models import BinexusEliteAgent
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class BinexusView_EliteAgentDelete(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_BINEXUS_ELITES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BINEXUS_ELITES):
            messages.error(self.request, "You do not have permission to execute Binexus Elite Agents.")
            return redirect('binexus:process_detail', pk=kwargs.get('pk'))
        ##############################

        agent_id = kwargs.get('pk')
        agent = BinexusEliteAgent.objects.get(id=agent_id)
        process_id = agent.binexus_process.id
        try:
            agent.delete()
            logger.info(f"Elite agent deleted successfully.")
            messages.success(request, "Elite agent deleted successfully.")
        except Exception as e:
            logger.error(f"Error deleting elite agent: {e}")
            messages.error(request, f"Error deleting elite agent: {e}")

        return redirect('binexus:process_detail', pk=process_id)


Contents of ../../apps/binexus/views/process/binexus_process_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: binexus_process_list_views.py
#  Last Modified: 2024-10-22 18:38:50
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 18:38:50
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.binexus.models import BinexusProcess
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class BinexusView_ProcessList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_BINEXUS_PROCESSES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_BINEXUS_PROCESSES):
            messages.error(self.request, "You do not have permission to list Binexus Processes.")
            return context
        ##############################

        try:
            user_orgs = Organization.objects.filter(users__in=[self.request.user])
            processes_by_org = {
                org: BinexusProcess.objects.filter(organization=org)
                for org in user_orgs
            }
            context['processes_by_org'] = processes_by_org
        except Exception as e:
            messages.error(self.request, "Error listing the Binexus Processes.")
            return context

        return context


Contents of ../../apps/binexus/views/process/binexus_process_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: binexus_process_update_views.py
#  Last Modified: 2024-10-22 18:39:39
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 18:39:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.binexus.models import BinexusProcess
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class BinexusView_ProcessUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        process_id = self.kwargs.get('pk')
        binexus_process = BinexusProcess.objects.get(id=process_id)
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        llm_models = LLMCore.objects.filter(organization__in=user_orgs)
        context['organizations'] = user_orgs
        context['llm_models'] = llm_models
        context['binexus_process'] = binexus_process
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_BINEXUS_PROCESSES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_BINEXUS_PROCESSES):
            messages.error(self.request, "You do not have permission to update Binexus Processes.")
            return redirect('binexus:process_list')
        ##############################

        process_id = self.kwargs.get('pk')
        try:
            binexus_process = BinexusProcess.objects.get(id=process_id)
            binexus_process.organization_id = request.POST.get('organization')
            binexus_process.llm_model_id = request.POST.get('llm_model')
            binexus_process.process_name = request.POST.get('process_name')
            binexus_process.process_description = request.POST.get('process_description')
            binexus_process.process_objective = request.POST.get('process_objective')
            binexus_process.process_success_criteria = request.POST.get('process_success_criteria')
            binexus_process.fitness_manager_selectiveness = request.POST.get('fitness_manager_selectiveness')

            gene_names = request.POST.getlist('additional_genes_keys[]')
            gene_values = request.POST.getlist('additional_genes_values[]')

            genes_data = {}
            for i in range(len(gene_names)):
                try:
                    gene_name = gene_names[i].strip()
                    raw_values = gene_values[i].strip()
                    values_list = [v.strip() for v in raw_values.split(',') if v.strip()]
                    if gene_name and values_list:
                        genes_data[gene_name] = values_list
                except Exception as e:
                    logger.error(f"Error parsing gene data: {e}")
                    continue

            # Optimization Hyper-Parameters
            binexus_process.optimization_generations = request.POST.get('optimization_generations')
            binexus_process.optimization_population_size = request.POST.get('optimization_population_size')
            binexus_process.optimization_breeding_pool_rate = request.POST.get('optimization_breeding_pool_rate')
            binexus_process.optimization_mutation_rate_per_individual = request.POST.get(
                'optimization_mutation_rate_per_individual')
            binexus_process.optimization_mutation_rate_per_gene = request.POST.get(
                'optimization_mutation_rate_per_gene')
            binexus_process.optimization_crossover_rate = request.POST.get('optimization_crossover_rate')
            binexus_process.self_breeding_possible = request.POST.get('self_breeding_possible') == 'on'
            binexus_process.additional_genes = genes_data
            binexus_process.save()
        except Exception as e:
            logger.error(f"Error updating Binexus Process: {e}")
            messages.error(request, f"Error updating Binexus Process: {e}")
            return redirect('binexus:process_detail', pk=process_id)

        logger.info(f"Binexus Process updated successfully: {binexus_process}")
        return redirect('binexus:process_list')


Contents of ../../apps/binexus/views/process/binexus_process_execute_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: binexus_process_rerun_views.py
#  Last Modified: 2024-10-22 18:39:29
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 18:39:29
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.binexus.models import BinexusProcess
from apps.core.binexus.binexus_executor import BinexusExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class BinexusView_ProcessExecute(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - EXECUTE_BINEXUS_PROCESSES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.EXECUTE_BINEXUS_PROCESSES):
            messages.error(self.request, "You do not have permission to execute Binexus Processes.")
            return redirect('binexus:process_detail', pk=kwargs.get('pk'))
        ##############################

        process_id = kwargs.get('pk')
        process_object: BinexusProcess = BinexusProcess.objects.get(id=process_id)
        try:
            xc = BinexusExecutionManager(binexus_process=process_object)
        except Exception as e:
            messages.error(request, f"Error occurred while executing the process: {e}")
            return redirect('binexus:process_detail', pk=kwargs.get('pk'))

        try:
            success, error = xc.execute_binexus()
            if error is not None:
                logger.error(f"Error occurred while executing the process: {error}")
                messages.error(request, f"Error occurred while executing the process: {error}")
                return redirect('binexus:process_detail', pk=kwargs.get('pk'))
        except Exception as e:
            logger.error(f"Error occurred while executing the process: {e}")
            messages.error(request, f"Error occurred while executing the process: {e}")
            return redirect('binexus:process_detail', pk=kwargs.get('pk'))

        logger.info(f"Process executed successfully.")
        messages.success(request, f"Process executed successfully.")
        return redirect('binexus:process_detail', pk=kwargs.get('pk'))


Contents of ../../apps/binexus/views/process/binexus_process_detail_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: binexus_process_detail_views.py
#  Last Modified: 2024-10-22 18:39:11
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 18:39:11
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.binexus.models import BinexusProcess, BinexusEliteAgent
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class BinexusView_ProcessDetail(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_BINEXUS_PROCESSES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_BINEXUS_PROCESSES):
            messages.error(self.request, "You do not have permission to list Binexus Processes.")
            return context
        ##############################

        try:
            process_id = self.kwargs.get('pk')
            binexus_process = get_object_or_404(BinexusProcess, id=process_id)
            elite_agents = BinexusEliteAgent.objects.filter(binexus_process=binexus_process)
            context['binexus_process'] = binexus_process
            context['elite_agents'] = elite_agents
        except Exception as e:
            messages.error(self.request, "Error listing the Binexus Process.")
            return context

        return context


Contents of ../../apps/binexus/views/process/binexus_process_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: binexus_process_create_views.py
#  Last Modified: 2024-10-22 18:38:42
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 18:38:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.binexus.models import BinexusProcess
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class BinexusView_ProcessCreate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        llm_models = LLMCore.objects.filter(organization__in=user_orgs)
        context['organizations'] = user_orgs
        context['llm_models'] = llm_models
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_BINEXUS_PROCESSES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_BINEXUS_PROCESSES):
            messages.error(self.request, "You do not have permission to create Binexus Processes.")
            return redirect('binexus:process_list')
        ##############################

        try:
            organization = request.POST.get('organization')
            llm_model = request.POST.get('llm_model')
            process_name = request.POST.get('process_name')
            process_description = request.POST.get('process_description')
            process_objective = request.POST.get('process_objective')
            process_success_criteria = request.POST.get('process_success_criteria')
            fitness_manager_selectiveness = request.POST.get('fitness_manager_selectiveness')

            gene_names = request.POST.getlist('additional_genes_keys[]')
            gene_values = request.POST.getlist('additional_genes_values[]')

            genes_data = {}
            for i in range(len(gene_names)):
                try:
                    gene_name = gene_names[i].strip()
                    raw_values = gene_values[i].strip()
                    values_list = [v.strip() for v in raw_values.split(',') if v.strip()]
                    if gene_name and values_list:
                        genes_data[gene_name] = values_list
                except Exception as e:
                    logger.error(f"Error parsing gene data: {e}")
                    continue

            optimization_generations = request.POST.get('optimization_generations')
            optimization_population_size = request.POST.get('optimization_population_size')
            optimization_breeding_pool_rate = request.POST.get('optimization_breeding_pool_rate')
            optimization_mutation_rate_per_individual = request.POST.get('optimization_mutation_rate_per_individual')
            optimization_mutation_rate_per_gene = request.POST.get('optimization_mutation_rate_per_gene')
            optimization_crossover_rate = request.POST.get('optimization_crossover_rate')
            self_breeding_possible = request.POST.get('self_breeding_possible') == 'on'

            binexus_process = BinexusProcess.objects.create(
                organization_id=organization,
                llm_model_id=llm_model,
                process_name=process_name,
                process_description=process_description,
                process_objective=process_objective,
                process_success_criteria=process_success_criteria,
                fitness_manager_selectiveness=fitness_manager_selectiveness,
                optimization_generations=optimization_generations,
                optimization_population_size=optimization_population_size,
                optimization_breeding_pool_rate=optimization_breeding_pool_rate,
                optimization_mutation_rate_per_individual=optimization_mutation_rate_per_individual,
                optimization_mutation_rate_per_gene=optimization_mutation_rate_per_gene,
                optimization_crossover_rate=optimization_crossover_rate,
                additional_genes=genes_data,
                self_breeding_possible=self_breeding_possible,
                created_by_user=request.user
            )
            binexus_process.save()
        except Exception as e:
            logger.error(f"Error creating Binexus Process: {e}")
            messages.error(request, "Error creating Binexus Process.")
            return redirect('binexus:process_list')

        logger.info(f"Binexus Process created successfully.")
        return redirect('binexus:process_list')


Contents of ../../apps/binexus/views/process/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-22 18:38:12
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 18:38:12
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .binexus_process_list_views import *
from .binexus_process_execute_views import *
from .binexus_process_create_views import *
from .binexus_process_delete_views import *
from .binexus_process_detail_views import *
from .binexus_process_update_views import *
from .binexus_process_purge_data_views import *


Contents of ../../apps/binexus/views/process/binexus_process_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: binexus_process_delete_views.py
#  Last Modified: 2024-10-22 18:38:57
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 18:38:58
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.binexus.models import BinexusProcess
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class BinexusView_ProcessDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        process_id = self.kwargs.get('pk')
        binexus_process = BinexusProcess.objects.get(id=process_id)
        context['binexus_process'] = binexus_process
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_BINEXUS_PROCESSES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BINEXUS_PROCESSES):
            messages.error(self.request, "You do not have permission to delete Binexus Processes.")
            return redirect('binexus:process_list')
        ##############################

        try:
            process_id = self.kwargs.get('pk')
            binexus_process = BinexusProcess.objects.get(id=process_id)
            binexus_process.delete()
        except Exception as e:
            logger.error(f"[BinexusView_ProcessDelete] Error deleting the Binexus Process: {e}")
            messages.error(self.request, "Error deleting the Binexus Process.")
            return redirect('binexus:process_list')

        logger.info(f'Binexus Process deleted successfully.')
        return redirect('binexus:process_list')


Contents of ../../apps/binexus/views/process/binexus_process_purge_data_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: binexus_process_purge_data_views.py
#  Last Modified: 2024-10-23 02:02:53
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-23 02:02:53
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.binexus.models import BinexusProcess, BinexusEliteAgent
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class BinexusView_ProcessPurgeData(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_BINEXUS_PROCESSES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BINEXUS_PROCESSES):
            messages.error(self.request, "You do not have permission to delete Binexus Processes.")
            return redirect('binexus:process_list')
        ##############################

        process_id = kwargs.get('pk')
        try:
            process: BinexusProcess = BinexusProcess.objects.get(id=process_id)
            process.post_processing_history_average_fitness_per_epoch = []
            process.post_processing_history_best_fitness_per_epoch = []
            process.post_processing_history_worst_fitness_per_epoch = []
            process.post_processing_history_average_of_average_fitnesses = 0.0
            process.post_processing_history_average_of_best_fitnesses = 0.0
            process.post_processing_history_average_of_worst_fitnesses = 0.0
            process.post_processing_history_visual_chart = None
            process.save()
            logger.info(f"Binexus process internal information purged successfully.")

            elite_agents = BinexusEliteAgent.objects.filter(binexus_process=process)
            for elite_agent in elite_agents:
                elite_agent.delete()
            logger.info(f"Binexus elite agents purged successfully.")
        except Exception as e:
            logger.error(f"Error purging binexus process data: {e}")
            messages.error(request, f"Error purging binexus process data: {e}")
            return redirect('binexus:process_detail', pk=process_id)

        messages.success(request, "Binexus process data purged successfully.")
        logger.info(f"Binexus process data purged successfully.")
        return redirect('binexus:process_detail', pk=process_id)


Contents of ../../apps/datasource_browsers/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .browser import *
from .browser_log import *


Contents of ../../apps/datasource_browsers/views/browser/create_browser_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_browser_connection_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.datasource_browsers.utils import BROWSER_TYPES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class BrowserView_BrowserCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            orgs = context_user.organizations.filter(users__in=[context_user])
            context['assistants'] = Assistant.objects.filter(organization__in=orgs)
            context['browser_types'] = BROWSER_TYPES
            context['user'] = context_user
        except Exception as e:
            logger.error(f"User: {context_user} - Data Source Browser Connection - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating Data Source Browser Connection.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - ADD_WEB_BROWSERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_WEB_BROWSERS):
            messages.error(self.request, "You do not have permission to add web browsers.")
            return redirect('datasource_browsers:list')
        ##############################

        browser_name = request.POST.get('name')
        description = request.POST.get('description')
        browser_type = request.POST.get('browser_type')
        agent_id = request.POST.get('assistant')
        browser_selectivity = request.POST.get('data_selectivity', 0.5)
        min_investigation_websites = request.POST.get('minimum_investigation_sites', 2)
        whitelisted_exts = request.POST.getlist('whitelisted_extensions[]')
        blacklisted_exts = request.POST.getlist('blacklisted_extensions[]')

        whitelisted_exts_cleaned = []
        for ext in whitelisted_exts:
            ext = ext.strip()
            if ext != '' and ext is not None and ext != 'None':
                whitelisted_exts_cleaned.append(ext)
        whitelisted_exts = whitelisted_exts_cleaned

        blacklisted_exts_cleaned = []
        for ext in blacklisted_exts:
            ext = ext.strip()
            if ext != '' and ext is not None and ext != 'None':
                blacklisted_exts_cleaned.append(ext)
        blacklisted_exts = blacklisted_exts_cleaned

        ra_javascript = request.POST.get('ra_javascript') == 'on'
        ra_style = request.POST.get('ra_style') == 'on'
        ra_inline_style = request.POST.get('ra_inline_style') == 'on'
        ra_comments = request.POST.get('ra_comments') == 'on'
        ra_links = request.POST.get('ra_links') == 'on'
        ra_meta = request.POST.get('ra_meta') == 'on'
        ra_page_structure = request.POST.get('ra_page_structure') == 'on'
        ra_processing_instructions = request.POST.get('ra_processing_instructions') == 'on'
        ra_embedded = request.POST.get('ra_embedded') == 'on'
        ra_frames = request.POST.get('ra_frames') == 'on'
        ra_forms = request.POST.get('ra_forms') == 'on'
        ra_remove_tags = request.POST.get('ra_remove_tags') == 'on'

        capabilities = {
            "javascript": ra_javascript, "style": ra_style, "inline_style": ra_inline_style, "comments": ra_comments,
            "links": ra_links, "meta": ra_meta, "page_structure": ra_page_structure,
            "processing_instructions": ra_processing_instructions, "embedded": ra_embedded, "frames": ra_frames,
            "forms": ra_forms, "remove_tags": ra_remove_tags
        }
        created_by_user = request.user
        try:
            assistant = Assistant.objects.get(id=agent_id)
            info_feed = DataSourceBrowserConnection.objects.create(
                name=browser_name, description=description, browser_type=browser_type, assistant=assistant,
                data_selectivity=browser_selectivity, minimum_investigation_sites=min_investigation_websites,
                whitelisted_extensions=whitelisted_exts, blacklisted_extensions=blacklisted_exts,
                reading_abilities=capabilities, created_by_user=created_by_user
            )
            info_feed.save()
            logger.info(f"User: {request.user} - Data Source Browser Connection: {info_feed.name} - Created.")
            messages.success(request, 'Data Source Browser Connection created successfully.')
            return redirect('datasource_browsers:list')
        except Assistant.DoesNotExist:
            logger.error('Invalid assistant selected.')
            messages.error(request, 'Invalid assistant selected.')
            return redirect('datasource_browsers:create')
        except Exception as e:
            logger.error(f'Error creating Data Source Browser Connection: {e}')
            messages.error(request, f'Error creating Data Source Browser Connection: {e}')
            return redirect('datasource_browsers:create')


Contents of ../../apps/datasource_browsers/views/browser/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .update_browser_connection_views import *
from .list_browser_connections_views import *
from .create_browser_connection_views import *
from .delete_browser_connection_views import *


Contents of ../../apps/datasource_browsers/views/browser/update_browser_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_browser_connection_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.datasource_browsers.utils import BROWSER_TYPES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class BrowserView_BrowserUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            organizations = context_user.organizations.filter(users__in=[context_user])
            context['assistants'] = Assistant.objects.filter(organization__in=organizations)
            context['browser_types'] = BROWSER_TYPES
            context['user'] = context_user
            connection_id = kwargs.get('pk')
            context['browser_connection'] = get_object_or_404(DataSourceBrowserConnection, pk=connection_id)
        except Exception as e:
            logger.error(f"User: {context_user} - Data Source Browser Connection - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating Data Source Browser Connection.')
            return context

        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_WEB_BROWSERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_WEB_BROWSERS):
            messages.error(self.request, "You do not have permission to update web browsers.")
            return redirect('datasource_browsers:list')
        ##############################

        c_id = kwargs.get('pk')
        browser_c = get_object_or_404(DataSourceBrowserConnection, pk=c_id)

        browser_name = request.POST.get('name')
        description = request.POST.get('description')
        browser_type = request.POST.get('browser_type')
        agent_id = request.POST.get('assistant')
        browser_selecitivity = request.POST.get('data_selectivity', 0.5)
        min_website_investigations = request.POST.get('minimum_investigation_sites', 2)
        whitelisted_exts = request.POST.getlist('whitelisted_extensions[]')
        blacklisted_exts = request.POST.getlist('blacklisted_extensions[]')

        whitelisted_exts_cleaned = []
        for ext in whitelisted_exts:
            ext = ext.strip()
            if ext != '' and ext is not None and ext != 'None':
                whitelisted_exts_cleaned.append(ext)
        whitelisted_exts = whitelisted_exts_cleaned

        blacklisted_exts_cleaned = []
        for ext in blacklisted_exts:
            ext = ext.strip()
            if ext != '' and ext is not None and ext != 'None':
                blacklisted_exts_cleaned.append(ext)
        blacklisted_exts = blacklisted_exts_cleaned

        ra_javascript = request.POST.get('ra_javascript') == 'on'
        ra_style = request.POST.get('ra_style') == 'on'
        ra_inline_style = request.POST.get('ra_inline_style') == 'on'
        ra_comments = request.POST.get('ra_comments') == 'on'
        ra_links = request.POST.get('ra_links') == 'on'
        ra_meta = request.POST.get('ra_meta') == 'on'
        ra_page_structure = request.POST.get('ra_page_structure') == 'on'
        ra_processing_instructions = request.POST.get('ra_processing_instructions') == 'on'
        ra_embedded = request.POST.get('ra_embedded') == 'on'
        ra_frames = request.POST.get('ra_frames') == 'on'
        ra_forms = request.POST.get('ra_forms') == 'on'
        ra_remove_tags = request.POST.get('ra_remove_tags') == 'on'

        capabilities = {
            "javascript": ra_javascript, "style": ra_style, "inline_style": ra_inline_style, "comments": ra_comments,
            "links": ra_links, "meta": ra_meta, "page_structure": ra_page_structure,
            "processing_instructions": ra_processing_instructions, "embedded": ra_embedded, "frames": ra_frames,
            "forms": ra_forms, "remove_tags": ra_remove_tags
        }
        created_by_user = request.user

        try:
            assistant = Assistant.objects.get(id=agent_id)
            browser_c.name = browser_name
            browser_c.description = description
            browser_c.browser_type = browser_type
            browser_c.assistant = assistant
            browser_c.data_selectivity = browser_selecitivity
            browser_c.minimum_investigation_sites = min_website_investigations
            browser_c.whitelisted_extensions = whitelisted_exts
            browser_c.blacklisted_extensions = blacklisted_exts
            browser_c.reading_abilities = capabilities
            browser_c.created_by_user = created_by_user
            browser_c.save()
            logger.info(f"User: {request.user} - Data Source Browser Connection: {browser_c.name} - Updated.")
            messages.success(request, 'Data Source Browser Connection updated successfully.')
            return redirect('datasource_browsers:list')
        except Assistant.DoesNotExist:
            logger.error('Invalid assistant selected.')
            messages.error(request, 'Invalid assistant selected.')
            return redirect('datasource_browsers:update', pk=c_id)
        except Exception as e:
            logger.error(f'Error updating Data Source Browser Connection: {e}')
            messages.error(request, f'Error updating Data Source Browser Connection: {e}')
            return redirect('datasource_browsers:update', pk=c_id)


Contents of ../../apps/datasource_browsers/views/browser/list_browser_connections_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_browser_connections_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class BrowserView_BrowserList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - LIST_WEB_BROWSERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_WEB_BROWSERS):
            messages.error(self.request, "You do not have permission to list web browsers.")
            return context
        ##############################

        try:
            cs_by_orgs = {}
            agents = Assistant.objects.filter(
                organization__in=context_user.organizations.filter(users__in=[context_user]))
            for agent in agents:
                org = agent.organization
                if org not in cs_by_orgs:
                    cs_by_orgs[org] = {}
                if agent not in cs_by_orgs[org]:
                    cs_by_orgs[org][agent] = []

                cs = DataSourceBrowserConnection.objects.filter(assistant=agent)
                cs_by_orgs[org][agent].extend(cs)
        except Exception as e:
            logger.error(f"User: {context_user} - Browser Connections - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing Browser Connections.')
            return context

        logger.info(f"Browser Connections were listed.")
        context['connections_by_organization'] = cs_by_orgs
        context['user'] = context_user
        return context


Contents of ../../apps/datasource_browsers/views/browser/delete_browser_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_browser_connection_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class BrowserView_BrowserDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['browser_connection'] = get_object_or_404(DataSourceBrowserConnection, pk=self.kwargs['pk'])
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_WEB_BROWSERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_WEB_BROWSERS):
            messages.error(self.request, "You do not have permission to delete web browsers.")
            return redirect('datasource_browsers:list')
        ##############################

        browser_c = get_object_or_404(DataSourceBrowserConnection, pk=self.kwargs['pk'])

        try:
            browser_c.delete()
        except Exception as e:
            logger.error(f"User: {request.user} - Browser Connection: {browser_c.name} - Delete Error: {e}")
            messages.error(request, 'An error occurred while deleting the Browser Connection.')
            return redirect('datasource_browsers:list')

        logger.info(f"User: {request.user} - Browser Connection: {browser_c.name} - Deleted.")
        messages.success(request, 'Browser Connection deleted successfully.')
        return redirect('datasource_browsers:list')


Contents of ../../apps/datasource_browsers/views/browser_log/download_html_content_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: download_html_content_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import HttpResponse
from django.shortcuts import get_object_or_404
from django.views import View

from apps.datasource_browsers.models import DataSourceBrowserBrowsingLog


logger = logging.getLogger(__name__)


class BrowserView_BrowserLogDownloadHTML(LoginRequiredMixin, View):
    def get(self, request, pk, *args, **kwargs):
        log = get_object_or_404(DataSourceBrowserBrowsingLog, pk=pk)
        response = HttpResponse(log.html_content, content_type='text/html')
        response[
            'Content-Disposition'] = f'attachment; filename="{log.connection.name}_html_content_{log.created_at.strftime("%Y%m%d%H%M%S")}.html"'
        logger.info(f"User: {request.user} - Browser Log HTML Content: {log.connection.name} - Downloaded.")
        return response


Contents of ../../apps/datasource_browsers/views/browser_log/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_browsing_logs_views import *
from .download_html_content_views import *
from .download_context_data_views import *


Contents of ../../apps/datasource_browsers/views/browser_log/download_context_data_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: download_context_data_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import json
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import HttpResponse
from django.shortcuts import get_object_or_404
from django.views import View

from apps.datasource_browsers.models import DataSourceBrowserBrowsingLog

logger = logging.getLogger(__name__)


class BrowserView_BrowserLogDownload(LoginRequiredMixin, View):
    def get(self, request, pk, *args, **kwargs):
        log = get_object_or_404(DataSourceBrowserBrowsingLog, pk=pk)
        context_data = json.dumps(log.context_content, indent=4)
        response = HttpResponse(context_data, content_type='application/json')
        response[
            'Content-Disposition'] = f'attachment; filename="{log.connection.name}_context_data_{log.created_at.strftime("%Y%m%d%H%M%S")}.json"'
        logger.info(f"User: {request.user} - Browser Log Context Data: {log.connection.name} - Downloaded.")
        return response


Contents of ../../apps/datasource_browsers/views/browser_log/list_browsing_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_browsing_logs_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class BrowserView_BrowserLogList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_WEB_BROWSERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_WEB_BROWSERS):
            messages.error(self.request, "You do not have permission to list web browsers.")
            return context
        ##############################

        c_id = kwargs.get('pk')
        browser_c = get_object_or_404(DataSourceBrowserConnection, pk=c_id)
        try:
            context['browser_connection'] = browser_c
            logs = browser_c.logs.all()
            search_query = self.request.GET.get('search', '')
            if search_query:
                logs = logs.filter(action__icontains=search_query) | logs.filter(
                    html_content__icontains=search_query) | logs.filter(
                    context_content__icontains=search_query) | logs.filter(log_content__icontains=search_query)

            paginator = Paginator(logs, 10)
            page_number = self.request.GET.get('page')
            page_obj = paginator.get_page(page_number)
            context['page_obj'] = page_obj
            context['search_query'] = search_query
        except Exception as e:
            logger.error(
                f"User: {self.request.user} - Browser Connection: {browser_c.name} - Browsing Logs List Error: {e}")
            messages.error(self.request, 'An error occurred while listing Browsing Logs.')
            return context

        logger.info(f"User: {self.request.user} - Browser Connection: {browser_c.name} - Browsing Logs Listed.")
        return context


Contents of ../../apps/datasource_media_storages/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .media_file import *
from .media_storage import *
from .generated import *


Contents of ../../apps/datasource_media_storages/views/generated/generated_media_items_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: generated_media_items_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging
import os

import boto3
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_media_storages.models import DataSourceMediaStorageItem
from apps.multimodal_chat.models import MultimodalChat
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import GeneratedVideo
from config.settings import MEDIA_URL
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_Generated(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to see media files.")
            return context
        ##############################

        try:
            orgs = Organization.objects.filter(users__in=[self.request.user])
            data = []
            for org in orgs:
                agents = Assistant.objects.filter(organization=org)
                agent_data_list = []
                for agent in agents:
                    chats_of_agents = MultimodalChat.objects.filter(assistant=agent)
                    msgs_with_imgs = []
                    msgs_with_fs = []
                    for chat in chats_of_agents:
                        f_or_img_msgs = chat.chat_messages.filter(Q(message_image_contents__isnull=False) |
                                                                  Q(message_file_contents__isnull=False))
                        for m in f_or_img_msgs:
                            if m.message_image_contents:
                                for img in m.message_image_contents:
                                    message_data = {'message': m, 'image': img}
                                    msgs_with_imgs.append(message_data)
                            if m.message_file_contents:
                                for file in m.message_file_contents:
                                    message_data = {'message': m, 'file': file}
                                    msgs_with_fs.append(message_data)

                    pg_imgs = Paginator(msgs_with_imgs, 5)  # 5 items per page
                    pg_no_imgs = self.request.GET.get('page_images')
                    pg_obj_imgs = pg_imgs.get_page(pg_no_imgs)
                    pg_fs = Paginator(msgs_with_fs, 5)
                    pg_no_fs = self.request.GET.get('page_files')
                    pg_obj_fs = pg_fs.get_page(pg_no_fs)
                    gen_videos = GeneratedVideo.objects.filter(assistant=agent)
                    pg_videos = Paginator(gen_videos, 5)
                    pg_no_videos = self.request.GET.get('page_videos')
                    pg_obj_videos = pg_videos.get_page(pg_no_videos)

                    agent_data = {
                        'assistant': agent, 'messages_with_images': pg_obj_imgs, 'messages_with_files': pg_obj_fs,
                        'generated_videos': pg_obj_videos,
                    }
                    agent_data_list.append(agent_data)
                data.append({'organization': org, 'assistants': agent_data_list, })
        except Exception as e:
            logger.error(f"User: {self.request.user} - Generated Media - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing generated media files.')
            return context

        context['data'] = data
        context['base_url'] = MEDIA_URL
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to delete media files.")
            return redirect('datasource_media_storages:list_items')
        ##############################

        if 'selected_items' in request.POST:
            item_ids = request.POST.getlist('selected_items')
            items_to_be_deleted = DataSourceMediaStorageItem.objects.filter(id__in=item_ids)
            for item in items_to_be_deleted:
                if item.full_file_path is not None:
                    try:
                        s3c = boto3.client('s3')
                        bucket = os.getenv('AWS_STORAGE_BUCKET_NAME')
                        s3c.delete_object(Bucket=bucket, Key=item.full_file_path.split(MEDIA_URL)[1])
                    except Exception as e:
                        pass
            logger.info(f"[views.generated_media_items] Deleting selected generated media files.")
            DataSourceMediaStorageItem.objects.filter(id__in=item_ids).delete()

        messages.success(request, 'Selected generated media files deleted successfully.')
        return redirect('datasource_media_storages:list_items')


Contents of ../../apps/datasource_media_storages/views/generated/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .generated_media_items_views import *


Contents of ../../apps/datasource_media_storages/views/media_file/delete_all_media_items_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_media_items_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging
import os

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_media_storages.models import DataSourceMediaStorageItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ItemDeleteAll(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.post(request, *args, **kwargs)
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to delete media files.")
            return redirect('datasource_media_storages:list_items')
        ##############################

        mm_id = kwargs.get('id')
        complete_items_set = DataSourceMediaStorageItem.objects.filter(storage_base_id=mm_id)
        for item in complete_items_set:
            if item.full_file_path is not None:
                try:
                    os.system(f"rm -rf {item.full_file_path}")
                except Exception as e:
                    logger.error(f"Error while deleting media file: {e}")
                    pass

        try:
            DataSourceMediaStorageItem.objects.filter(storage_base_id=mm_id).delete()
        except Exception as e:
            logger.error(f"User: {request.user} - Media Item - Delete All Error: {e}")
            messages.error(request, 'An error occurred while deleting all media files.')
            return redirect('datasource_media_storages:list_items')

        logger.info(f"[views.delete_all_media_items] All media files deleted successfully.")
        messages.success(request, 'All media files deleted successfully.')
        return redirect('datasource_media_storages:list_items')


Contents of ../../apps/datasource_media_storages/views/media_file/create_media_item_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_media_item_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection, DataSourceMediaStorageItem
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ItemCreate(LoginRequiredMixin, TemplateView):
    def get(self, request, *args, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        try:
            user_agents = Assistant.objects.filter(organization__users__in=[request.user])
            media_managers = DataSourceMediaStorageConnection.objects.filter(assistant__in=user_agents)
            orgs = Organization.objects.filter(users__in=[request.user])
            context['organizations'] = list(orgs.values('id', 'name'))
            context['assistants'] = list(user_agents.values('id', 'name', 'organization_id'))
            context['media_storages'] = list(media_managers.values('id', 'name', 'assistant_id'))
        except Exception as e:
            logger.error(f"User: {request.user} - Media Item - Create Error: {e}")
            messages.error(request, 'An error occurred while creating media item.')
            return self.render_to_response(context)

        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to add media files")
            return redirect('datasource_media_storages:list_items')
        ##############################

        mm_id = request.POST.get('media_storage') or None
        if not mm_id:
            messages.error(request, 'Please select a media storage.')
            return redirect('datasource_media_storages:create_item')
        media_manager = DataSourceMediaStorageConnection.objects.get(pk=mm_id)
        fs = request.FILES.getlist('media_files')
        descriptions = request.POST.getlist('file_descriptions[]')
        if mm_id and fs:
            for file, desc in zip(fs, descriptions):
                try:
                    f_data_bytes = file.read()
                except Exception as e:
                    messages.error(request, f'Error reading file: {e}')
                    continue
                media_item = DataSourceMediaStorageItem.objects.create(
                    storage_base=media_manager, media_file_name=file.name.split('.')[0],
                    media_file_size=file.size, media_file_type=file.name.split('.')[-1],
                    file_bytes=f_data_bytes, description=desc
                )
                media_item.save()
            logger.info(f"[views.create_media_item] Files uploaded successfully.")
            messages.success(request, 'Files uploaded successfully.')
            return redirect('datasource_media_storages:list_items')
        else:
            logger.error('Please select a media storage and upload files.')
            messages.error(request, 'Please select a media storage and upload files.')

        return redirect('datasource_media_storages:create_item')


Contents of ../../apps/datasource_media_storages/views/media_file/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .fetch_media_file_from_url_views import *
from .list_media_items_views import *
from .create_media_item_views import *
from .delete_all_media_items_views import *
from .detail_update_media_item_views import *
from .generate_description_media_item_views import *


Contents of ../../apps/datasource_media_storages/views/media_file/fetch_media_file_from_url_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: fetch_media_file_from_url_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_media_storages.tasks import download_file_from_url
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ItemHTTPRetrieval(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to add media files.")
            return redirect('datasource_media_storages:list_items')
        ##############################

        mm_id = request.POST.get('storage_id') or None
        if not mm_id:
            logger.error('Invalid media storage ID.')
            messages.error(request, 'Invalid media storage ID.')
            return redirect('datasource_media_storages:create_item')
        retrieval_uri = request.POST.get('download_url') or None
        if not retrieval_uri:
            logger.error('Invalid download URL.')
            messages.error(request, 'Invalid download URL.')
            return redirect('datasource_media_storages:create_item')

        try:
            mm_id_int = int(mm_id)
            download_file_from_url.delay(storage_id=mm_id_int, url=retrieval_uri)
            logger.info('File download from URL initiated.')
        except Exception as e:
            logger.error(f'Error while initiating file download from URL: {e}')
            messages.error(request, 'Error while initiating file download from URL.')
            return redirect('datasource_media_storages:create_item')

        messages.success(request, 'File download from URL initiated.')
        return redirect('datasource_media_storages:list_items')


Contents of ../../apps/datasource_media_storages/views/media_file/list_media_items_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_media_items_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection, DataSourceMediaStorageItem
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ItemList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to see media files.")
            return context
        ##############################

        try:
            orgs = Organization.objects.filter(users__in=[self.request.user])
            data = []
            for org in orgs:
                agents = Assistant.objects.filter(organization=org)
                agent_data_list = []
                for agent in agents:
                    media_managers = DataSourceMediaStorageConnection.objects.filter(assistant=agent)
                    manager_data_list = []
                    for media_manager in media_managers:
                        items = DataSourceMediaStorageItem.objects.filter(
                            storage_base=media_manager).order_by('-created_at')
                        paginator = Paginator(items, 5)
                        page_no = self.request.GET.get('page')
                        page_obj = paginator.get_page(page_no)
                        item_data_list = []
                        for item in page_obj:
                            item_data_list.append({'item': item, })
                        manager_data_list.append(
                            {'storage': media_manager, 'items': page_obj, 'item_data': item_data_list, }
                        )
                    agent_data_list.append({'assistant': agent, 'media_storages': manager_data_list, })
                data.append({'organization': org, 'assistants': agent_data_list, })
        except Exception as e:
            logger.error(f"User: {self.request.user} - Media Item - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing media items.')
            return context

        context['data'] = data
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to delete media files.")
            return redirect('datasource_media_storages:list_items')
        ##############################

        item_ids = request.POST.getlist('selected_items')
        try:
            if 'selected_items' in request.POST:
                items_to_be_deleted = DataSourceMediaStorageItem.objects.filter(id__in=item_ids)
                for item in items_to_be_deleted:
                    if item.full_file_path is not None:
                        try:
                            pass
                        except Exception as e:
                            pass
                DataSourceMediaStorageItem.objects.filter(id__in=item_ids).delete()
        except Exception as e:
            logger.error(f"User: {request.user} - Media Item - Delete Error: {e}")
            messages.error(request, 'An error occurred while deleting media files.')
            return redirect('datasource_media_storages:list_items')

        logger.info(f"Selected media files deleted: {item_ids}")
        messages.success(request, 'Selected media files deleted successfully.')
        return redirect('datasource_media_storages:list_items')


Contents of ../../apps/datasource_media_storages/views/media_file/detail_update_media_item_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_update_media_item_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging
import os

import boto3
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_media_storages.models import DataSourceMediaStorageItem
from apps.datasource_media_storages.utils import decode_stream__docx, decode_stream__pptx, decode_stream__xlsx, \
    FILE_TYPE_HIGHLIGHTING_DECODER, MediaManagerItemFormatTypesNames
from apps.user_permissions.utils import PermissionNames
from config.settings import MEDIA_URL
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ItemUpdate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to see media files.")
            return context
        ##############################

        media_item = DataSourceMediaStorageItem.objects.get(id=kwargs['pk'])
        context['media_item'] = media_item
        f_data_bytes = None
        if media_item.full_file_path is not None:
            try:
                s3c = boto3.client('s3')
                bucket = os.getenv('AWS_STORAGE_BUCKET_NAME')
                f_data_bytes = s3c.get_object(Bucket=bucket, Key=media_item.full_file_path.split(MEDIA_URL)[1])
                f_data_bytes = f_data_bytes['Body'].read()
            except Exception as e:
                pass

        item_contents = "File contents could not be decoded."
        try:
            if media_item.media_file_type == MediaManagerItemFormatTypesNames.Data.TXT:
                item_contents = f_data_bytes.decode('utf-8')
            elif media_item.media_file_type == MediaManagerItemFormatTypesNames.Data.DOCX:
                item_contents = decode_stream__docx(f_data_bytes)
            elif media_item.media_file_type == MediaManagerItemFormatTypesNames.Data.PPTX:
                item_contents = decode_stream__pptx(f_data_bytes)
            elif media_item.media_file_type == MediaManagerItemFormatTypesNames.Data.XLSX:
                item_contents = decode_stream__xlsx(f_data_bytes)
            else:
                item_contents = f_data_bytes.decode('utf-8', errors='ignore')
        except Exception as e:
            pass
        context['media_item_contents'] = item_contents
        context['file_type_highlighting'] = FILE_TYPE_HIGHLIGHTING_DECODER.get(media_item.media_file_type, 'plaintext')
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to update media files.")
            return redirect('datasource_media_storages:list_items')
        ##############################

        try:
            media_item = DataSourceMediaStorageItem.objects.get(id=kwargs['pk'])
            description = request.POST.get('description')
            media_item.description = description
            media_item.save()
        except Exception as e:
            logger.error(f"User: {request.user} - Media Item - Update Error: {e}")
            messages.error(request, 'An error occurred while updating the media item.')
            return redirect('datasource_media_storages:list_items')

        logger.info(f"[views.update_media_item] Media item updated successfully.")
        messages.success(request, 'Media item updated successfully.')
        return redirect('datasource_media_storages:list_items')


Contents of ../../apps/datasource_media_storages/views/media_file/generate_description_media_item_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: generate_description_media_item_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging
import re

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.generative_ai.auxiliary_methods.tool_helpers.tool_helper_instructions import \
    FILE_GENERATION_INSTRUCTION_QUERY
from apps.core.tool_calls.core_services.core_service_query_media_manager import run_query_media_manager
from apps.core.tool_calls.utils import AnalysisToolCallExecutionTypesNames
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_media_storages.models import DataSourceMediaStorageItem
from apps.datasource_media_storages.utils import MediaManagerItemFormatTypesNamesLists, \
    AI_GENERATED_DESCRIPTION_SPECIFIER
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ItemAIDescription(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        if AI_GENERATED_DESCRIPTION_SPECIFIER in kwargs:
            context['generated_description'] = kwargs['generated_description']
        return context

    @staticmethod
    def decode_media_item_type(media_item_type):
        class MediaFileTypesNamesLists:
            IMAGE = MediaManagerItemFormatTypesNamesLists.IMAGE
            AUDIO = MediaManagerItemFormatTypesNamesLists.AUDIO
            VIDEO = MediaManagerItemFormatTypesNamesLists.VIDEO
            COMPRESSED = MediaManagerItemFormatTypesNamesLists.COMPRESSED
            CODE = MediaManagerItemFormatTypesNamesLists.CODE
            DATA = MediaManagerItemFormatTypesNamesLists.DATA

        if media_item_type in MediaFileTypesNamesLists.IMAGE:
            logger.info(f"Media Item Type: {media_item_type}")
            return AnalysisToolCallExecutionTypesNames.IMAGE_INTERPRETATION
        elif media_item_type in (
            MediaFileTypesNamesLists.COMPRESSED or
            media_item_type in MediaFileTypesNamesLists.DATA or
            media_item_type in MediaFileTypesNamesLists.CODE):
            logger.info(f"Media Item Type: {media_item_type}")
            return AnalysisToolCallExecutionTypesNames.FILE_INTERPRETATION
        else:
            logger.info(f"Media Item Type: {media_item_type}")
            return AnalysisToolCallExecutionTypesNames.FILE_INTERPRETATION

    @staticmethod
    def normalize_whitespace(text):
        text = text.strip()
        text = text.replace('\n', ' ')
        text = text.replace('\r', ' ')
        text = text.replace('\t', ' ')
        text = text.replace('\v', ' ')
        text = text.replace('\f', ' ')
        text = text.replace('\0', ' ')
        text = text.strip()
        text = re.sub(r'\s+', ' ', text, flags=re.UNICODE)
        return text

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to update media files.")
            return redirect('datasource_media_storages:list_items')
        ##############################

        try:
            item_id = kwargs.get('pk')
            media_item = DataSourceMediaStorageItem.objects.get(id=item_id)
            xc_type = self.decode_media_item_type(media_item.media_file_type)
            txts, _, _ = run_query_media_manager(chat_id=None, c_id=media_item.storage_base.id,
                                                 manager_file_type=xc_type, f_uris=[media_item.full_file_path],
                                                 manager_query=(FILE_GENERATION_INSTRUCTION_QUERY + f"""
                                                        File Format Information:
                                                        - Extension/Type: {media_item.media_file_type}
                                                   """),
                                                 no_chat=True)
        except Exception as e:
            logger.error(f"User: {request.user} - Media Item - Update Error: {e}")
            messages.error(request, 'An error occurred while updating the media item.')
            return redirect('datasource_media_storages:list_items')

        kwargs['pk'] = item_id
        if xc_type == AnalysisToolCallExecutionTypesNames.IMAGE_INTERPRETATION:
            gen_desc = txts
            media_item.description = gen_desc
            media_item.save()
        elif xc_type == AnalysisToolCallExecutionTypesNames.FILE_INTERPRETATION:
            try:
                output = txts["response"]
                gen_desc = ""
                if output:
                    gen_desc = output[0]
                gen_desc = self.normalize_whitespace(gen_desc)
                media_item.description = gen_desc
                media_item.save()
                logger.info(f"[views.update_media_item] Media item updated successfully.")
            except Exception as e:
                logger.error(f"Error while updating media item description: {e}")
                pass
        return redirect('datasource_media_storages:item_detail', **kwargs)


Contents of ../../apps/datasource_media_storages/views/media_storage/create_media_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_media_storage_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection
from apps.datasource_media_storages.utils import MEDIA_MANAGER_ITEM_TYPES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ManagerCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            user_orgs = Organization.objects.filter(users__in=[context_user])
            context['assistants'] = Assistant.objects.filter(organization__in=user_orgs)
            context['media_categories'] = MEDIA_MANAGER_ITEM_TYPES
            context['user'] = context_user
        except Exception as e:
            logger.error(f"User: {context_user} - Media Storage - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating media storage.')
            return context

        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_MEDIA_STORAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_MEDIA_STORAGES):
            messages.error(self.request, "You do not have permission to create media storages.")
            return redirect('datasource_media_storages:list')
        ##############################

        name = request.POST.get('name')
        desc = request.POST.get('description')
        item_category = request.POST.get('media_category')
        agent_id = request.POST.get('assistant')
        try:
            agent = Assistant.objects.get(id=agent_id)
            media_manager = DataSourceMediaStorageConnection.objects.create(
                name=name, description=desc, media_category=item_category, assistant=agent
            )
            media_manager.save()
            logger.info('Data Source Media Storage created successfully.')
            messages.success(request, 'Data Source Media Storage created successfully.')
            return redirect('datasource_media_storages:list')
        except Assistant.DoesNotExist:
            logger.error('Invalid assistant selected.')
            messages.error(request, 'Invalid assistant selected.')
            return redirect('datasource_media_storages:create')
        except Exception as e:
            logger.error(f'Error creating Data Source Media Storage: {e}')
            messages.error(request, f'Error creating Data Source Media Storage: {e}')
            return redirect('datasource_media_storages:create')


Contents of ../../apps/datasource_media_storages/views/media_storage/delete_media_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_media_storage_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ManagerDelete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            media_manager = get_object_or_404(DataSourceMediaStorageConnection, pk=kwargs['pk'])
            context['user'] = context_user
            context['media_storage'] = media_manager
        except Exception as e:
            logger.error(f"User: {context_user} - Media Storage - Delete Error: {e}")
            messages.error(self.request, 'An error occurred while deleting media storage.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_MEDIA_STORAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_MEDIA_STORAGES):
            messages.error(self.request, "You do not have permission to delete media storages.")
            return redirect('datasource_media_storages:list')
        ##############################

        media_manager = get_object_or_404(DataSourceMediaStorageConnection, pk=kwargs['pk'])

        try:
            media_manager.delete()
        except Exception as e:
            logger.error(f"Error while deleting media storage: {e}")
            messages.error(request, 'An error occurred while deleting media storage.')
            return redirect('datasource_media_storages:list')

        logger.info(f"Media Storage Connection deleted: {media_manager}")
        messages.success(request, 'Media Storage Connection deleted successfully.')
        return redirect('datasource_media_storages:list')


Contents of ../../apps/datasource_media_storages/views/media_storage/update_media_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_media_storage_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection
from apps.datasource_media_storages.utils import MEDIA_MANAGER_ITEM_TYPES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ManagerUpdate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            media_manager = get_object_or_404(DataSourceMediaStorageConnection, pk=kwargs['pk'])
            user_orgs = Organization.objects.filter(users__in=[context_user])
            context['assistants'] = Assistant.objects.filter(organization__in=user_orgs)
            context['media_categories'] = MEDIA_MANAGER_ITEM_TYPES
            context['user'] = context_user
            context['connection'] = media_manager
        except Exception as e:
            logger.error(f"User: {context_user} - Media Storage - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating media storage.')

        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_MEDIA_STORAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_MEDIA_STORAGES):
            messages.error(self.request, "You do not have permission to update media storages.")
            return redirect('datasource_media_storages:list')
        ##############################

        media_manager = get_object_or_404(DataSourceMediaStorageConnection, pk=kwargs['pk'])
        name = request.POST.get('name')
        desc = request.POST.get('description')
        manager_category = request.POST.get('media_category')
        agent_id = request.POST.get('assistant')

        try:
            agent = Assistant.objects.get(id=agent_id)
            media_manager.name = name
            media_manager.description = desc
            media_manager.media_category = manager_category
            media_manager.assistant = agent
            media_manager.save()
            logger.info('Data Source Media Storage updated successfully.')
            messages.success(request, 'Data Source Media Storage updated successfully.')
            return redirect('datasource_media_storages:list')
        except Assistant.DoesNotExist:
            logger.error('Invalid assistant selected.')
            messages.error(request, 'Invalid assistant selected.')
            return redirect('datasource_media_storages:update', pk=media_manager.pk)
        except Exception as e:
            logger.error(f'Error updating Data Source Media Storage: {e}')
            messages.error(request, f'Error updating Data Source Media Storage: {e}')
            return redirect('datasource_media_storages:update', pk=media_manager.pk)


Contents of ../../apps/datasource_media_storages/views/media_storage/__init__.py:

#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_media_storages_views import *
from .create_media_storage_views import *
from .delete_media_storage_views import *
from .update_media_storage_views import *


Contents of ../../apps/datasource_media_storages/views/media_storage/list_media_storages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_media_storages_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MediaView_ManagerList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_MEDIA_STORAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_MEDIA_STORAGES):
            messages.error(self.request, "You do not have permission to list media storages.")
            return context
        ##############################

        try:
            orgs = Organization.objects.filter(users__in=[self.request.user])
            data = []
            for org in orgs:
                agents = Assistant.objects.filter(organization=org)
                agent_data_list = []
                for agent in agents:
                    media_managers = DataSourceMediaStorageConnection.objects.filter(assistant=agent)
                    manager_data_list = []
                    for media_manager in media_managers:
                        manager_data_list.append({'storage': media_manager})
                    agent_data_list.append({'assistant': agent, 'media_storages': manager_data_list})
                data.append({'organization': org, 'assistants': agent_data_list})
        except Exception as e:
            logger.error(f"User: {self.request.user} - Media Storage - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing media storages.')
            return context

        context['data'] = data
        logger.info(f"Media Storages were listed.")
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_MEDIA_STORAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_MEDIA_STORAGES):
            messages.error(self.request, "You do not have permission to delete media storages.")
            return redirect('datasource_media_storages:list')
        ##############################

        mm_ids = request.POST.getlist('selected_storages')

        try:
            if mm_ids:
                DataSourceMediaStorageConnection.objects.filter(id__in=mm_ids).delete()
                logger.info(f"Media Storages were deleted.")
        except Exception as e:
            logger.error(f"Error while deleting media storages: {e}")
            messages.error(request, 'An error occurred while deleting media storages.')
            return redirect('datasource_media_storages:list')

        messages.success(request, 'Selected storage connections deleted successfully.')
        return redirect('datasource_media_storages:list')


Contents of ../../apps/mm_triggered_jobs/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .log import *
from .triggered_job import *
from .webhook import *


Contents of ../../apps/mm_triggered_jobs/views/webhook/orchestration_triggered_job_webhook_listener_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: orchestration_triggered_job_webhook_listener_views.py
#  Last Modified: 2024-11-14 07:22:02
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 07:22:03
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import json
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.generative_ai.utils import GPT_DEFAULT_ENCODING_ENGINE, ChatRoles
from apps.core.internal_cost_manager.costs_map import InternalServiceCosts
from apps.core.orchestration.orchestration_executor import OrchestrationExecutor
from apps.llm_transaction.models import LLMTransaction
from apps.llm_transaction.utils import LLMTransactionSourcesTypesNames
from apps.mm_triggered_jobs.models import OrchestrationTriggeredJob, OrchestrationTriggeredJobInstance
from apps.mm_triggered_jobs.utils import TriggeredJobInstanceStatusesNames
from apps.orchestrations.models import Maestro, OrchestrationQuery, OrchestrationQueryLog
from apps.orchestrations.utils import OrchestrationQueryLogTypesNames

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class OrchestrationTriggeredJobWebhookListenerView(View):
    def get(self, request, assistant_id, triggered_job_id):
        _, _ = assistant_id, triggered_job_id
        logger.error('Method GET is not allowed')
        return JsonResponse({'status': 'error', 'message': 'Method GET is not allowed'}, status=405)

    def post(self, request, assistant_id, triggered_job_id):
        try:
            payload = json.loads(request.body)
            try:
                job = OrchestrationTriggeredJob.objects.get(id=triggered_job_id)
                maestro = job.trigger_maestro
                check_maestro = Maestro.objects.get(id=assistant_id)
                if maestro != check_maestro:
                    logger.error(f"Maestro verification failed for Triggered Job: {job.id}")
                    return JsonResponse({'status': 'error', 'message': 'Maestro verification failed'}, status=400)
            except OrchestrationTriggeredJob.DoesNotExist:
                logger.error(f"Orchestration Triggered Job could not been found: {triggered_job_id}")
                return JsonResponse({'status': 'error', 'message': 'Orchestration Triggered Job could not been found'},
                                    status=404)
            except Maestro.DoesNotExist:
                logger.error(f"Maestro could not been found: {assistant_id}")
                return JsonResponse({'status': 'error', 'message': 'Maestro could not been found'}, status=404)

            if job.current_run_count > job.maximum_runs:
                job.delete()
                logger.info(f"Maximum runs reached for Orchestration Triggered Job: {job.id}")
                return JsonResponse(
                    {'status': 'error', 'message': 'Maximum runs reached for the orchestration triggered job'},
                    status=400)
            new_instance = OrchestrationTriggeredJobInstance.objects.create(
                triggered_job=job, status=TriggeredJobInstanceStatusesNames.PENDING, webhook_payload=payload)

            job.triggered_job_instances.add(new_instance)
            job.save()
            job.current_run_count += 1
            job.save()
            new_instance.execution_index = job.current_run_count
            new_instance.save()
            self.handle_orchestration_triggered_job(job=job, instance=new_instance)
            logger.info(f"Webhook payload received for Orchestration Triggered Job: {job.id}")
            return JsonResponse({
                'status': 'success', 'message': 'Orchestration Webhook payload received successfully',
                'data': {'assistant_id': assistant_id, 'triggered_job_id': triggered_job_id, 'payload': payload}
            }, status=200)
        except json.JSONDecodeError:
            logger.error('Invalid JSON object')
            return JsonResponse({'status': 'error', 'message': 'Invalid JSON object'}, status=400)

    @staticmethod
    def handle_orchestration_triggered_job(job, instance):
        try:
            job: OrchestrationTriggeredJob
            instruction_feed = f"""
                **WARNING: This is an AUTO-GENERATED user message.**
                - If you see this message, it means that this message is sent to you by the system, within the context
                of a webhook-triggered automatic job execution. Please do not expect an answer to this message and treat
                this as a STRICT ORDER given to you by the user, for you to perform. DO YOUR BEST to accomplish the
                described task based on your available tools and capabilities.

                ---

                **TASK INFORMATION:**
                [Triggered Job Name]: {job.name} (The user-defined name of the triggered job)
                [Triggered Job Description]: {job.task_description} (The user-defined instructions to explain TO YOU
                    what the job is about and what you need to accomplish within the context of the job. Make sure
                    you read and understand the descriptions here to help the user THE BEST you can.)
                [Triggered Job Step Guide]: (The user-defined step-by-step guide to help you understand the process of
                    the job and what you need to do to accomplish the job. Make sure you read and understand the step
                    guide to help the user THE BEST you can.)
                '''
                {job.step_guide}
                '''
                [When this task is triggered?]: {job.event_type}
                [Source of the Webhook Trigger]: {job.trigger_source}
                [Webhook Payload]:
                '''
                {json.dumps(instance.webhook_payload, indent=4)}
                '''

                [What is the life expectancy of this task?]:
                '''
                [Current Run Index]: {job.current_run_count}
                [Maximum Runs]: {job.maximum_runs}
                '''
                - If the current run index exceeds the maximum runs, the triggered job will be deleted automatically by
                the system. However, if you see this message, it means that the task still exists, and you must try to
                execute whatever ordered to you by the user within the context of this job.

                **IMPORTANT NOTES**
                - DO NOT ASK questions, since the user will not be able to answer you, as this is an automatic task.
                - If you are NOT 100% clear on what you need to accomplish, still try to do something if you think it
                wouldn't be a very harmful operation. However, if a potentially harmful operation (such as a database
                deletion operation) is ordered clearly by the user, DO NOT ASK FOR CONFIRMATION and perform the task.
                - IN FACT, NEVER ASK FOR CONFIRMATION, nor any other details since there is no way for the user to answer
                you since this message is completely automated and triggered by a Webhook.

                ---

                NOW; PLEASE GO AHEAD and EXECUTE the task according to the instructions provided to you.

                ---
            """

            attached_images = []
            attached_files = []
            query = OrchestrationQuery.objects.create(
                maestro=job.trigger_maestro, query_text=instruction_feed,
                created_by_user=job.created_by_user,
                last_updated_by_user=job.created_by_user
            )
            query_text = query.query_text
            query_log = OrchestrationQueryLog.objects.create(
                orchestration_query=query, log_type=OrchestrationQueryLogTypesNames.USER,
                log_text_content=query_text + f"""
                    -----
                    **IMAGE URLS:**
                    '''
                    {attached_images}
                    '''
                    -----
                    **FILE URLS:**
                    '''
                    {attached_files}
                    '''
                    -----
            """, log_file_contents=attached_files, log_image_contents=attached_images)
            query.logs.add(query_log)
            query.save()
            xc = OrchestrationExecutor(maestro=job.trigger_maestro, query_chat=query)
            output = xc.execute_for_query()
            logger.info("Orchestration Triggered Job Output: \n" + output)
            logger.info(f"Orchestration Triggered Job: {job.id} was executed successfully.")

            transaction = LLMTransaction(
                organization=job.trigger_maestro.organization, model=job.trigger_maestro.llm_model, responsible_user=None,
                responsible_assistant=None, encoding_engine=GPT_DEFAULT_ENCODING_ENGINE,
                llm_cost=InternalServiceCosts.TriggeredJobExecutor.COST, transaction_type=ChatRoles.SYSTEM,
                transaction_source=LLMTransactionSourcesTypesNames.TRIGGER_JOB_EXECUTION, is_tool_cost=True
            )
            transaction.save()

            logger.info(f"Triggered Job completed successfully: {job.id}")
        except Exception as e:
            instance.status = TriggeredJobInstanceStatusesNames.FAILED
            instance.save()
            logger.error(f"Triggered Job failed: {job.id} - {str(e)}")


Contents of ../../apps/mm_triggered_jobs/views/webhook/triggered_job_webhook_listener_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: triggered_job_webhook_listener_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import json
import logging

from django.http import JsonResponse
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.internal_cost_manager.costs_map import InternalServiceCosts
from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
from apps.assistants.models import Assistant
from apps.llm_transaction.models import LLMTransaction
from apps.llm_transaction.utils import LLMTransactionSourcesTypesNames
from apps.mm_triggered_jobs.models import TriggeredJob, TriggeredJobInstance
from apps.mm_triggered_jobs.utils import TriggeredJobInstanceStatusesNames, generate_triggered_job_chat_name
from apps.multimodal_chat.models import MultimodalChat, MultimodalChatMessage
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames


logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class TriggeredJobWebhookListenerView(View):
    def get(self, request, assistant_id, triggered_job_id):
        _, _ = assistant_id, triggered_job_id
        logger.error('Method GET is not allowed')
        return JsonResponse({'status': 'error', 'message': 'Method GET is not allowed'}, status=405)

    def post(self, request, assistant_id, triggered_job_id):
        try:
            payload = json.loads(request.body)
            try:
                job = TriggeredJob.objects.get(id=triggered_job_id)
                assistant = job.trigger_assistant
                check_assistant = Assistant.objects.get(id=assistant_id)
                if assistant != check_assistant:
                    logger.error(f"Assistant verification failed for Triggered Job: {job.id}")
                    return JsonResponse({'status': 'error', 'message': 'Assistant verification failed'}, status=400)
            except TriggeredJob.DoesNotExist:
                logger.error(f"Triggered Job could not been found: {triggered_job_id}")
                return JsonResponse({'status': 'error', 'message': 'Triggered Job could not been found'}, status=404)
            except Assistant.DoesNotExist:
                logger.error(f"Assistant could not been found: {assistant_id}")
                return JsonResponse({'status': 'error', 'message': 'Assistant could not been found'}, status=404)

            if job.current_run_count > job.maximum_runs:
                job.delete()
                logger.info(f"Maximum runs reached for Triggered Job: {job.id}")
                return JsonResponse({'status': 'error', 'message': 'Maximum runs reached for the triggered job'},
                                    status=400)
            new_instance = TriggeredJobInstance.objects.create(
                triggered_job=job, status=TriggeredJobInstanceStatusesNames.PENDING, webhook_payload=payload)

            job.triggered_job_instances.add(new_instance)
            job.save()
            job.current_run_count += 1
            job.save()
            new_instance.execution_index = job.current_run_count
            new_instance.save()
            self.handle_triggered_job(job=job, instance=new_instance)
            logger.info(f"Webhook payload received for Triggered Job: {job.id}")
            return JsonResponse({
                'status': 'success', 'message': 'Webhook payload received successfully',
                'data': {'assistant_id': assistant_id, 'triggered_job_id': triggered_job_id, 'payload': payload}
            }, status=200)
        except json.JSONDecodeError:
            logger.error('Invalid JSON object')
            return JsonResponse({'status': 'error', 'message': 'Invalid JSON object'}, status=400)

    @staticmethod
    def handle_triggered_job(job, instance):
        from apps.core.generative_ai.utils import GPT_DEFAULT_ENCODING_ENGINE
        from apps.core.generative_ai.utils import ChatRoles
        try:
            chat = MultimodalChat.objects.create(
                user=job.created_by_user, organization=job.trigger_assistant.organization,
                assistant=job.trigger_assistant, chat_name=generate_triggered_job_chat_name(job.name),
                created_by_user=job.created_by_user, chat_source=SourcesForMultimodalChatsNames.TRIGGERED)

            instance.status = TriggeredJobInstanceStatusesNames.BUILDING
            instance.save()
            logger.info(f"Chat created for Triggered Job: {job.id}")
            instruction_feed = f"""
                **WARNING: This is an AUTO-GENERATED user message.**
                - If you see this message, it means that this message is sent to you by the system, within the context
                of a webhook-triggered automatic job execution. Please do not expect an answer to this message and treat
                this as a STRICT ORDER given to you by the user, for you to perform. DO YOUR BEST to accomplish the
                described task based on your available tools and capabilities.

                ---

                **TASK INFORMATION:**
                [Triggered Job Name]: {job.name} (The user-defined name of the triggered job)
                [Triggered Job Description]: {job.task_description} (The user-defined instructions to explain TO YOU
                    what the job is about and what you need to accomplish within the context of the job. Make sure
                    you read and understand the descriptions here to help the user THE BEST you can.)
                [Triggered Job Step Guide]: (The user-defined step-by-step guide to help you understand the process of
                    the job and what you need to do to accomplish the job. Make sure you read and understand the step
                    guide to help the user THE BEST you can.)
                '''
                {job.step_guide}
                '''
                [When this task is triggered?]: {job.event_type}
                [Source of the Webhook Trigger]: {job.trigger_source}
                [Webhook Payload]:
                '''
                {json.dumps(instance.webhook_payload, indent=4)}
                '''

                [What is the life expectancy of this task?]:
                '''
                [Current Run Index]: {job.current_run_count}
                [Maximum Runs]: {job.maximum_runs}
                '''
                - If the current run index exceeds the maximum runs, the triggered job will be deleted automatically by
                the system. However, if you see this message, it means that the task still exists, and you must try to
                execute whatever ordered to you by the user within the context of this job.

                **IMPORTANT NOTES**
                - DO NOT ASK questions, since the user will not be able to answer you, as this is an automatic task.
                - If you are NOT 100% clear on what you need to accomplish, still try to do something if you think it
                wouldn't be a very harmful operation. However, if a potentially harmful operation (such as a database
                deletion operation) is ordered clearly by the user, DO NOT ASK FOR CONFIRMATION and perform the task.
                - IN FACT, NEVER ASK FOR CONFIRMATION, nor any other details since there is no way for the user to answer
                you since this message is completely automated and triggered by a Webhook.

                ---

                NOW; PLEASE GO AHEAD and EXECUTE the task according to the instructions provided to you.

                ---
                """
            instruction_feed_message = MultimodalChatMessage.objects.create(
                multimodal_chat=chat, sender_type='USER', message_text_content=instruction_feed)

            instance.status = TriggeredJobInstanceStatusesNames.INITIALIZING_ASSISTANT
            instance.save()
            llm_client = GenerativeAIDecodeController.get(assistant=chat.assistant, multimodal_chat=chat)
            instance.status = TriggeredJobInstanceStatusesNames.GENERATING
            instance.save()
            response_text = llm_client.respond(latest_message=instruction_feed_message)
            instance.status = TriggeredJobInstanceStatusesNames.SAVING_LOGS
            instance.save()
            instance.logs = response_text
            instance.save()
            instance.status = TriggeredJobInstanceStatusesNames.CLEANING_UP
            instance.save()
            chat.delete()
            instance.status = TriggeredJobInstanceStatusesNames.COMPLETED
            instance.ended_at = timezone.now()
            instance.save()
            transaction = LLMTransaction(
                organization=job.assistant.organization, model=job.assistant.llm_model, responsible_user=None,
                responsible_assistant=job.assistant, encoding_engine=GPT_DEFAULT_ENCODING_ENGINE,
                llm_cost=InternalServiceCosts.TriggeredJobExecutor.COST, transaction_type=ChatRoles.SYSTEM,
                transaction_source=LLMTransactionSourcesTypesNames.TRIGGER_JOB_EXECUTION, is_tool_cost=True
            )
            transaction.save()
            logger.info(f"Triggered Job completed successfully: {job.id}")
        except Exception as e:
            instance.status = TriggeredJobInstanceStatusesNames.FAILED
            instance.save()
            logger.error(f"Triggered Job failed: {job.id} - {str(e)}")


Contents of ../../apps/mm_triggered_jobs/views/webhook/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .triggered_job_webhook_listener_views import *
from .orchestration_triggered_job_webhook_listener_views import *


Contents of ../../apps/mm_triggered_jobs/views/triggered_job/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .list_triggered_jobs_views import *
from .create_triggered_job_views import *
from .delete_triggered_job_views import *
from .orchestration_create_triggered_job_views import *
from .orchestration_delete_triggered_job_views import *
from .orchestration_list_triggered_jobs_views import *


Contents of ../../apps/mm_triggered_jobs/views/triggered_job/delete_triggered_job_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_triggered_job_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.models import TriggeredJob
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class TriggeredJobView_Delete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        triggered_job_id = self.kwargs.get('pk')
        triggered_job = get_object_or_404(TriggeredJob, id=triggered_job_id)
        context['triggered_job'] = triggered_job
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_TRIGGERS):
            messages.error(self.request, "You do not have permission to delete triggered jobs.")
            return redirect('mm_triggered_jobs:list')
        ##############################

        triggered_job_id = self.kwargs.get('pk')
        triggered_job = get_object_or_404(TriggeredJob, id=triggered_job_id)

        try:
            triggered_job.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the Triggered Job: " + str(e))
            return redirect("mm_triggered_jobs:list")

        logger.info(f"Triggered Job was deleted by User: {self.request.user.id}.")
        messages.success(request, "Triggered Job deleted successfully.")
        return redirect('mm_triggered_jobs:list')


Contents of ../../apps/mm_triggered_jobs/views/triggered_job/orchestration_delete_triggered_job_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: orchestration_delete_triggered_job_views.py
#  Last Modified: 2024-11-14 07:21:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 07:21:19
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.models import OrchestrationTriggeredJob
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class TriggeredJobView_OrchestrationDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        triggered_job_id = self.kwargs.get('pk')
        triggered_job = get_object_or_404(OrchestrationTriggeredJob, id=triggered_job_id)
        context['triggered_job'] = triggered_job
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_ORCHESTRATION_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ORCHESTRATION_TRIGGERS):
            messages.error(self.request, "You do not have permission to delete orchestration triggered jobs.")
            return redirect('mm_triggered_jobs:orchestration_list')
        ##############################

        triggered_job_id = self.kwargs.get('pk')
        triggered_job = get_object_or_404(OrchestrationTriggeredJob, id=triggered_job_id)

        try:
            triggered_job.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the Orchestration Triggered Job: " + str(e))
            return redirect("mm_triggered_jobs:orchestration_list")

        logger.info(f"Orchestration Triggered Job was deleted by User: {self.request.user.id}.")
        messages.success(request, "Orchestration Triggered Job deleted successfully.")
        return redirect('mm_triggered_jobs:orchestration_list')


Contents of ../../apps/mm_triggered_jobs/views/triggered_job/orchestration_create_triggered_job_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: orchestration_create_triggered_job_views.py
#  Last Modified: 2024-11-14 07:21:09
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 07:21:10
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.forms import OrchestrationTriggeredJobForm
from apps.mm_triggered_jobs.models import OrchestrationTriggeredJob
from apps.orchestrations.models import Maestro
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class TriggeredJobView_OrchestrationCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = OrchestrationTriggeredJobForm()
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        trigger_maestros = Maestro.objects.filter(organization__in=user_orgs)
        context['trigger_maestros'] = trigger_maestros
        return context

    def post(self, request, *args, **kwargs):
        form = OrchestrationTriggeredJobForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_ORCHESTRATION_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_ORCHESTRATION_TRIGGERS):
            messages.error(self.request, "You do not have permission to add orchestration triggered jobs.")
            return redirect('mm_triggered_jobs:orchestration_list')
        ##############################

        if form.is_valid():
            triggered_job: OrchestrationTriggeredJob = form.save(commit=False)
            maestro_id = request.POST.get('trigger_maestro')
            trigger_maestro = Maestro.objects.get(id=maestro_id)
            triggered_job.created_by_user = request.user
            step_guide = request.POST.getlist('step_guide[]')
            triggered_job.step_guide = step_guide
            triggered_job.trigger_maestro = trigger_maestro
            triggered_job.save()
            logger.info(f"Triggered Job was created by User: {self.request.user.id}.")
            messages.success(request, "Orchestration Triggered Job created successfully!")
            return redirect('mm_triggered_jobs:orchestration_list')
        else:
            logger.error(f"Error creating orchestration triggered job: {form.errors}")
            messages.error(request, "There was an error creating the orchestration triggered job.")
            return self.render_to_response({'form': form})


Contents of ../../apps/mm_triggered_jobs/views/triggered_job/list_triggered_jobs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_triggered_jobs_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.models import TriggeredJob
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class TriggeredJobView_List(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_TRIGGERS):
            messages.error(self.request, "You do not have permission to list triggered jobs.")
            return context
        ##############################

        search_query = self.request.GET.get('search', '')
        user_orgs = self.request.user.organizations.all()
        org_agents = user_orgs.values_list('assistants', flat=True)
        triggered_jobs_list = TriggeredJob.objects.filter(trigger_assistant__in=org_agents)
        if search_query:
            triggered_jobs_list = triggered_jobs_list.filter(
                Q(name__icontains=search_query) | Q(task_description__icontains=search_query))
        paginator = Paginator(triggered_jobs_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['triggered_jobs'] = page_obj.object_list
        context['total_triggered_jobs'] = TriggeredJob.objects.count()
        context['search_query'] = search_query
        logger.info(f"Triggered Jobs were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/mm_triggered_jobs/views/triggered_job/orchestration_list_triggered_jobs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: orchestration_list_triggered_jobs_views.py
#  Last Modified: 2024-11-14 07:21:30
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 07:21:31
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.models import OrchestrationTriggeredJob
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class TriggeredJobView_OrchestrationList(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ORCHESTRATION_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ORCHESTRATION_TRIGGERS):
            messages.error(self.request, "You do not have permission to list orchestration triggered jobs.")
            return context
        ##############################

        search_query = self.request.GET.get('search', '')
        user_orgs = self.request.user.organizations.all()
        org_maestros = user_orgs.values_list('maestros', flat=True)
        triggered_jobs_list = OrchestrationTriggeredJob.objects.filter(trigger_maestro__in=org_maestros)
        if search_query:
            triggered_jobs_list = triggered_jobs_list.filter(
                Q(name__icontains=search_query) | Q(task_description__icontains=search_query))
        paginator = Paginator(triggered_jobs_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['triggered_jobs'] = page_obj.object_list
        context['total_triggered_jobs'] = OrchestrationTriggeredJob.objects.count()
        context['search_query'] = search_query
        logger.info(f"Orchestration Triggered Jobs were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/mm_triggered_jobs/views/triggered_job/create_triggered_job_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_triggered_job_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.forms import TriggeredJobForm
from apps.mm_triggered_jobs.models import TriggeredJob
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class TriggeredJobView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = TriggeredJobForm()
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        trigger_assistants = Assistant.objects.filter(organization__in=user_orgs)
        context['trigger_assistants'] = trigger_assistants
        return context

    def post(self, request, *args, **kwargs):
        form = TriggeredJobForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_TRIGGERS):
            messages.error(self.request, "You do not have permission to add triggered jobs.")
            return redirect('mm_triggered_jobs:list')
        ##############################

        if form.is_valid():
            triggered_job:TriggeredJob = form.save(commit=False)
            assistant_id = request.POST.get('trigger_assistant')
            trigger_assistant = Assistant.objects.get(id=assistant_id)
            triggered_job.created_by_user = request.user
            step_guide = request.POST.getlist('step_guide[]')
            triggered_job.step_guide = step_guide
            triggered_job.trigger_assistant = trigger_assistant
            triggered_job.save()
            logger.info(f"Triggered Job was created by User: {self.request.user.id}.")
            messages.success(request, "Triggered Job created successfully!")
            return redirect('mm_triggered_jobs:list')
        else:
            logger.error(f"Error creating triggered job: {form.errors}")
            messages.error(request, "There was an error creating the triggered job.")
            return self.render_to_response({'form': form})


Contents of ../../apps/mm_triggered_jobs/views/log/orchestration_list_triggered_job_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: orchestration_list_triggered_job_logs_views.py
#  Last Modified: 2024-11-14 07:20:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 07:20:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.models import OrchestrationTriggeredJob, OrchestrationTriggeredJobInstance
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class TriggeredJobView_OrchestrationLogList(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ORCHESTRATION_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ORCHESTRATION_TRIGGERS):
            messages.error(self.request, "You do not have permission to list orchestration triggered jobs.")
            return context
        ##############################

        triggered_job_id = self.kwargs.get('pk')
        triggered_job = get_object_or_404(OrchestrationTriggeredJob, id=triggered_job_id)
        context['triggered_job'] = triggered_job
        search_query = self.request.GET.get('search', '')
        job_instances_list = OrchestrationTriggeredJobInstance.objects.filter(triggered_job=triggered_job)
        if search_query:
            job_instances_list = job_instances_list.filter(
                Q(status__icontains=search_query) | Q(logs__icontains=search_query) | Q(
                    triggered_job__name__icontains=search_query))
        paginator = Paginator(job_instances_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['triggered_job_instances'] = page_obj.object_list
        context['total_triggered_job_instances'] = job_instances_list.count()
        context['search_query'] = search_query
        logger.info(f"Orchestration Triggered Job Log List View accessed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/mm_triggered_jobs/views/log/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .list_triggered_job_logs_views import *
from .orchestration_list_triggered_job_logs_views import *


Contents of ../../apps/mm_triggered_jobs/views/log/list_triggered_job_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_triggered_job_logs_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.models import TriggeredJob, TriggeredJobInstance
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class TriggeredJobView_LogList(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_TRIGGERS):
            messages.error(self.request, "You do not have permission to list triggered jobs.")
            return context
        ##############################

        triggered_job_id = self.kwargs.get('pk')
        triggered_job = get_object_or_404(TriggeredJob, id=triggered_job_id)
        context['triggered_job'] = triggered_job
        search_query = self.request.GET.get('search', '')
        job_instances_list = TriggeredJobInstance.objects.filter(triggered_job=triggered_job)
        if search_query:
            job_instances_list = job_instances_list.filter(
                Q(status__icontains=search_query) | Q(logs__icontains=search_query) | Q(
                    triggered_job__name__icontains=search_query))
        paginator = Paginator(job_instances_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['triggered_job_instances'] = page_obj.object_list
        context['total_triggered_job_instances'] = job_instances_list.count()
        context['search_query'] = search_query
        logger.info(f"Triggered Job Log List View accessed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/datasource_codebase/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .code_repository import *
from .code_base_storage import *


Contents of ../../apps/datasource_codebase/views/code_base_storage/create_code_base_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_code_base_storage_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_codebase.forms import CodeRepositoryStorageForm
from apps.datasource_codebase.utils import KNOWLEDGE_BASE_SYSTEMS, VECTORIZERS
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CodeBaseView_StorageCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user
        context['user'] = context_user

        try:
            context['knowledge_base_systems'] = KNOWLEDGE_BASE_SYSTEMS
            context['vectorizers'] = VECTORIZERS
            user_orgs = context_user.organizations.all()
            agents_of_orgs = Assistant.objects.filter(organization__in=user_orgs)
            context['assistants'] = agents_of_orgs
            context['form'] = CodeRepositoryStorageForm()
        except Exception as e:
            logger.error(f"User: {context_user} - Code Base Storage - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating Code Base Storage.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        form = CodeRepositoryStorageForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_CODE_BASE
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_CODE_BASE):
            messages.error(self.request, "You do not have permission to add code base storages.")
            return redirect('datasource_codebase:list')
        ##############################

        if form.is_valid():
            form.save()
            logger.info(f"Code Base Storage created successfully.")
            messages.success(request, "Code Base Storage created successfully.")
            return redirect('datasource_codebase:list')
        else:
            logger.error(f"Error creating Code Base Storage. Please check the form for errors.")
            messages.error(request, "Error creating Code Base Storage. Please check the form for errors.")
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_codebase/views/code_base_storage/delete_code_base_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_code_base_storage_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_codebase.models import CodeRepositoryStorageConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CodeBaseView_StorageDelete(LoginRequiredMixin, DeleteView):
    model = CodeRepositoryStorageConnection
    success_url = '/app/datasource_codebase/list/'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['knowledge_base'] = self.get_object()
        return context

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()

        ##############################
        # PERMISSION CHECK FOR - DELETE_CODE_BASE
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CODE_BASE):
            messages.error(self.request, "You do not have permission to update code base storages.")
            return redirect('datasource_codebase:list')
        ##############################

        logger.info(f"[CodeBaseView_StorageDelete] Deleting Code Repository Storage: {self.object}")
        return super().post(request, *args, **kwargs)

    def get_queryset(self):
        context_user = self.request.user
        return CodeRepositoryStorageConnection.objects.filter(assistant__organization__users__in=[context_user])


Contents of ../../apps/datasource_codebase/views/code_base_storage/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .update_code_base_storage_views import *
from .create_code_base_storage_views import *
from .delete_code_base_storage_views import *
from .list_code_base_storages_views import *


Contents of ../../apps/datasource_codebase/views/code_base_storage/list_code_base_storages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_code_base_storages_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_codebase.models import CodeRepositoryStorageConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CodeBaseView_StorageList(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_CODE_BASE
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_CODE_BASE):
            messages.error(self.request, "You do not have permission to list code base storages.")
            return context
        ##############################

        context_user = self.request.user
        try:
            user_orgs = Organization.objects.filter(users__in=[context_user])

            conns_by_orgs = {}
            for org in user_orgs:
                agents = org.assistants.all()
                agent_conns = {}
                for agent in agents:
                    conns = CodeRepositoryStorageConnection.objects.filter(assistant=agent)
                    if conns.exists():
                        agent_conns[agent] = conns
                if agent_conns:
                    conns_by_orgs[org] = agent_conns
        except Exception as e:
            logger.error(f"User: {context_user} - Code Base Storage - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing Code Base Storages.')
            return context

        context['connections_by_organization'] = conns_by_orgs
        context['user'] = context_user
        logger.info(f"[CodeBaseView_StorageList] User: {context_user} listed code base storages.")
        return context


Contents of ../../apps/datasource_codebase/views/code_base_storage/update_code_base_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_code_base_storage_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_codebase.forms import CodeRepositoryStorageForm
from apps.datasource_codebase.models import CodeRepositoryStorageConnection
from apps.datasource_codebase.utils import KNOWLEDGE_BASE_SYSTEMS, VECTORIZERS
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CodeBaseView_StorageUpdate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user
        vector_store = get_object_or_404(CodeRepositoryStorageConnection, pk=kwargs['pk'])

        try:
            context['user'] = context_user
            context['knowledge_base_systems'] = KNOWLEDGE_BASE_SYSTEMS
            context['vectorizers'] = VECTORIZERS
            user_orgs = context_user.organizations.all()
            agents_of_orgs = Assistant.objects.filter(organization__in=user_orgs)
            context['assistants'] = agents_of_orgs
            context['connection'] = vector_store
            context['form'] = CodeRepositoryStorageForm(instance=vector_store)
        except Exception as e:
            logger.error(f"User: {context_user} - Code Base Storage - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating Code Base Storage.')

        return context

    def post(self, request, *args, **kwargs):
        vector_store = get_object_or_404(CodeRepositoryStorageConnection, pk=kwargs['pk'])

        ##############################
        # PERMISSION CHECK FOR - UPDATE_CODE_BASE
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_CODE_BASE):
            messages.error(self.request, "You do not have permission to update code base storages.")
            return redirect('datasource_codebase:list')
        ##############################

        form = CodeRepositoryStorageForm(request.POST, instance=vector_store)
        if form.is_valid():
            form.save()
            logger.info(f"[CodeBaseView_StorageUpdate] Code Repository Storage updated: {vector_store}")
            messages.success(request, "Code Base Storage updated successfully.")
            return redirect('datasource_codebase:list')
        else:
            logger.error(
                f"[CodeBaseView_StorageUpdate] Error updating Code Base Storage. Please check the form for errors.")
            messages.error(request, "Error updating Code Base Storage. Please check the form for errors.")
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_codebase/views/code_repository/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_code_repositories_views import *
from .create_code_repository_views import *
from .delete_all_code_repositories_views import *


Contents of ../../apps/datasource_codebase/views/code_repository/create_code_repository_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_code_repository_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.codebase.codebase_decoder import CodeBaseDecoder
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_codebase.models import CodeRepositoryStorageConnection
from apps.datasource_codebase.tasks import add_repository_upload_log
from apps.datasource_codebase.utils import RepositoryUploadStatusNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CodeBaseView_RepositoryCreate(LoginRequiredMixin, TemplateView):
    def get(self, request, *args, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        try:
            user_agents = Assistant.objects.filter(organization__users__in=[request.user])
            vector_stores = CodeRepositoryStorageConnection.objects.filter(assistant__in=user_agents)
            orgs = Organization.objects.filter(users__in=[request.user])
            context['organizations'] = list(orgs.values('id', 'name'))
            context['assistants'] = list(user_agents.values('id', 'name', 'organization_id'))
            context['knowledge_bases'] = list(vector_stores.values('id', 'name', 'assistant_id'))
        except Exception as e:
            logger.error(f"User: {request.user} - Code Repository - Create Error: {e}")
            messages.error(request, 'An error occurred while creating Code Repository.')
            return self.render_to_response(context)

        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        vs_id = request.POST.get('knowledge_base') or None

        ##############################
        # PERMISSION CHECK FOR - ADD_CODE_REPOSITORY
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_CODE_REPOSITORY):
            messages.error(self.request, "You do not have permission to add code repositories.")
            return redirect('datasource_codebase:list_repositories')
        ##############################

        if not vs_id:
            logger.error(f"Please select a knowledge base.")
            messages.error(request, 'Please select a knowledge base.')
            return redirect('datasource_knowledge_base:create_documents')
        vector_store = CodeRepositoryStorageConnection.objects.get(pk=vs_id)
        repo_url = request.POST.get('repository_url')
        if vs_id and repo_url:
            add_repository_upload_log(document_full_uri=repo_url, log_name=RepositoryUploadStatusNames.STAGED)
            add_repository_upload_log(document_full_uri=repo_url, log_name=RepositoryUploadStatusNames.UPLOADED)
            CodeBaseDecoder.get(vector_store).index_repositories(document_paths=[repo_url])
            logger.info(f"Repositories uploaded successfully.")
            messages.success(request, 'Repositories uploaded successfully.')
            return redirect('datasource_codebase:list_repositories')
        else:
            logger.error(f"Please select a knowledge base and add repositories.")
            messages.error(request, 'Please select a knowledge base and add repositories.')
        return redirect('datasource_codebase:create_repositories')


Contents of ../../apps/datasource_codebase/views/code_repository/delete_all_code_repositories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_code_repositories_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_codebase.models import CodeBaseRepository
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CodeBaseView_RepositoryDeleteAll(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.post(request, *args, **kwargs)
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        vs_id = kwargs.get('kb_id')

        ##############################
        # PERMISSION CHECK FOR - DELETE_CODE_REPOSITORY
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CODE_REPOSITORY):
            messages.error(self.request, "You do not have permission to delete code repositories.")
            return redirect('datasource_codebase:list_repositories')
        ##############################

        try:
            CodeBaseRepository.objects.filter(knowledge_base_id=vs_id).delete()
        except Exception as e:
            logger.error(f"User: {request.user} - Code Repository - Delete All Error: {e}")
            messages.error(request, 'An error occurred while deleting all repositories.')
            return redirect('datasource_codebase:list_repositories')

        logger.info(
            f"[CodeBaseView_RepositoryDeleteAll] All repositories in the selected knowledge base have been deleted.")
        messages.success(request, 'All repositories in the selected knowledge base have been deleted successfully.')
        return redirect('datasource_codebase:list_repositories')


Contents of ../../apps/datasource_codebase/views/code_repository/list_code_repositories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_code_repositories_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_codebase.models import CodeRepositoryStorageConnection, CodeBaseRepository, \
    RepositoryProcessingLog
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CodeBaseView_RepositoryList(LoginRequiredMixin, TemplateView):
    def get(self, request, *args, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_CODE_REPOSITORY
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_CODE_REPOSITORY):
            messages.error(self.request, "You do not have permission to list code repositories.")
            return context
        ##############################

        try:
            orgs = Organization.objects.filter(users__in=[request.user])
            data = []
            for org in orgs:
                agents = Assistant.objects.filter(organization=org)
                agent_data_list = []
                for agent in agents:
                    vector_stores = CodeRepositoryStorageConnection.objects.filter(assistant=agent)
                    kb_data_list = []
                    for kb in vector_stores:
                        docs = CodeBaseRepository.objects.filter(knowledge_base=kb).order_by('-created_at')
                        paginator = Paginator(docs, 5)  # 5 repositories per page
                        page_number = request.GET.get('page')
                        page_obj = paginator.get_page(page_number)

                        doc_data_list = []
                        for doc in page_obj:
                            doc: CodeBaseRepository
                            logs = RepositoryProcessingLog.objects.filter(
                                repository_full_uri=doc.repository_uri)
                            cur_statuses = [log.log_message for log in logs]
                            doc_data_list.append({'document': doc, 'current_statuses': cur_statuses})
                        kb_data_list.append({
                            'knowledge_base': kb, 'documents': page_obj, 'document_data': doc_data_list,
                        })
                    agent_data_list.append({'assistant': agent, 'knowledge_bases': kb_data_list})
                data.append({'organization': org, 'assistants': agent_data_list})

            context['data'] = data
            context['document_statuses'] = [
                'staged', 'uploaded', 'loaded', 'chunked', 'embedded_document', 'saved_document', 'processed_document',
                'embedded_chunks', 'saved_chunks', 'processed_chunks', 'completed'
            ]
        except Exception as e:
            logger.error(f"User: {request.user} - Code Repository - List Error: {e}")
            messages.error(request, 'An error occurred while listing Code Repositories.')
            return self.render_to_response(context)

        context['failed_statuses'] = ['failed']
        context['partially_failed_statuses'] = ['partially_failed']
        logger.info(f"Code Repositories were listed.")
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_CODE_REPOSITORY
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CODE_REPOSITORY):
            messages.error(self.request, "You do not have permission to add code repositories.")
            return redirect('datasource_codebase:list_repositories')
        ##############################

        try:
            doc_ids = request.POST.getlist('selected_documents')
            if doc_ids:
                CodeBaseRepository.objects.filter(id__in=doc_ids).delete()
                logger.info(f"Code Repositories {doc_ids} were deleted.")
        except Exception as e:
            logger.error(f"User: {request.user} - Code Repository - Delete Error: {e}")
            messages.error(request, 'An error occurred while deleting selected repositories.')
            return redirect('datasource_codebase:list_repositories')

        messages.success(request, 'Selected repositories deleted successfully.')
        return redirect('datasource_codebase:list_repositories')


Contents of ../../apps/mm_functions/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .store import *
from .function import *


Contents of ../../apps/mm_functions/views/function/create_function_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_function_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.mm_functions.forms import CustomFunctionForm
from apps.mm_functions.utils import CUSTOM_FUNCTION_CATEGORIES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomFunctionView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = CustomFunctionForm()
        context['CUSTOM_FUNCTION_CATEGORIES'] = CUSTOM_FUNCTION_CATEGORIES
        return context

    def post(self, request, *args, **kwargs):
        form = CustomFunctionForm(request.POST, request.FILES)

        ##############################
        # PERMISSION CHECK FOR - ADD_FUNCTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_FUNCTIONS):
            messages.error(self.request, "You do not have permission to add custom functions.")
            return redirect('mm_functions:list')
        ##############################

        if form.is_valid():
            custom_function = form.save(commit=False)
            custom_function.created_by_user = request.user
            packages = []
            for name, version in zip(request.POST.getlist('packages[][name]'),
                                     request.POST.getlist('packages[][version]')):
                if name:
                    packages.append({'name': name, 'version': version})

            custom_function.packages = packages
            categories = request.POST.getlist('categories')
            input_field_names = request.POST.getlist('input_fields[][name]')
            input_field_descriptions = request.POST.getlist('input_fields[][description]')
            input_field_types = request.POST.getlist('input_fields[][type]')
            input_field_requireds = request.POST.getlist('input_fields[][required]')

            input_fields = []
            for i in range(len(input_field_names)):
                input_fields.append({
                    'name': input_field_names[i] if i < len(input_field_names) else '',
                    'description': input_field_descriptions[i] if i < len(input_field_descriptions) else '',
                    'type': input_field_types[i] if i < len(input_field_types) else '',
                    'required': bool(input_field_requireds[i]) if i < len(input_field_requireds) else False
                })

            custom_function.input_fields = input_fields
            output_field_names = request.POST.getlist('output_fields[][name]')
            output_field_descriptions = request.POST.getlist('output_fields[][description]')
            output_field_types = request.POST.getlist('output_fields[][type]')
            output_fields = []
            for i in range(len(output_field_names)):
                output_fields.append({
                    'name': output_field_names[i] if i < len(output_field_names) else '',
                    'description': output_field_descriptions[i] if i < len(output_field_descriptions) else '',
                    'type': output_field_types[i] if i < len(output_field_types) else ''
                })

            custom_function.output_fields = output_fields
            secret_field_names = request.POST.getlist('secrets[][name]')
            secret_field_keys = request.POST.getlist('secrets[][key]')
            secrets = []
            for i in range(len(secret_field_names)):
                secrets.append({
                    'name': secret_field_names[i] if i < len(secret_field_names) else '',
                    'key': secret_field_keys[i] if i < len(secret_field_keys) else ''
                })

            custom_function.secrets = secrets
            if request.FILES.get('function_picture'):
                custom_function.function_picture = request.FILES.get('function_picture')
            custom_function.categories = categories
            custom_function.save()
            logger.info(f"Function '{custom_function.name}' created.")
            return redirect('mm_functions:list')
        return render(request, self.template_name, {'form': form, 'assistants': Assistant.objects.filter(
            organization__users__in=[request.user])})


Contents of ../../apps/mm_functions/views/function/connections_functions_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: connections_functions_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.mm_functions.models import CustomFunction, CustomFunctionReference
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomFunctionView_Connections(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user
        conn_orgs = Organization.objects.filter(users__in=[user])
        users_of_conn_orgs = [user for org in conn_orgs for user in org.users.all()]
        functions = CustomFunction.objects.filter(created_by_user__in=users_of_conn_orgs)
        ext_function_refs = CustomFunctionReference.objects.filter(assistant__organization__in=conn_orgs).exclude(
            custom_function__created_by_user__in=users_of_conn_orgs)
        agents = Assistant.objects.filter(organization__in=conn_orgs).select_related('organization')
        agent_function_map = {
            assistant.id: CustomFunctionReference.objects.filter(
                assistant=assistant, custom_function__created_by_user__in=users_of_conn_orgs) for assistant in agents}

        ext_function_refs_map = {
            assistant.id: set(reference for reference in ext_function_refs if reference.assistant.id == assistant.id)
            for assistant in agents}

        context.update({
            'connected_organizations': conn_orgs, 'functions': functions, 'assistants': agents,
            'assistant_function_map': agent_function_map, 'external_function_references_map': ext_function_refs_map})
        logger.info(f"User: {self.request.user.id} is connecting functions.")
        return context

    def post(self, request, *args, **kwargs):
        agent_id = request.POST.get('assistant_id')
        function_id = request.POST.get('function_id')
        action = request.POST.get('action')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_FUNCTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_FUNCTIONS):
            messages.error(self.request, "You do not have permission to update custom functions.")
            return redirect('mm_functions:list')
        ##############################

        if not agent_id or not action:
            messages.error(request, "Invalid input. Please try again.")
            logger.error(f"Invalid input. Please try again.")
            return redirect('mm_functions:connect')

        try:
            agent = Assistant.objects.get(id=agent_id)
            if action == 'add' and function_id:
                custom_function = CustomFunction.objects.get(id=function_id)
                CustomFunctionReference.objects.create(
                    assistant=agent, custom_function=custom_function, created_by_user=request.user)
                logger.info(f"Function '{custom_function.name}' assigned to assistant '{agent.name}'.")
                messages.success(request,
                                 f"Function '{custom_function.name}' assigned to assistant '{agent.name}'.")
            elif action == 'remove':
                ref_id = request.POST.get('reference_id')
                if ref_id:
                    reff = CustomFunctionReference.objects.get(id=ref_id)
                    reff.delete()
                    logger.info(f"Function reference removed from assistant '{agent.name}'.")
                    messages.success(request, f"Function reference removed from assistant '{agent.name}'.")
        except Assistant.DoesNotExist:
            messages.error(request, "Assistant not found.")
            logger.error(f"Assistant not found.")
        except CustomFunction.DoesNotExist:
            messages.error(request, "Custom Function not found.")
            logger.error(f"Custom Function not found.")
        except CustomFunctionReference.DoesNotExist:
            messages.error(request, "Custom Function Reference not found.")
            logger.error(f"Custom Function Reference not found.")
        return redirect('mm_functions:connect')


Contents of ../../apps/mm_functions/views/function/delete_functions_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_functions_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_functions.models import CustomFunction
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CustomFunctionView_Delete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        custom_function_id = self.kwargs.get('pk')
        custom_function = CustomFunction.objects.get(id=custom_function_id)
        context['custom_function'] = custom_function
        return context

    def post(self, request, *args, **kwargs):
        custom_function_id = self.kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_FUNCTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_FUNCTIONS):
            messages.error(self.request, "You do not have permission to delete custom functions.")
            return redirect('mm_functions:list')
        ##############################

        custom_function = CustomFunction.objects.get(id=custom_function_id)

        try:
            custom_function.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the custom function: " + str(e))
            return redirect("mm_functions:list")

        logger.info(f"Custom Function was deleted by User: {self.request.user.id}.")
        messages.success(request, "Custom Function deleted successfully.")
        return redirect('mm_functions:list')


Contents of ../../apps/mm_functions/views/function/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_functions_views import *
from .create_function_views import *
from .delete_functions_views import *
from .connections_functions_views import *


Contents of ../../apps/mm_functions/views/function/list_functions_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_functions_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.core.paginator import Paginator
from django.db.models import Q
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_functions.models import CustomFunction
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomFunctionView_List(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_FUNCTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_FUNCTIONS):
            messages.error(self.request, "You do not have permission to list custom functions.")
            return context
        ##############################

        context_user = self.request.user
        conn_orgs = Organization.objects.filter(users__in=[context_user])
        users_of_conn_orgs = User.objects.filter(
            profile__user__in=[user for org in conn_orgs for user in org.users.all()])
        functions_list = CustomFunction.objects.filter(created_by_user__in=users_of_conn_orgs)
        search_query = self.request.GET.get('search', '')
        if search_query:
            functions_list = functions_list.filter(
                Q(name__icontains=search_query) | Q(description__icontains=search_query))

        paginator = Paginator(functions_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['functions'] = page_obj.object_list
        context['total_functions'] = CustomFunction.objects.count()
        context['public_functions'] = CustomFunction.objects.filter(is_public=True).count()
        context['private_functions'] = CustomFunction.objects.filter(is_public=False).count()
        context['search_query'] = search_query
        logger.info(f"User: {self.request.user.id} is listing custom functions.")
        return context


Contents of ../../apps/mm_functions/views/store/function_store_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: function_store_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.mm_functions.models import CustomFunction, CustomFunctionReference
from apps.mm_functions.utils import CUSTOM_FUNCTION_CATEGORIES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomFunctionView_Store(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        search_query = self.request.GET.get('search', '')
        selected_categories = self.request.GET.getlist('categories')
        functions_list = CustomFunction.objects.filter(is_public=True)
        if search_query:
            functions_list = functions_list.filter(
                Q(name__icontains=search_query) | Q(description__icontains=search_query))
        if selected_categories:
            functions_list = functions_list.filter(
                *[Q(categories__icontains=category) for category in selected_categories])

        function_agent_map = {
            function.id: Assistant.objects.exclude(customfunctionreference__custom_function=function)
            for function in functions_list
        }
        paginator = Paginator(functions_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['functions'] = page_obj.object_list
        context['total_functions'] = CustomFunction.objects.count()
        context['public_functions'] = CustomFunction.objects.filter(is_public=True).count()
        context['private_functions'] = CustomFunction.objects.filter(is_public=False).count()
        context['search_query'] = search_query
        context['selected_categories'] = selected_categories
        context['CUSTOM_FUNCTION_CATEGORIES'] = CUSTOM_FUNCTION_CATEGORIES
        context['function_assistant_map'] = function_agent_map
        logger.info(f"User: {self.request.user.id} is checking function store.")
        return context

    def post(self, request, *args, **kwargs):
        action = request.POST.get('action')
        agent_id = request.POST.get('assistant_id')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_FUNCTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_FUNCTIONS):
            logger.error(f"You do not have permission to update custom functions.")
            messages.error(self.request, "You do not have permission to update custom functions.")
            return redirect('mm_functions:list')
        ##############################

        if action and action == "add" and agent_id:
            function_id = request.POST.get('function_id')
            if function_id:
                custom_function = CustomFunction.objects.get(id=function_id)
                agent = Assistant.objects.get(id=agent_id)
                CustomFunctionReference.objects.create(assistant=agent, custom_function=custom_function,
                                                       created_by_user=request.user)
                logger.info(f"Function '{custom_function.name}' assigned to assistant '{agent.name}'.")
                messages.success(request,
                                 f"Function '{custom_function.name}' assigned to assistant '{agent.name}'.")
        else:
            logger.error(f"Invalid input. Please try again.")
            messages.error(request, "Invalid input. Please try again.")
        return redirect('mm_functions:store')


Contents of ../../apps/mm_functions/views/store/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .function_store_views import *


Contents of ../../apps/community_forum/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .like import *
from .post import *
from .thread import *
from .comment import *
from .category import *


Contents of ../../apps/community_forum/views/like/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .like_comment_views import *


Contents of ../../apps/community_forum/views/like/like_comment_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: like_comment_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404
from django.views import View

from apps.community_forum.models import ForumComment, ForumLike
from auth.utils import ForumRewardActionsNames

logger = logging.getLogger(__name__)


class ForumView_CommentLike(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        comment_id = self.kwargs.get("comment_id")
        comment = get_object_or_404(ForumComment, id=comment_id)

        try:
            like, created = ForumLike.objects.get_or_create(user=request.user, comment=comment)
            if not created:
                like.delete()
                comment.like_count -= 1
                comment.save()
                comment_owner = comment.created_by
                comment_owner.profile.remove_points(ForumRewardActionsNames.GET_LIKE)
            else:
                comment.like_count += 1
                comment.save()
                comment_owner = comment.created_by
                comment_owner.profile.add_points(ForumRewardActionsNames.GET_LIKE)
        except Exception as e:
            logger.error(f"[ForumView_CommentLike] Error liking the Comment: {e}")
            return HttpResponseRedirect(request.META.get('HTTP_REFERER', '/'))

        logger.info(f"Comment liked. Comment ID: {comment.id}")
        return HttpResponseRedirect(request.META.get('HTTP_REFERER', '/'))


Contents of ../../apps/community_forum/views/post/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .create_forum_post_views import *


Contents of ../../apps/community_forum/views/post/create_forum_post_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_forum_post_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.db.models import Prefetch
from django.shortcuts import get_object_or_404, redirect
from django.utils import timezone
from django.views.generic import TemplateView

from apps.community_forum.forms import ForumPostForm
from apps.community_forum.models import ForumThread, ForumCategory
from apps.community_forum.utils import CONST_HOURS
from auth.utils import ForumRewardActionsNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ForumView_PostCreate(LoginRequiredMixin, TemplateView):
    def post(self, request, *args, **kwargs):
        thread_id = self.kwargs.get("thread_id")
        thread = get_object_or_404(ForumThread, id=thread_id)

        try:
            if request.user.profile.user_last_forum_post_at:
                if (timezone.now() - request.user.profile.user_last_forum_post_at).seconds < (1 * CONST_HOURS):
                    messages.error(request, "You can only post once per hour.")
                    logger.error(f"User tried to post more than once per hour. User ID: {request.user.id}")
                    return redirect('community_forum:thread_detail', thread_id=thread.id)

            request.user.profile.user_last_forum_post_at = timezone.now()
            request.user.profile.save()
            form = ForumPostForm(request.POST)
            if form.is_valid():
                post = form.save(commit=False)
                post.thread = thread
                post.created_by = request.user
                post.save()
                request.user.profile.add_points(ForumRewardActionsNames.ASK_QUESTION)
                logger.info(f"Forum post created. Post ID: {post.id}")
                return redirect('community_forum:thread_detail', thread_id=thread.id)
        except Exception as e:
            logger.error(f"Error creating forum post: {e}")
            messages.error(request, "An error occurred while creating the post.")
            return redirect('community_forum:thread_detail', thread_id=thread.id)

        context = self.get_context_data(**kwargs)
        context['form'] = form
        logger.error(f"Error creating forum post: {form.errors}")
        return self.render_to_response(context)

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        thread_id = self.kwargs.get("thread_id")

        try:
            thread = get_object_or_404(ForumThread, id=thread_id)
            categories = ForumCategory.objects.prefetch_related(
                Prefetch('threads', queryset=ForumThread.objects.order_by('-created_at'))
            )
            context['categories'] = categories
            context['thread'] = thread
            context['form'] = ForumPostForm()
        except Exception as e:
            logger.error(f"Error getting context data for forum post creation: {e}")
            return context

        return context


Contents of ../../apps/community_forum/views/category/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_forum_categories_views import *


Contents of ../../apps/community_forum/views/category/list_forum_categories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_forum_categories_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.community_forum.models import ForumCategory
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ForumView_CategoryList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        try:
            search_query = self.request.GET.get('search', '')
            if search_query:
                categories = ForumCategory.objects.filter(threads__title__icontains=search_query).order_by(
                    "created_at")
            else:
                categories = ForumCategory.objects.all().order_by("created_at")

            paginator = Paginator(categories, 20)
            page_number = self.request.GET.get('page')
            page_obj = paginator.get_page(page_number)
            context['categories'] = page_obj
            context['page_obj'] = page_obj
            context['search_query'] = search_query
        except Exception as e:
            logger.error(f"[ForumView_CategoryList] Error listing the Forum Categories: {e}")
            return context

        logger.info(f"Forum Categories were listed.")
        return context


Contents of ../../apps/community_forum/views/comment/verify_forum_comment_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: verify_forum_comment_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.community_forum.models import ForumPost, ForumComment
from auth.utils import ForumRewardActionsNames

logger = logging.getLogger(__name__)


class ForumView_CommentVerify(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        post_id = self.kwargs.get("post_id")
        comment_id = self.kwargs.get("comment_id")
        post = get_object_or_404(ForumPost, id=post_id)

        try:
            comment = get_object_or_404(ForumComment, id=comment_id)
            if post.is_verified:
                comment_owner = post.verified_comment.created_by
                comment_owner.profile.remove_points(ForumRewardActionsNames.GET_MERIT)
            if post.created_by == request.user:
                post.verify_comment(comment)
            comment_owner = comment.created_by
            comment_owner.profile.add_points(ForumRewardActionsNames.GET_MERIT)
        except Exception as e:
            logger.error(f"[ForumView_CommentVerify] Error verifying the Comment: {e}")
            return redirect('community_forum:thread_detail', thread_id=post.thread.id)

        logger.info(f"Comment verified. Comment ID: {comment.id}")
        return redirect('community_forum:thread_detail', thread_id=post.thread.id)


Contents of ../../apps/community_forum/views/comment/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .verify_forum_comment_views import *


Contents of ../../apps/community_forum/views/thread/list_forum_threads_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_forum_threads_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Prefetch, Q
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.community_forum.models import ForumCategory, ForumThread
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ForumView_ThreadList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        category_slug = self.kwargs.get("slug")

        try:
            category = get_object_or_404(ForumCategory, slug=category_slug)
            context['category'] = category
            categories = ForumCategory.objects.prefetch_related(
                Prefetch('threads', queryset=ForumThread.objects.order_by('-created_at'))
            )
            context['categories'] = categories
            search_query = self.request.GET.get('search', '')
            if search_query:
                threads = category.threads.filter(
                    Q(title__icontains=search_query)
                ).order_by('-created_at')
            else:
                threads = category.threads.all().order_by('-created_at')
        except Exception as e:
            logger.error(f"[ForumView_ThreadList] Error listing the Forum Threads: {e}")
            return context

        try:
            paginator = Paginator(threads, 10)
            page_number = self.request.GET.get('page')
            page_obj = paginator.get_page(page_number)
            context['threads'] = page_obj
            context['page_obj'] = page_obj
            context['search_query'] = search_query
        except Exception as e:
            logger.error(f"[ForumView_ThreadList] Error listing the Forum Threads: {e}")
            return context

        return context


Contents of ../../apps/community_forum/views/thread/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_forum_threads_views import *
from .detail_forum_thread_views import *


Contents of ../../apps/community_forum/views/thread/detail_forum_thread_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_forum_thread_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Prefetch, Q
from django.shortcuts import get_object_or_404, redirect
from django.utils import timezone
from django.views.generic import TemplateView

from apps.community_forum.forms import ForumCommentForm
from apps.community_forum.models import ForumThread, ForumPost, ForumCategory, ForumComment, ForumLike
from apps.community_forum.utils import CONST_MINUTES
from auth.utils import ForumRewardActionsNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ForumView_ThreadDetail(LoginRequiredMixin, TemplateView):
    def post(self, request, *args, **kwargs):
        thread_id = self.kwargs.get("thread_id")
        thread = get_object_or_404(ForumThread, id=thread_id)

        try:
            post_id = request.POST.get("post_id")
            post = get_object_or_404(ForumPost, id=post_id)
            if request.user.profile.user_last_forum_comment_at:
                if (timezone.now() - request.user.profile.user_last_forum_comment_at).seconds < (5 * CONST_MINUTES):
                    messages.error(request, "You can only comment once every 5 minutes.")
                    logger.error(f"User tried to comment more than once per 5 minutes. User ID: {request.user.id}")
                    return redirect('community_forum:thread_detail', thread_id=thread.id)
            request.user.profile.user_last_forum_comment_at = timezone.now()
            request.user.profile.save()
        except Exception as e:
            logger.error(f"Error creating forum comment: {e}")
            messages.error(request, "An error occurred while creating the comment.")
            return redirect('community_forum:thread_detail', thread_id=thread.id)

        try:
            form = ForumCommentForm(request.POST)
            if form.is_valid():
                comment = form.save(commit=False)
                comment.post = post
                comment.created_by = request.user
                comment.save()
                request.user.profile.add_points(ForumRewardActionsNames.ADD_COMMENT)
                logger.info(f"Forum comment created. Comment ID: {comment.id}")
                return redirect('community_forum:thread_detail', thread_id=thread.id)
        except Exception as e:
            logger.error(f"Error creating forum comment: {e}")
            messages.error(request, "An error occurred while creating the comment.")
            return redirect('community_forum:thread_detail', thread_id=thread.id)

        context = self.get_context_data(**kwargs)
        context['form'] = form
        logger.error(f"Error creating forum comment: {form.errors}")
        return self.render_to_response(context)

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        thread_id = self.kwargs.get("thread_id")

        try:
            thread = get_object_or_404(ForumThread, id=thread_id)
            context['thread'] = thread
            categories = ForumCategory.objects.prefetch_related(
                Prefetch('threads', queryset=ForumThread.objects.order_by('-created_at'))
            )
            context['categories'] = categories
            search_query = self.request.GET.get('search', '')
            if search_query:
                posts = thread.posts.filter(
                    Q(content__icontains=search_query) | Q(comments__content__icontains=search_query)
                ).distinct().order_by('created_at')
            else:
                posts = thread.posts.all().order_by('created_at')
        except Exception as e:
            logger.error(f"Error getting context data for forum thread detail: {e}")
            return context

        try:
            post_paginator = Paginator(posts, 5)
            page_number = self.request.GET.get('page')
            page_obj = post_paginator.get_page(page_number)
            context['posts'] = page_obj
            context['post_page_obj'] = page_obj
            context['search_query'] = search_query
            for post in context['posts']:
                comments = ForumComment.objects.filter(post=post).order_by('created_at')
                comment_paginator = Paginator(comments, 5)
                comment_page_number = self.request.GET.get(f'comment_page_{post.id}')
                post.ordered_comments = comment_paginator.get_page(comment_page_number)
                post.comment_page_obj = post.ordered_comments
                for comment in post.ordered_comments:
                    comment.user_has_liked = ForumLike.objects.filter(comment=comment, user=self.request.user).exists()
        except Exception as e:
            logger.error(f"Error paginating posts and comments: {e}")
            return context

        context['form'] = ForumCommentForm()
        logger.info(f"Thread detail view accessed. Thread ID: {thread.id}")
        return context


Contents of ../../apps/assistants/views/create_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_assistant_views.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import AGENT_SPEECH_LANGUAGES, CONTEXT_MANAGEMENT_STRATEGY, EMBEDDING_MANAGERS, Assistant
from apps.assistants.utils import ContextManagementStrategyNames
from apps.data_security.models import NERIntegration
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from apps.assistants.utils import MULTI_STEP_REASONING_CAPABILITY_CHOICE
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class AssistantView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['llm_models'] = LLMCore.objects.filter(organization__in=context['organizations'])
        context['response_languages'] = AGENT_SPEECH_LANGUAGES
        context['context_overflow_strategies'] = CONTEXT_MANAGEMENT_STRATEGY
        context['reasoning_capability_choices'] = MULTI_STEP_REASONING_CAPABILITY_CHOICE
        context['vectorizers'] = EMBEDDING_MANAGERS
        context["ner_integrations"] = NERIntegration.objects.filter(organization__in=context['organizations'])
        context["projects"] = ProjectItem.objects.filter(organization__in=context['organizations'])
        return context

    def post(self, request, *args, **kwargs):
        context_user = request.user

        ##############################
        # PERMISSION CHECK FOR - ADD_ASSISTANTS
        if not UserPermissionManager.is_authorized(user=context_user, operation=PermissionNames.ADD_ASSISTANTS):
            messages.error(request, "You do not have permission to create agents.")
            return redirect('assistants:list')
        ##############################

        try:
            org_id = request.POST.get('organization')
            llm_id = request.POST.get('llm_model')
            ner_id = None
            if ("ner_integration" in request.POST and request.POST.get('ner_integration')
                and request.POST.get('ner_integration') != "None"
                and request.POST.get('ner_integration') != ""):
                ner_id = request.POST.get('ner_integration')
                logger.info(f"NER Integration is defined for this agent. NER ID: {ner_id}")
        except Exception as e:
            logger.error(f"Error while getting the organization and LLM model information: {e}")
            messages.error(request, "Organization and LLM model information is required.")
            return redirect('assistants:create')

        try:
            agent_name = request.POST.get('name')
            agent_description = request.POST.get('description')
            system_instructions = request.POST.get('instructions')
            templated_response = request.POST.get('response_template')
            target_audience = request.POST.get('audience')
            tool_call_max_step_back_retries = request.POST.get('max_retry_count')
            tool_call_chain_same_tool_max = request.POST.get('tool_max_attempts_per_instance')
            tool_call_chain_maximum_attempts = request.POST.get('tool_max_chains')
            terms = request.POST.getlist('terms[]')
            definitions = request.POST.getlist('definitions[]')
            technical_dict = {term: definition for term, definition in zip(terms, definitions)}
            intra_memory_strategy = request.POST.get('context_overflow_strategy')
            max_msgs_context = request.POST.get('max_context_messages')
            embedding_vectorizer_name = None
            embedding_vectorizer_api_key = None
            logger.info(f"Agent information is received.")
            if intra_memory_strategy == ContextManagementStrategyNames.FORGET:
                pass
            elif intra_memory_strategy == ContextManagementStrategyNames.STOP:
                pass
            # TODO: optimize the vectorization strategy, then will be uncommented
            """
            elif intra_memory_strategy == ContextManagementStrategyNames.VECTORIZE:
                embedding_vectorizer_name = request.POST.get('vectorizer_name')
                embedding_vectorizer_api_key = request.POST.get('vectorizer_api_key')
            """

            tone = request.POST.get('tone')
            communication_lang = request.POST.get('response_language')
            spatial_capab_time = request.POST.get('time_awareness') == 'on'
            spatial_capab_place = request.POST.get('place_awareness') == 'on'
            visualization_capab = request.POST.get('image_generation_capability') == 'on'
            reasoning_capab = request.POST.get('multi_step_reasoning_capability_choice')
            agent_img = request.FILES.get('assistant_image')
            if not (org_id and llm_id and agent_name and agent_description and system_instructions and target_audience and tone):
                messages.error(request, "All fields are required.")
                return redirect('assistants:create')
        except Exception as e:
            logger.error(f"Error while getting the agent information: {e}")
            messages.error(request, "Agent information is required.")
            return redirect('assistants:create')

        try:
            org = Organization.objects.get(id=org_id)
            llm_core = LLMCore.objects.get(id=llm_id)
            ner_integration = None
            if ner_id:
                ner_integration = NERIntegration.objects.get(id=ner_id)
            agent = Assistant.objects.create(
                organization=org, llm_model=llm_core, name=agent_name, description=agent_description,
                instructions=system_instructions, audience=target_audience,
                max_retry_count=tool_call_max_step_back_retries,
                tool_max_attempts_per_instance=tool_call_chain_same_tool_max,
                tool_max_chains=tool_call_chain_maximum_attempts, tone=tone, assistant_image=agent_img,
                context_overflow_strategy=intra_memory_strategy,max_context_messages=max_msgs_context,
                vectorizer_name=embedding_vectorizer_name, vectorizer_api_key=embedding_vectorizer_api_key,
                created_by_user=context_user, last_updated_by_user=context_user, response_template=templated_response,
                response_language=communication_lang, time_awareness=spatial_capab_time,
                place_awareness=spatial_capab_place, image_generation_capability=visualization_capab,
                multi_step_reasoning_capability_choice=reasoning_capab, glossary=technical_dict,
                ner_integration=ner_integration
            )
            org.assistants.add(agent)
            org.save()

            project_items = request.POST.getlist('project_items[]')
            agent.project_items.set(project_items)
            agent.save()
        except Exception as e:
            logger.error(f"Error while creating the agent: {e}")
            messages.error(request, "Error while creating the agent.")
            return redirect('assistant:create')

        messages.success(request, "Agent created successfully!")
        logger.info(f"Agent is created successfully. Agent ID: {agent.id}")
        return redirect('assistants:list')


Contents of ../../apps/assistants/views/delete_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_assistant_views.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class AssistantView_Delete(LoginRequiredMixin, DeleteView):
    model = Assistant

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        agent = self.get_object()
        context['assistant'] = agent
        return context

    def post(self, request, *args, **kwargs):
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - DELETE_ASSISTANTS
        if not UserPermissionManager.is_authorized(user=context_user, operation=PermissionNames.DELETE_ASSISTANTS):
            messages.error(self.request, "You do not have permission to delete agents.")
            return redirect('assistants:list')
        ##############################

        try:
            agent = self.get_object()
            agent.delete()
            logger.info(f"Assistant has been deleted. ")
            messages.success(self.request, "Assistant has been deleted.")
        except Exception as e:
            logger.error(f"[AssistantView_Delete] Error deleting the assistant: {e}")
            messages.error(self.request, "Error deleting the assistant.")

        return redirect('assistants:list')

    def get_queryset(self):
        context_user = self.request.user
        return Assistant.objects.filter(organization__users__in=[context_user])


Contents of ../../apps/assistants/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#

from .create_assistant_views import *
from .delete_assistant_views import *
from .update_assistant_views import *
from .list_assistants_views import *


Contents of ../../apps/assistants/views/update_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_assistant_views.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant, AGENT_SPEECH_LANGUAGES, CONTEXT_MANAGEMENT_STRATEGY, EMBEDDING_MANAGERS
from apps.assistants.utils import ContextManagementStrategyNames, MULTI_STEP_REASONING_CAPABILITY_CHOICE, \
    EmbeddingManagersNames
from apps.data_security.models import NERIntegration
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class AssistantView_Update(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        agent_id = self.kwargs.get('pk')
        agent = get_object_or_404(Assistant, id=agent_id)
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['llm_models'] = LLMCore.objects.filter(organization__in=context['organizations'])
        context['assistant'] = agent
        context['response_languages'] = AGENT_SPEECH_LANGUAGES
        context['context_overflow_strategies'] = CONTEXT_MANAGEMENT_STRATEGY
        context['reasoning_capability_choices'] = MULTI_STEP_REASONING_CAPABILITY_CHOICE
        context['vectorizers'] = EMBEDDING_MANAGERS
        context["assistant_current_strategy"] = ContextManagementStrategyNames.as_dict()[
            agent.context_overflow_strategy]
        context["assistant_current_vectorizer"] = EmbeddingManagersNames.as_dict()[
            agent.vectorizer_name] if agent.vectorizer_name else None
        context["ner_integrations"] = NERIntegration.objects.filter(organization__in=context['organizations'])
        context["projects"] = ProjectItem.objects.filter(organization__in=context['organizations'])
        return context

    def post(self, request, *args, **kwargs):
        context_user = request.user

        ##############################
        # PERMISSION CHECK FOR - UPDATE_ASSISTANTS
        if not UserPermissionManager.is_authorized(user=context_user, operation=PermissionNames.UPDATE_ASSISTANTS):
            messages.error(self.request, "You do not have permission to update assistants.")
            return redirect('assistants:list')
        ##############################

        agent_id = self.kwargs.get('pk')
        try:
            agent = get_object_or_404(Assistant, id=agent_id)
            agent.name = request.POST.get('name')
            agent.description = request.POST.get('description')
            agent.instructions = request.POST.get('instructions')
            agent.audience = request.POST.get('audience')
            agent.max_retry_count = request.POST.get('max_retry_count')
            agent.tool_max_attempts_per_instance = request.POST.get('tool_max_attempts_per_instance')
            agent.tool_max_chains = request.POST.get('tool_max_chains')

            ner_id = None
            if ("ner_integration" in request.POST and request.POST.get('ner_integration')
                and request.POST.get('ner_integration') != "None"
                and request.POST.get('ner_integration') != ""):
                ner_id = request.POST.get('ner_integration')
                logger.info(f"NER Integration is defined for this agent. NER ID: {ner_id}")

            if ner_id:
                agent.ner_integration = NERIntegration.objects.get(id=ner_id)
            else:
                agent.ner_integration = None

            terms = request.POST.getlist('terms[]')
            definitions = request.POST.getlist('definitions[]')
            updated_technical_dict = {}
            for term, definition in zip(terms, definitions):
                updated_technical_dict[term] = definition
            agent.glossary = updated_technical_dict
            agent.context_overflow_strategy = request.POST.get('context_overflow_strategy')
            agent.max_context_messages = request.POST.get('max_context_messages')
            vectorizer_name = None
            vectorizer_api_key = None
            if agent.context_overflow_strategy == ContextManagementStrategyNames.FORGET:
                pass
            elif agent.context_overflow_strategy == ContextManagementStrategyNames.STOP:
                pass
            # TODO: optimize the vectorization strategy, then will be uncommented
            """
            elif agent.context_overflow_strategy == ContextManagementStrategyNames.VECTORIZE:
                vectorizer_name = request.POST.get('vectorizer_name')
                vectorizer_api_key = request.POST.get('vectorizer_api_key')
            """

            agent.vectorizer_name = vectorizer_name
            agent.vectorizer_api_key = vectorizer_api_key
            agent.tone = request.POST.get('tone')
            agent.llm_model_id = request.POST.get('llm_model')
            agent.response_template = request.POST.get('response_template')
            agent.response_language = request.POST.get('response_language')
            agent.time_awareness = request.POST.get('time_awareness') == 'on'
            agent.place_awareness = request.POST.get('place_awareness') == 'on'
            agent.image_generation_capability = request.POST.get('image_generation_capability') == 'on'
            agent.multi_step_reasoning_capability_choice = request.POST.get('multi_step_reasoning_capability_choice')
            agent.last_updated_by_user = request.user
            if 'assistant_image' in request.FILES:
                agent.assistant_image = request.FILES['assistant_image']
            agent.save()

            project_items = request.POST.getlist('project_items[]')
            agent.project_items.set(project_items)
            agent.save()
        except Exception as e:
            logger.error(f"Error while updating the agent information: {e}")
            messages.error(request, "Agent information is required.")
            return redirect('assistants:update', pk=agent_id)

        logger.info(f"Assistant has been updated. ")
        return redirect('assistants:update', pk=agent_id)


Contents of ../../apps/assistants/views/list_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_assistants_views.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class AssistantView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - LIST_ASSISTANTS
        if not UserPermissionManager.is_authorized(user=user, operation=PermissionNames.LIST_ASSISTANTS):
            messages.error(self.request, "You do not have permission to list agents.")
            return context
        ##############################

        try:
            organizations = Organization.objects.filter(users__in=[user])
            org_assistants = {org: org.assistants.all() for org in organizations}
            context['org_assistants'] = org_assistants
        except Exception as e:
            logger.error(f"[AssistantView_List] Error listing the assistants: {e}")
            messages.error(self.request, "Error listing the agents.")

        return context


Contents of ../../apps/data_security/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_ner_integration_views import *
from .create_ner_integration_views import *
from .delete_ner_integration_views import *
from .update_ner_integration_views import *


Contents of ../../apps/data_security/views/delete_ner_integration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_ner_integration_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.data_security.models import NERIntegration
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NERView_IntegrationDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        ner_integration = get_object_or_404(NERIntegration, id=self.kwargs['pk'])
        context['ner_integration'] = ner_integration
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_DATA_SECURITY
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_DATA_SECURITY):
            messages.error(self.request, "You do not have permission to delete data security layers.")
            return redirect('data_security:list_ner_integrations')
        ##############################

        ner_integration = get_object_or_404(NERIntegration, id=self.kwargs['pk'])
        try:
            ner_integration.delete()
        except Exception as e:
            logger.error(f"User: {request.user} - NER Integration: {ner_integration.name} - Delete Error: {e}")
            messages.error(request, 'An error occurred while deleting the NER Policy.')
            return redirect('data_security:list_ner_integrations')

        logger.info(f"User: {request.user} - NER Integration: {ner_integration.name} - Deleted.")
        messages.success(request, 'NER Policy has been deleted successfully.')
        return redirect('data_security:list_ner_integrations')


Contents of ../../apps/data_security/views/update_ner_integration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_ner_integration_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.data_security.models import NERIntegration
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NERView_IntegrationUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        try:
            ner_integration = NERIntegration.objects.get(id=self.kwargs['pk'])
            context['ner_integration'] = ner_integration
            context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
            context['boolean_fields'] = [
                {'name': 'encrypt_persons', 'label': 'Encrypt Persons (PERSON)',
                 'value': ner_integration.encrypt_persons},
                {'name': 'encrypt_orgs', 'label': 'Encrypt Organizations (ORG)',
                 'value': ner_integration.encrypt_orgs},
                {'name': 'encrypt_nationality_religion_political', 'label': 'Encrypt NORP',
                 'value': ner_integration.encrypt_nationality_religion_political},
                {'name': 'encrypt_facilities', 'label': 'Encrypt Facilities (FAC)',
                 'value': ner_integration.encrypt_facilities},
                {'name': 'encrypt_countries_cities_states', 'label': 'Encrypt GPE',
                 'value': ner_integration.encrypt_countries_cities_states},
                {'name': 'encrypt_locations', 'label': 'Encrypt Locations (LOC)',
                 'value': ner_integration.encrypt_locations},
                {'name': 'encrypt_products', 'label': 'Encrypt Products (PRODUCT)',
                 'value': ner_integration.encrypt_products},
                {'name': 'encrypt_events', 'label': 'Encrypt Events (EVENT)', 'value': ner_integration.encrypt_events},
                {'name': 'encrypt_artworks', 'label': 'Encrypt Work of Art (WORK_OF_ART)',
                 'value': ner_integration.encrypt_artworks},
                {'name': 'encrypt_laws', 'label': 'Encrypt Laws (LAW)', 'value': ner_integration.encrypt_laws},
                {'name': 'encrypt_languages', 'label': 'Encrypt Languages (LANGUAGE)',
                 'value': ner_integration.encrypt_languages},
                {'name': 'encrypt_dates', 'label': 'Encrypt Dates (DATE)', 'value': ner_integration.encrypt_dates},
                {'name': 'encrypt_times', 'label': 'Encrypt Times (TIME)', 'value': ner_integration.encrypt_times},
                {'name': 'encrypt_percentages', 'label': 'Encrypt Percentages (PERCENT)',
                 'value': ner_integration.encrypt_percentages},
                {'name': 'encrypt_money', 'label': 'Encrypt Money (MONEY)', 'value': ner_integration.encrypt_money},
                {'name': 'encrypt_quantities', 'label': 'Encrypt Quantities (QUANTITY)',
                 'value': ner_integration.encrypt_quantities},
                {'name': 'encrypt_ordinal_numbers', 'label': 'Encrypt Ordinal Numbers (ORDINAL)',
                 'value': ner_integration.encrypt_ordinal_numbers},
                {'name': 'encrypt_cardinal_numbers', 'label': 'Encrypt Cardinal Numbers (CARDINAL)',
                 'value': ner_integration.encrypt_cardinal_numbers},
            ]
        except Exception as e:
            logger.error(f"User: {self.request.user} - NER Integration: {self.kwargs['pk']} - Update Error: {e}")
            messages.error(self.request, 'An error occurred while listing update page for NER Integration.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_DATA_SECURITY
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_DATA_SECURITY):
            messages.error(self.request, "You do not have permission to update data security layers.")
            return redirect('data_security:list_ner_integrations')
        ##############################

        try:
            ner_integration = NERIntegration.objects.get(id=self.kwargs['pk'])
            ner_integration.encrypt_persons = request.POST.get('encrypt_persons') == 'True'
            ner_integration.encrypt_orgs = request.POST.get('encrypt_orgs') == 'True'
            ner_integration.encrypt_nationality_religion_political = request.POST.get(
                'encrypt_nationality_religion_political') == 'True'
            ner_integration.encrypt_facilities = request.POST.get('encrypt_facilities') == 'True'
            ner_integration.encrypt_countries_cities_states = request.POST.get(
                'encrypt_countries_cities_states') == 'True'
            ner_integration.encrypt_locations = request.POST.get('encrypt_locations') == 'True'
            ner_integration.encrypt_products = request.POST.get('encrypt_products') == 'True'
            ner_integration.encrypt_events = request.POST.get('encrypt_events') == 'True'
            ner_integration.encrypt_artworks = request.POST.get('encrypt_artworks') == 'True'
            ner_integration.encrypt_laws = request.POST.get('encrypt_laws') == 'True'
            ner_integration.encrypt_languages = request.POST.get('encrypt_languages') == 'True'
            ner_integration.encrypt_dates = request.POST.get('encrypt_dates') == 'True'
            ner_integration.encrypt_times = request.POST.get('encrypt_times') == 'True'
            ner_integration.encrypt_percentages = request.POST.get('encrypt_percentages') == 'True'
            ner_integration.encrypt_money = request.POST.get('encrypt_money') == 'True'
            ner_integration.encrypt_quantities = request.POST.get('encrypt_quantities') == 'True'
            ner_integration.encrypt_ordinal_numbers = request.POST.get('encrypt_ordinal_numbers') == 'True'
            ner_integration.encrypt_cardinal_numbers = request.POST.get('encrypt_cardinal_numbers') == 'True'

            ner_integration.name = request.POST.get('name')
            ner_integration.description = request.POST.get('description')
            ner_integration.language = request.POST.get('language')
            organization_id = request.POST.get('organization')
            if organization_id:
                ner_integration.organization_id = organization_id  # Assign organization directly
            ner_integration.save()
        except Exception as e:
            logger.error(f"User: {request.user} - NER Integration: {self.kwargs['pk']} - Update Error: {e}")
            messages.error(request, 'An error occurred while updating NER Integration.')
            return redirect('data_security:list_ner_integrations')

        logger.info(f"User: {request.user} - NER Integration: {ner_integration.name} - Updated.")
        return redirect('data_security:update_ner_integration', pk=ner_integration.id)


Contents of ../../apps/data_security/views/create_ner_integration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_ner_integration_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.data_security.forms import NERIntegrationForm
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NERView_IntegrationCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = NERIntegrationForm()
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['boolean_fields'] = [
            {'name': 'encrypt_persons', 'label': 'Encrypt Persons (PERSON)'},
            {'name': 'encrypt_orgs', 'label': 'Encrypt Organizations (ORG)'},
            {'name': 'encrypt_nationality_religion_political', 'label': 'Encrypt NORP'},
            {'name': 'encrypt_facilities', 'label': 'Encrypt Facilities (FAC)'},
            {'name': 'encrypt_countries_cities_states', 'label': 'Encrypt GPE'},
            {'name': 'encrypt_locations', 'label': 'Encrypt Locations (LOC)'},
            {'name': 'encrypt_products', 'label': 'Encrypt Products (PRODUCT)'},
            {'name': 'encrypt_events', 'label': 'Encrypt Events (EVENT)'},
            {'name': 'encrypt_artworks', 'label': 'Encrypt Work of Art (WORK_OF_ART)'},
            {'name': 'encrypt_laws', 'label': 'Encrypt Laws (LAW)'},
            {'name': 'encrypt_languages', 'label': 'Encrypt Languages (LANGUAGE)'},
            {'name': 'encrypt_dates', 'label': 'Encrypt Dates (DATE)'},
            {'name': 'encrypt_times', 'label': 'Encrypt Times (TIME)'},
            {'name': 'encrypt_percentages', 'label': 'Encrypt Percentages (PERCENT)'},
            {'name': 'encrypt_money', 'label': 'Encrypt Money (MONEY)'},
            {'name': 'encrypt_quantities', 'label': 'Encrypt Quantities (QUANTITY)'},
            {'name': 'encrypt_ordinal_numbers', 'label': 'Encrypt Ordinal Numbers (ORDINAL)'},
            {'name': 'encrypt_cardinal_numbers', 'label': 'Encrypt Cardinal Numbers (CARDINAL)'},
        ]
        return context

    def post(self, request, *args, **kwargs):
        context_user = request.user

        ##############################
        # PERMISSION CHECK FOR - ADD_DATA_SECURITY
        if not UserPermissionManager.is_authorized(user=context_user, operation=PermissionNames.ADD_DATA_SECURITY):
            messages.error(request, "You do not have permission to add data security layers.")
            return redirect('data_security:list_ner_integrations')
        ##############################

        form = NERIntegrationForm(request.POST)
        if form.is_valid():
            form.save()
            logger.info(f"User: {context_user} - NER Integration: {form.cleaned_data['name']} - Created.")
            return redirect('data_security:list_ner_integrations')

        logger.error(f"User: {context_user} - Form: {form.errors}")
        return render(request, self.template_name, {'form': form})


Contents of ../../apps/data_security/views/list_ner_integration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_ner_integration_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.data_security.models import NERIntegration
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NERView_IntegrationList(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - ADD_DATA_SECURITY
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_DATA_SECURITY):
            messages.error(self.request, "You do not have permission to list data security layers.")
            return context
        ##############################

        try:
            context['ner_integrations'] = NERIntegration.objects.select_related('organization').filter(
                organization__users__in=[self.request.user]
            )
        except Exception as e:
            logger.error(f"User: {self.request.user} - NER Integrations - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing NER Integrations.')
            return context

        logger.info(f"NER Integrations were listed.")
        return context


Contents of ../../apps/brainstorms/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .idea import *
from .session import *
from .level_synthesis import *
from .complete_synthesis import *


Contents of ../../apps/brainstorms/views/complete_synthesis/perform_complete_synthesis_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: perform_complete_synthesis_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.brainstorms.brainstorms_executor import BrainstormsExecutor
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class BrainstormingView_PerformCompleteSynthesis(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        ss_id = self.kwargs.get('session_id')
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=request.user)

        ##############################
        # PERMISSION CHECK FOR - CREATE_BRAINSTORMING_SYNTHESES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_BRAINSTORMING_SYNTHESES):
            messages.error(self.request, "You do not have permission to create brainstorming syntheses.")
            return redirect('brainstorms:detail_session', session_id=session.id)
        ##############################

        xc = BrainstormsExecutor(session=session)
        xc.generate_complete_synthesis()
        messages.success(request, 'Complete synthesis for the entire session generated successfully.')
        logger.info(f'Complete synthesis for the entire session generated successfully. Session ID: {session.id}')
        return redirect('brainstorms:detail_session', session_id=session.id)


Contents of ../../apps/brainstorms/views/complete_synthesis/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .perform_complete_synthesis_views import *


Contents of ../../apps/brainstorms/views/level_synthesis/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .perform_level_synthesis_views import *


Contents of ../../apps/brainstorms/views/level_synthesis/perform_level_synthesis_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: perform_level_synthesis_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.brainstorms.brainstorms_executor import BrainstormsExecutor
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class BrainstormingView_LevelSynthesis(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        ss_id = self.kwargs.get('session_id')
        depth_level = request.POST.get('depth_level', 1)
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=request.user)

        ##############################
        # PERMISSION CHECK FOR - CREATE_BRAINSTORMING_SYNTHESES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_BRAINSTORMING_SYNTHESES):
            messages.error(self.request, "You do not have permission to create brainstorming syntheses.")
            return redirect('brainstorms:detail_session', session_id=session.id)
        ##############################

        xc = BrainstormsExecutor(session=session)
        xc.generate_level_synthesis(depth_level=int(depth_level))
        messages.success(request, f'Level synthesis for level {depth_level} generated successfully.')
        logger.info(f'Level synthesis for level {depth_level} generated successfully. Session ID: {session.id}')
        return redirect('brainstorms:detail_session', session_id=session.id)


Contents of ../../apps/brainstorms/views/idea/delete_idea_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_idea_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingIdea
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class BrainstormingView_IdeaDelete(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        idea_id = self.kwargs.get('idea_id')
        idea = get_object_or_404(BrainstormingIdea, id=idea_id, created_by_user=request.user)

        ##############################
        # PERMISSION CHECK FOR - DELETE_BRAINSTORMING_IDEAS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BRAINSTORMING_IDEAS):
            messages.error(self.request, "You do not have permission to delete ideas.")
            return redirect('brainstorms:detail_session', session_id=idea.brainstorming_session.id)
        ##############################

        ss_id = idea.brainstorming_session.id
        idea.delete()
        messages.success(request, f'Idea "{idea.idea_title}" has been deleted successfully.')
        logger.info(f'Idea "{idea.idea_title}" has been deleted successfully. Idea ID: {idea.id}')
        return redirect('brainstorms:detail_session', session_id=ss_id)


Contents of ../../apps/brainstorms/views/idea/bookmark_idea_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: bookmark_idea_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingIdea
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class BrainstormingView_IdeaBookmark(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        idea_id = self.kwargs.get('idea_id')
        idea = get_object_or_404(BrainstormingIdea, id=idea_id, created_by_user=request.user)

        ##############################
        # PERMISSION CHECK FOR - BOOKMARK_BRAINSTORMING_IDEAS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.BOOKMARK_BRAINSTORMING_IDEAS):
            messages.error(self.request, "You do not have permission to bookmark ideas.")
            return redirect('brainstorms:detail_session', session_id=idea.brainstorming_session.id)
        ##############################

        idea.is_bookmarked = not idea.is_bookmarked
        idea.save()
        status = "bookmarked" if idea.is_bookmarked else "unbookmarked"
        messages.success(request, f'Idea "{idea.idea_title}" has been {status}.')
        logger.info(f'Idea "{idea.idea_title}" has been {status}. Idea ID: {idea.id}')
        return redirect('brainstorms:detail_session', session_id=idea.brainstorming_session.id)


Contents of ../../apps/brainstorms/views/idea/produce_ideas_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: produce_ideas_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.brainstorms.brainstorms_executor import BrainstormsExecutor
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class BrainstormingView_IdeasGenerate(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        ss_id = self.kwargs.get('session_id')

        ##############################
        # PERMISSION CHECK FOR - CREATE_BRAINSTORMING_IDEAS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_BRAINSTORMING_IDEAS):
            messages.error(self.request, "You do not have permission to create brainstorming ideas.")
            return redirect('brainstorms:detail_session', session_id=ss_id)
        ##############################

        depth_level = request.POST.get('depth_level', 1)
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=request.user)
        xc = BrainstormsExecutor(session=session)
        xc.produce_ideas(depth_level=int(depth_level))
        messages.success(request, f'Ideas for level {depth_level} generated successfully.')
        logger.info(f'Ideas for level {depth_level} generated successfully. Session ID: {session.id}')
        return redirect('brainstorms:detail_session', session_id=session.id)


Contents of ../../apps/brainstorms/views/idea/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .delete_idea_views import *
from .bookmark_idea_views import *
from .produce_ideas_views import *
from .deepen_idea_views import *


Contents of ../../apps/brainstorms/views/idea/deepen_idea_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: deepen_idea_views.py
#  Last Modified: 2024-10-08 18:46:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-08 18:46:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.core.brainstorms.brainstorms_executor import BrainstormsExecutor
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession, BrainstormingIdea
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)

class BrainstormingView_IdeaDeepen(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        idea_id = self.kwargs.get('idea_id')
        idea = get_object_or_404(BrainstormingIdea, id=idea_id)
        session = idea.brainstorming_session

        ##############################
        # PERMISSION CHECK FOR - CREATE_BRAINSTORMING_IDEAS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_BRAINSTORMING_IDEAS):
            messages.error(self.request, "You do not have permission to create brainstorming ideas.")
            return redirect('brainstorms:detail_session', session_id=session.id)
        ##############################

        session = get_object_or_404(BrainstormingSession, id=session.id, created_by_user=request.user)
        xc = BrainstormsExecutor(session=session)
        xc.deepen_thought_over_idea(idea=idea)
        messages.success(request, f'Idea {idea.id} deepened successfully.')
        logger.info(f'Idea {idea.id} deepened successfully.')
        return redirect('brainstorms:detail_session', session_id=session.id)


Contents of ../../apps/brainstorms/views/session/list_brainstorming_sessions_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_brainstorming_sessions_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class BrainstormingView_SessionList(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_BRAINSTORMING_SESSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_BRAINSTORMING_SESSIONS):
            messages.error(self.request, "You do not have permission to list brainstorming sessions.")
            return context
        ##############################

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['sessions'] = BrainstormingSession.objects.filter(organization__in=user_orgs)
        logger.info(f"Brainstorming Sessions were listed.")
        return context


Contents of ../../apps/brainstorms/views/session/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .list_brainstorming_sessions_views import *
from .create_brainstorming_session_views import *
from .update_brainstorming_session_views import *
from .confirm_delete_brainstorming_session import *
from .detail_brainstorming_session_views import *


Contents of ../../apps/brainstorms/views/session/confirm_delete_brainstorming_session.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: confirm_delete_brainstorming_session.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class BrainstormingView_SessionConfirmDelete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        ss_id = self.kwargs.get('session_id')
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=self.request.user)
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['session'] = session
        return context

    def post(self, request, *args, **kwargs):
        ss_id = self.kwargs.get('session_id')
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=request.user)

        ##############################
        # PERMISSION CHECK FOR - DELETE_BRAINSTORMING_SESSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BRAINSTORMING_SESSIONS):
            messages.error(self.request, "You do not have permission to delete brainstorming sessions.")
            return redirect('brainstorms:list_sessions')
        ##############################

        try:
            session_name = session.session_name
            session.delete()  # Delete the brainstorming session from the system
            messages.success(request, f'The session "{session_name}" was deleted successfully.')
        except Exception as e:
            messages.error(request, f"Error deleting session: {str(e)}")
            return self.get(request, *args, **kwargs)
        logger.info(f'The session "{session_name}" was deleted successfully. Session ID: {session.id}')
        return redirect('brainstorms:list_sessions')


Contents of ../../apps/brainstorms/views/session/detail_brainstorming_session_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_brainstorming_session_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging
from collections import defaultdict

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.brainstorms.utils import BrainstormingActionTypeNames
from apps.core.brainstorms.brainstorms_executor import BrainstormsExecutor
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession, BrainstormingIdea, BrainstormingLevelSynthesis, \
    BrainstormingCompleteSynthesis
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class BrainstormingView_SessionDetail(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_BRAINSTORMING_SESSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_BRAINSTORMING_SESSIONS):
            messages.error(self.request, "You do not have permission to list brainstorming sessions.")
            return context
        ##############################

        ss_id = self.kwargs.get('session_id')
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=self.request.user)
        ideas = BrainstormingIdea.objects.filter(brainstorming_session=session).order_by('-depth_level')
        ideas_by_depth = defaultdict(list)
        for idea in ideas:
            ideas_by_depth[idea.depth_level].append(idea)

        level_syntheses = BrainstormingLevelSynthesis.objects.filter(brainstorming_session=session)
        complete_synthesis = BrainstormingCompleteSynthesis.objects.filter(brainstorming_session=session).first()
        max_depth_level = max(ideas_by_depth.keys(), default=1)
        context['session'] = session
        context['ideas_by_depth'] = dict(ideas_by_depth)
        context['level_syntheses'] = level_syntheses
        context['complete_synthesis'] = complete_synthesis
        context['max_depth_level'] = max_depth_level
        return context

    def post(self, request, *args, **kwargs):
        ss_id = self.kwargs.get('session_id')
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=request.user)
        action = request.POST.get('action')
        xc = BrainstormsExecutor(session=session)
        if action == BrainstormingActionTypeNames.CREATE_FIRST_LAYER:
            xc.produce_ideas(depth_level=1)
            messages.success(request, "First layer of ideas created successfully.")
        elif action == BrainstormingActionTypeNames.CREATE_DEEPER_LAYER:
            depth_level = int(request.POST.get('depth_level', 1))
            xc.produce_ideas(depth_level=depth_level)
            messages.success(request, f"Layer {depth_level + 1} of ideas created successfully.")
        elif action == BrainstormingActionTypeNames.GENERATE_LEVEL_SYNTHESIS:
            depth_level = int(request.POST.get('depth_level', 1))
            xc.generate_level_synthesis(depth_level=depth_level)
            messages.success(request, f"Level synthesis for layer {depth_level} generated successfully.")
        elif action == BrainstormingActionTypeNames.GENERATE_COMPLETE_SYNTHESIS:
            xc.generate_complete_synthesis()
            messages.success(request, "Complete synthesis generated successfully.")
        logger.info(f"Action {action} performed successfully. Session ID: {session.id}")
        return redirect('brainstorms:detail_session', session_id=session.id)


Contents of ../../apps/brainstorms/views/session/update_brainstorming_session_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_brainstorming_session_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class BrainstormingView_SessionUpdate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        ss_id = self.kwargs.get('session_id')
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=self.request.user)
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['session'] = session
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['llm_models'] = LLMCore.objects.filter(organization__in=context['organizations'])
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_BRAINSTORMING_SESSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_BRAINSTORMING_SESSIONS):
            messages.error(self.request, "You do not have permission to update brainstorming sessions.")
            return redirect('brainstorms:list_sessions')
        ##############################

        ss_id = self.kwargs.get('session_id')
        session = get_object_or_404(BrainstormingSession, id=ss_id, created_by_user=request.user)
        org_id = request.POST.get('organization')
        llm_id = request.POST.get('llm_model')
        session_name = request.POST.get('session_name')
        topic_definition = request.POST.get('topic_definition')
        constraints = request.POST.get('constraints')
        if org_id and llm_id and session_name and topic_definition:
            try:
                organization = Organization.objects.get(id=org_id)
                llm_model = LLMCore.objects.get(id=llm_id)
                session.organization = organization
                session.llm_model = llm_model
                session.session_name = session_name
                session.topic_definition = topic_definition
                session.constraints = constraints
                session.save()
                messages.success(request, "Brainstorming session updated successfully!")
                logger.info(f'The session "{session_name}" was updated successfully. Session ID: {session.id}')
                return redirect('brainstorms:list_sessions')
            except Exception as e:
                logger.error(f"Error updating brainstorming session: {str(e)}")
                messages.error(request, f"Error updating brainstorming session: {str(e)}")
        else:
            messages.error(request, "All fields are required.")
        return self.get(request, *args, **kwargs)


Contents of ../../apps/brainstorms/views/session/create_brainstorming_session_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_brainstorming_session_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.brainstorms.models import BrainstormingSession
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class BrainstormingView_SessionCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user
        context['organizations'] = Organization.objects.filter(
            users__in=[user]
        )
        context['llm_models'] = LLMCore.objects.filter(
            organization__in=context['organizations']
        )
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_BRAINSTORMING_SESSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_BRAINSTORMING_SESSIONS):
            messages.error(self.request, "You do not have permission to create brainstorming sessions.")
            return redirect('brainstorms:list_sessions')
        ##############################

        org_id = request.POST.get('organization')
        llm_core_id = request.POST.get('llm_model')
        session_name = request.POST.get('session_name')
        topic_definition = request.POST.get('topic_definition')
        constraints = request.POST.get('constraints')
        if org_id and llm_core_id and session_name and topic_definition:
            try:
                organization = Organization.objects.get(id=org_id)
                llm_model = LLMCore.objects.get(id=llm_core_id)
                session = BrainstormingSession.objects.create(
                    organization=organization, llm_model=llm_model, created_by_user=request.user,
                    session_name=session_name, topic_definition=topic_definition, constraints=constraints
                )
                messages.success(request, "Brainstorming session created successfully!")
                logger.info(f"Brainstorming session created successfully. Session ID: {session.id}")
                return redirect('brainstorms:list_sessions')
            except Exception as e:
                logger.error(f"Error creating brainstorming session: {str(e)}")
                messages.error(request, f"Error creating brainstorming session: {str(e)}")
        else:
            messages.error(request, "All fields are required.")
        return self.get(request, *args, **kwargs)


Contents of ../../apps/datasource_ml_models/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .ml_item import *
from .ml_storage import *


Contents of ../../apps/datasource_ml_models/views/ml_item/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_ml_items_views import *
from .create_ml_item_views import *


Contents of ../../apps/datasource_ml_models/views/ml_item/list_ml_items_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_ml_items_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_ml_models.models import DataSourceMLModelConnection, DataSourceMLModelItem
from apps.datasource_ml_models.utils import DELETE_ALL_ML_ITEMS_SPECIFIER
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MLModelView_ItemList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ML_MODEL_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ML_MODEL_FILES):
            messages.error(self.request, "You do not have permission to list ML Model files.")
            return context
        ##############################

        context_user = self.request.user
        conn_by_orgs = []

        try:
            orgs = Organization.objects.filter(users__in=[context_user])
            for org in orgs:
                agents_data = []
                agents = Assistant.objects.filter(organization=org)
                for agent in agents:
                    conns_data = []
                    conns = DataSourceMLModelConnection.objects.filter(assistant=agent)
                    for conn in conns:
                        items = DataSourceMLModelItem.objects.filter(ml_model_base=conn)
                        page = self.request.GET.get('page', 1)
                        paginator = Paginator(items, 5)  # Show 5 items per page
                        try:
                            paginated_items = paginator.page(page)
                        except PageNotAnInteger:
                            paginated_items = paginator.page(1)
                        except EmptyPage:
                            paginated_items = paginator.page(paginator.num_pages)
                        conns_data.append({'connection': conn, 'items': paginated_items})
                    agents_data.append({'assistant': agent, 'ml_model_connections': conns_data})
                conn_by_orgs.append({'organization': org, 'assistants': agents_data})
        except Exception as e:
            logger.error(f"User: {context_user} - ML Model Item - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing ML Model Items.')
            return context

        context['connections_by_organization'] = conn_by_orgs
        logger.info(f"ML Model Items were listed.")
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_ML_MODEL_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ML_MODEL_FILES):
            messages.error(self.request, "You do not have permission to delete ML Model files.")
            return redirect('datasource_ml_models:item_list')
        ##############################

        mgr_id = request.POST.get('storage_id')
        chosen_insts = request.POST.getlist('selected_items')
        chosen_insts = [item for item in chosen_insts if item]
        if DELETE_ALL_ML_ITEMS_SPECIFIER in request.POST:
            DataSourceMLModelItem.objects.filter(ml_model_base__id=mgr_id).delete()
            logger.info(f"All ML models in the selected connection have been deleted.")
            messages.success(request, 'All ML models in the selected connection have been deleted.')
        elif chosen_insts:
            DataSourceMLModelItem.objects.filter(id__in=chosen_insts).delete()
            logger.info(f"Selected ML models have been deleted.")
            messages.success(request, 'Selected ML models have been deleted.')
        return redirect('datasource_ml_models:item_list')


Contents of ../../apps/datasource_ml_models/views/ml_item/create_ml_item_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_ml_item_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_ml_models.forms import DataSourceMLModelItemForm
from apps.datasource_ml_models.models import DataSourceMLModelConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MLModelView_ItemCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            user_orgs = Organization.objects.filter(users__in=[context_user])
            user_agents = Assistant.objects.filter(organization__in=user_orgs)
            ml_managers = DataSourceMLModelConnection.objects.filter(assistant__in=user_agents).all()
            context['ml_model_connections'] = ml_managers
            context['form'] = DataSourceMLModelItemForm()
        except Exception as e:
            logger.error(f"User: {context_user} - ML Model Item - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating ML Model Item.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        form = DataSourceMLModelItemForm(request.POST, request.FILES)

        ##############################
        # PERMISSION CHECK FOR - ADD_ML_MODEL_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_ML_MODEL_FILES):
            messages.error(self.request, "You do not have permission to add ML Model files.")
            return redirect('datasource_ml_models:item_list')
        ##############################

        if form.is_valid():
            ml_model_item = form.save(commit=False)
            uploaded_file = request.FILES['file']
            ml_model_item.file_bytes = uploaded_file.read()
            ml_model_item.ml_model_size = uploaded_file.size
            ml_model_item.created_by_user = request.user
            ml_model_item.save()
            logger.info(f'ML Model Item uploaded: {ml_model_item}')
            messages.success(request, 'ML Model Item uploaded successfully.')
            return redirect('datasource_ml_models:item_list')
        else:
            logger.error('There was an error uploading the ML Model Item.')
            messages.error(request, 'There was an error uploading the ML Model Item.')
            context = self.get_context_data()
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_ml_models/views/ml_storage/update_ml_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_ml_storage_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_ml_models.forms import DataSourceMLModelConnectionForm
from apps.datasource_ml_models.models import DataSourceMLModelConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MLModelView_ManagerUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            mgr = DataSourceMLModelConnection.objects.get(id=kwargs['pk'])
            user_orgs = context_user.organizations.all()
            agents = Assistant.objects.filter(organization__in=user_orgs)
            context['form'] = DataSourceMLModelConnectionForm(instance=mgr)
            context['assistants'] = agents
            context['connection'] = mgr
        except Exception as e:
            logger.error(f"User: {context_user} - ML Model Connection - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating ML Model Connection.')
            return context

        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_ML_MODEL_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_ML_MODEL_CONNECTIONS):
            messages.error(self.request, "You do not have permission to update ML Model Connections.")
            return redirect('datasource_ml_models:list')
        ##############################

        mgr = DataSourceMLModelConnection.objects.get(id=kwargs['pk'])
        form = DataSourceMLModelConnectionForm(request.POST, instance=mgr)
        if form.is_valid():
            form.save()
            logger.info(f"ML Model Connection updated: {mgr}")
            messages.success(request, "ML Model Connection updated successfully.")
            return redirect('datasource_ml_models:list')
        else:
            logger.error("Error updating ML Model Connection: " + str(form.errors))
            messages.error(request, "Error updating ML Model Connection: " + str(form.errors))
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_ml_models/views/ml_storage/list_ml_storages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_ml_storages_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_ml_models.models import DataSourceMLModelConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MLModelView_ManagerList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ML_MODEL_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ML_MODEL_CONNECTIONS):
            messages.error(self.request, "You do not have permission to list ML Model Connections.")
            return context
        ##############################

        context_user = self.request.user

        try:
            mgrs = DataSourceMLModelConnection.objects.filter(
                assistant__in=Assistant.objects.filter(organization__in=context_user.organizations.all())
            ).select_related('assistant__organization')

            mgrs_by_orgs = {}
            for manager in mgrs:
                org = manager.assistant.organization
                agent = manager.assistant
                if org not in mgrs_by_orgs:
                    mgrs_by_orgs[org] = {}
                if agent not in mgrs_by_orgs[org]:
                    mgrs_by_orgs[org][agent] = []
                mgrs_by_orgs[org][agent].append(manager)
        except Exception as e:
            logger.error(f"User: {context_user} - ML Model Connection - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing ML Model Connections.')
            return context

        context['connections_by_organization'] = mgrs_by_orgs
        logger.info(f"ML Model Connections were listed.")
        return context


Contents of ../../apps/datasource_ml_models/views/ml_storage/delete_ml_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_ml_storage_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_ml_models.models import DataSourceMLModelConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MLModelView_ManagerDelete(LoginRequiredMixin, DeleteView):
    model = DataSourceMLModelConnection
    success_url = 'datasource_ml_models:list'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['user'] = self.request.user
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_ML_MODEL_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ML_MODEL_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete ML Model Connections.")
            return redirect('datasource_ml_models:list')
        ##############################

        conn = get_object_or_404(DataSourceMLModelConnection, id=kwargs['pk'])

        try:
            conn.delete()
        except Exception as e:
            logger.error(f"Error deleting ML Model Connection: {e}")
            messages.error(self.request, 'An error occurred while deleting ML Model Connection.')
            return redirect(self.success_url)

        logger.info(f"ML Model Connection deleted: {conn}")
        return redirect(self.success_url)

    def get_queryset(self):
        user = self.request.user
        return DataSourceMLModelConnection.objects.filter(assistant__organization__in=user.organizations.all())


Contents of ../../apps/datasource_ml_models/views/ml_storage/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_ml_storages_views import *
from .create_ml_storage_views import *
from .delete_ml_storage_views import *
from .update_ml_storage_views import *


Contents of ../../apps/datasource_ml_models/views/ml_storage/create_ml_storage_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_ml_storage_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_ml_models.forms import DataSourceMLModelConnectionForm
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class MLModelView_ManagerCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context = TemplateLayout.init(self, context)
        context['form'] = DataSourceMLModelConnectionForm()
        return context

    def post(self, request, *args, **kwargs):
        form = DataSourceMLModelConnectionForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_ML_MODEL_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_ML_MODEL_CONNECTIONS):
            messages.error(self.request, "You do not have permission to create ML Model Connections.")
            return redirect('datasource_ml_models:list')
        ##############################

        if form.is_valid():
            conn = form.save(commit=False)
            conn.created_by_user = request.user
            conn.save()
            logger.info(f"ML Model Connection created: {conn}")
            messages.success(request, 'ML Model Connection created successfully.')
            return redirect('datasource_ml_models:list')
        else:
            logger.error('There was an error creating the ML Model Connection.')
            messages.error(request, 'There was an error creating the ML Model Connection.')
            context = self.get_context_data()
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/leanmod/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 12:51:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .expert_network import *
from .lean_assistant import *


Contents of ../../apps/leanmod/views/lean_assistant/delete_lean_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_lean_assistant_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import LeanAssistant
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class LeanModAssistantView_Delete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        agent_id = kwargs.get('pk')
        context['lean_assistant'] = LeanAssistant.objects.get(id=agent_id)
        return context

    def post(self, request, *args, **kwargs):
        agent_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_LEAN_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_LEAN_ASSISTANT):
            messages.error(self.request, "You do not have permission to delete LeanMod assistants.")
            return redirect('leanmod:list')
        ##############################

        try:
            leanmod_agent = LeanAssistant.objects.get(id=agent_id)
            leanmod_agent.delete()
            logger.info(f"Lean Assistant {leanmod_agent.name} was deleted by User: {self.request.user.id}.")
            messages.success(request, f"Lean Assistant '{leanmod_agent.name}' was deleted successfully.")
        except LeanAssistant.DoesNotExist:
            logger.error("The Lean Assistant does not exist.")
            messages.error(request, "The Lean Assistant does not exist.")
        except Exception as e:
            logger.error(f"An error occurred while deleting the Lean Assistant: {e}")
            messages.error(request, f"An error occurred while deleting the Lean Assistant: {e}")
        return redirect('leanmod:list')


Contents of ../../apps/leanmod/views/lean_assistant/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_lean_assistants_views import *
from .create_lean_assistant_views import *
from .delete_lean_assistant_views import *
from .update_lean_assistant_views import *


Contents of ../../apps/leanmod/views/lean_assistant/update_lean_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_lean_assistant_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import LeanAssistant, ExpertNetwork
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class LeanModAssistantView_Update(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        agent_id = kwargs.get('pk')
        context['lean_assistant'] = LeanAssistant.objects.get(id=agent_id)
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['llm_models'] = LLMCore.objects.filter(organization__users__in=[self.request.user])
        context['expert_networks'] = ExpertNetwork.objects.filter(organization__in=context['organizations'])
        context['selected_expert_networks'] = context['lean_assistant'].expert_networks.all().values_list('id',flat=True)
        return context

    def post(self, request, *args, **kwargs):
        agent_id = kwargs.get('pk')
        leanmod_agent = LeanAssistant.objects.get(id=agent_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_LEAN_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_LEAN_ASSISTANT):
            messages.error(self.request, "You do not have permission to update LeanMod assistants.")
            return redirect('leanmod:list')
        ##############################

        org_id = request.POST.get('organization')
        llm_id = request.POST.get('llm_model')
        name = request.POST.get('name')
        instructions = request.POST.get('instructions')
        nw_ids = request.POST.getlist('expert_networks')
        agent_img = request.FILES.get('lean_assistant_image', None)
        if not org_id or not llm_id or not name or not instructions:
            logger.error("Please fill in all required fields.")
            messages.error(request, "Please fill in all required fields.")
            return redirect('leanmod:update', pk=agent_id)

        try:
            leanmod_agent.organization = Organization.objects.get(id=org_id)
            leanmod_agent.llm_model = LLMCore.objects.get(id=llm_id)
            leanmod_agent.name = name
            leanmod_agent.instructions = instructions
            if agent_img:
                leanmod_agent.lean_assistant_image = agent_img

            leanmod_agent.expert_networks.clear()
            if nw_ids:
                for expert_network_id in nw_ids:
                    expert_network = ExpertNetwork.objects.get(id=expert_network_id)
                    leanmod_agent.expert_networks.add(expert_network)

            leanmod_agent.save()
            logger.info(f"Lean Assistant {leanmod_agent.name} was updated by User: {self.request.user.id}.")
            messages.success(request, "Lean Assistant updated successfully.")
            return redirect('leanmod:list')
        except Exception as e:
            logger.error(f"Error updating Lean Assistant: {e}")
            messages.error(request, f"Error updating Lean Assistant: {e}")
            return redirect('leanmod:update', pk=agent_id)


Contents of ../../apps/leanmod/views/lean_assistant/create_lean_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_lean_assistant_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import ExpertNetwork, LeanAssistant
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class LeanModAssistantView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['llm_models'] = LLMCore.objects.filter(organization__users__in=[self.request.user])
        context['expert_networks'] = ExpertNetwork.objects.filter(organization__in=context['organizations'])
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_LEAN_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_LEAN_ASSISTANT):
            messages.error(self.request, "You do not have permission to add new LeanMod assistants.")
            return redirect('leanmod:list')
        ##############################

        org_id = request.POST.get('organization')
        llm_id = request.POST.get('llm_model')
        name = request.POST.get('name')
        instructions = request.POST.get('instructions')
        nw_ids = request.POST.getlist('expert_networks')
        agent_img = request.FILES.get('lean_assistant_image')
        if not org_id or not llm_id or not name or not instructions:
            logger.error("Please fill in all required fields.")
            messages.error(request, "Please fill in all required fields.")
            return redirect('leanmod:create')

        try:
            org = Organization.objects.get(id=org_id)
            llm_model = LLMCore.objects.get(id=llm_id)
            leanmod_agent = LeanAssistant.objects.create(
                organization=org, llm_model=llm_model, name=name, instructions=instructions,
                lean_assistant_image=agent_img, created_by_user=request.user, last_updated_by_user=request.user)

            if nw_ids:
                for nw_id in nw_ids:
                    nw = ExpertNetwork.objects.get(id=nw_id)
                    leanmod_agent.expert_networks.add(nw)

            leanmod_agent.save()
            logger.info(f"Lean Assistant {leanmod_agent.name} was created by User: {self.request.user.id}.")
            messages.success(request, "Lean Assistant created successfully.")
            return redirect('leanmod:list')
        except Exception as e:
            logger.error(f"Error creating Lean Assistant: {e}")
            messages.error(request, f"Error creating Lean Assistant: {e}")
            return redirect('leanmod:create')


Contents of ../../apps/leanmod/views/lean_assistant/list_lean_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_lean_assistants_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class LeanModAssistantView_List(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_LEAN_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_LEAN_ASSISTANT):
            messages.error(self.request, "You do not have permission to list LeanMod assistants.")
            return context
        ##############################

        org_lean_agents = {}
        orgs = Organization.objects.prefetch_related('lean_assistants').filter(users__in=[self.request.user]).all()
        for organization in orgs:
            org_lean_agents[organization] = organization.lean_assistants.all()
        context['org_lean_assistants'] = org_lean_agents
        logger.info(f"LeanMod Assistants were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/leanmod/views/expert_network/create_expert_network_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_expert_network_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.leanmod.models import ExpertNetwork, ExpertNetworkAssistantReference
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExpertNetworkView_Create(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        user = self.request.user
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['assistants'] = Assistant.objects.filter(organization__users__in=[user])
        context['organizations'] = Organization.objects.filter(users__in=[user])
        return context

    def post(self, request, *args, **kwargs):
        user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - ADD_EXPERT_NETWORK
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_EXPERT_NETWORKS):
            messages.error(self.request, "You do not have permission to add Expert Network.")
            return redirect('leanmod:list_expert_networks')
        ##############################

        name = request.POST.get("network_name")
        desc = request.POST.get("network_description")
        selected_agent_ids = request.POST.getlist("assistants")
        org_id = request.POST.get("organization")
        try:
            org = Organization.objects.get(id=org_id)
        except Organization.DoesNotExist:
            logger.error(f"Selected organization does not exist.")
            messages.error(request, "Selected organization does not exist.")
            return redirect('leanmod:create_expert_network')
        try:
            expert_network = ExpertNetwork.objects.create(
                name=name, meta_description=desc, organization=org, created_by_user=request.user,
                last_updated_by_user=request.user)
        except Exception as e:
            logger.error(f"Error creating Expert Network: {e}")
            messages.error(request, f"Error creating Expert Network: {e}")
            return redirect('leanmod:create_expert_network')

        for agent_id in selected_agent_ids:
            agent = Assistant.objects.get(id=agent_id)
            nw_instructions = request.POST.get(f"context_instructions_{agent_id}")
            try:
                reference = ExpertNetworkAssistantReference.objects.create(
                    network=expert_network, assistant=agent, context_instructions=nw_instructions,
                    created_by_user=request.user, last_updated_by_user=request.user)
                expert_network.assistant_references.add(reference)
                expert_network.save()
            except Exception as e:
                logger.error(f"Error creating Expert Network Assistant Reference: {e}")
                messages.error(request, f"Error creating Expert Network Assistant Reference: {e}")
                return redirect('leanmod:create_expert_network')
        logger.info(f"Expert Network created successfully with selected assistants.")
        messages.success(request, "Expert Network created successfully with selected assistants.")
        return redirect('leanmod:list_expert_networks')


Contents of ../../apps/leanmod/views/expert_network/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_expert_networks_views import *
from .create_expert_network_views import *
from .delete_expert_network_views import *
from .update_expert_network_views import *


Contents of ../../apps/leanmod/views/expert_network/update_expert_network_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_expert_network_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.leanmod.models import ExpertNetwork, ExpertNetworkAssistantReference
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ExpertNetworkView_Update(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user
        nw_id = kwargs.get('pk')
        nw = ExpertNetwork.objects.get(id=nw_id)
        agents = Assistant.objects.filter(organization__users__in=[user])
        agent_refs = nw.assistant_references.all().values('assistant_id', 'assistant__name', 'context_instructions')
        context['expert_network'] = nw
        context['assistants'] = agents
        context['assistant_references'] = [
            {
                'id': ref['assistant_id'],
                'name': ref['assistant__name'],
                'context_instructions': ref['context_instructions']
            } for ref in agent_refs]
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_EXPERT_NETWORKS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_EXPERT_NETWORKS):
            messages.error(self.request, "You do not have permission to update Expert Network.")
            return redirect('leanmod:list_expert_networks')
        ##############################

        user = self.request.user
        nw_id = kwargs.get('pk')
        nw = ExpertNetwork.objects.get(id=nw_id)
        nw.name = request.POST.get("network_name")
        nw.meta_description = request.POST.get("network_description")
        nw.save()
        nw.assistant_references.clear()
        selected_agent_ids = request.POST.getlist("assistants")

        try:
            for agent_id in selected_agent_ids:
                agent = Assistant.objects.get(id=agent_id)
                nw_instructions = request.POST.get(f"context_instructions_{agent_id}")
                reff, created = ExpertNetworkAssistantReference.objects.get_or_create(
                    network=nw, assistant=agent, defaults={
                        'context_instructions': nw_instructions, 'created_by_user': request.user,
                        'last_updated_by_user': request.user})
                if not created:
                    reff.context_instructions = nw_instructions
                    reff.last_updated_by_user = request.user
                    reff.save()
                nw.assistant_references.add(reff)
        except Exception as e:
            logger.error(f"Error updating Expert Network: {e}")
            messages.error(request, f"Error updating Expert Network: {e}")
            return redirect('leanmod:update_expert_network', pk=nw_id)

        logger.info(f"Expert Network {nw.name} was updated by User: {user.id}.")
        messages.success(request, "Expert Network updated successfully.")
        return redirect('leanmod:update_expert_network', pk=nw_id)


Contents of ../../apps/leanmod/views/expert_network/list_expert_networks_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_expert_networks_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import ExpertNetwork
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExpertNetworkView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_EXPERT_NETWORKS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_EXPERT_NETWORKS):
            messages.error(self.request, "You do not have permission to list Expert Network.")
            return context
        ##############################

        nws = ExpertNetwork.objects.prefetch_related('assistant_references__assistant','organization').filter(
            organization__users__in=[self.request.user]).all()
        context['expert_networks'] = nws
        logger.info(f"Expert Networks were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/leanmod/views/expert_network/delete_expert_network_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_expert_network_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import ExpertNetwork
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ExpertNetworkView_Delete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        nw_id = kwargs.get('pk')
        nw = get_object_or_404(ExpertNetwork, id=nw_id)
        context['expert_network'] = nw
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_EXPERT_NETWORKS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_EXPERT_NETWORKS):
            messages.error(self.request, "You do not have permission to delete Expert Network.")
            return redirect('leanmod:list_expert_networks')
        ##############################

        nw_id = kwargs.get('pk')
        nw = get_object_or_404(ExpertNetwork, id=nw_id)

        try:
            nw.delete()
        except Exception as e:
            logger.error(f"An error occurred while deleting Expert Network {nw.name}. Error: {str(e)}")
            messages.error(request, f"An error occurred while deleting Expert Network {nw.name}. Error: {str(e)}")
            return redirect('leanmod:list_expert_networks')

        logger.info(f"Expert Network {nw.name} was deleted by User: {self.request.user.id}.")
        messages.success(request, f'The expert network "{nw.name}" has been deleted successfully.')
        return redirect('leanmod:list_expert_networks')


Contents of ../../apps/video_generations/views/confirm_delete_video_generator_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: confirm_delete_video_generator_connection_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VideoGeneratorView_ConfirmDelete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        pk = self.kwargs.get('pk')
        video_generator_connection = get_object_or_404(VideoGeneratorConnection, pk=pk)
        context['video_generator_connection'] = video_generator_connection
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_VIDEO_GENERATOR_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_VIDEO_GENERATOR_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete video generator connections.")
            return redirect('video_generations:list')
        ##############################

        pk = self.kwargs.get('pk')
        video_generator_connection = get_object_or_404(VideoGeneratorConnection, pk=pk)

        try:
            video_generator_connection.delete()
        except Exception as e:
            logger.error(f"Video Generator Connection deletion failed. Error: {e}")
            messages.error(request,
                           f'The Video Generator Connection "{video_generator_connection.name}" could not be deleted.')
            return redirect('video_generations:list')

        logger.info(f"Video Generator Connection was deleted by User: {self.request.user.id}.")
        messages.success(request, 'Video Generator Connection deleted successfully.')
        return redirect('video_generations:list')


Contents of ../../apps/video_generations/views/create_video_generator_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_video_generator_connection_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import render, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.core.video_generation.utils import VIDEO_GENERATOR_PROVIDER_TYPES
from apps.assistants.models import Assistant
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VideoGeneratorView_Create(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['assistants'] = Assistant.objects.filter(organization__in=context['organizations'])
        context['provider_choices'] = VIDEO_GENERATOR_PROVIDER_TYPES
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_VIDEO_GENERATOR_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_VIDEO_GENERATOR_CONNECTIONS):
            messages.error(self.request, "You do not have permission to create video generator connections.")
            return redirect('video_generations:list')
        ##############################

        org_id = request.POST.get('organization')
        agent_id = request.POST.get('assistant')
        name = request.POST.get('name')
        description = request.POST.get('description')
        provider = request.POST.get('provider')
        provider_api_key = request.POST.get('provider_api_key')
        errors = {}
        if not org_id:
            errors['organization'] = 'Organization is required.'
        if not agent_id:
            errors['assistant'] = 'Assistant is required.'
        if not name:
            errors['name'] = 'Name is required.'
        if not description:
            errors['description'] = 'Description is required.'
        if not provider:
            errors['provider'] = 'Provider is required.'
        if not provider_api_key:
            errors['provider_api_key'] = 'Provider API Key is required.'

        if errors:
            context = self.get_context_data()
            context['error_messages'] = errors
            logger.error(f"Error creating the Video Generator Connection. Errors: {errors}")
            return render(request, self.template_name, context)

        orgg = None
        agent = None
        try:
            orgg = Organization.objects.get(id=org_id)
        except Organization.DoesNotExist:
            logger.error(f"Organization with ID {org_id} does not exist.")
            errors['organization'] = 'Selected organization does not exist.'
        try:
            agent = Assistant.objects.get(id=agent_id)
        except Assistant.DoesNotExist:
            logger.error(f"Assistant with ID {agent_id} does not exist.")
            errors['assistant'] = 'Selected assistant does not exist.'
        if errors:
            context = self.get_context_data()
            context['error_messages'] = errors
            logger.error(f"Error creating the Video Generator Connection. Errors: {errors}")
            return render(request, self.template_name, context)

        if orgg is None:
            errors['organization'] = 'Selected organization does not exist.'
        if agent is None:
            errors['assistant'] = 'Selected assistant does not exist.'
        if errors:
            context = self.get_context_data()
            context['error_messages'] = errors
            logger.error(f"Error creating the Video Generator Connection. Errors: {errors}")
            return render(request, self.template_name, context)

        try:
            video_generator_connection = VideoGeneratorConnection(
                organization=orgg, assistant=agent, created_by_user=request.user, name=name, description=description,
                provider=provider, provider_api_key=provider_api_key)
            video_generator_connection.save()
        except Exception as e:
            logger.error(f"Error creating the Video Generator Connection. Error: {e}")
            messages.error(request, 'Error creating the Video Generator Connection.')
            return redirect('video_generations:create')

        logger.info(f"Video Generator Connection created by User: {self.request.user.id}.")
        messages.success(request, 'Video Generator Connection created successfully.')
        return redirect('video_generations:list')


Contents of ../../apps/video_generations/views/list_video_generator_connections_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_video_generator_connections_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class VideoGeneratorView_Connections(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_VIDEO_GENERATOR_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_VIDEO_GENERATOR_CONNECTIONS):
            messages.error(self.request, "You do not have permission to list video generator connections.")
            return context
        ##############################

        user_organizations = Organization.objects.filter(users__in=[self.request.user])
        context['video_generator_connections'] = VideoGeneratorConnection.objects.filter(
            organization__in=user_organizations)
        logger.info(f"Video Generator Connections were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/video_generations/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .create_video_generator_connection_views import *
from .update_video_generator_connection_views import *
from .list_video_generator_connections_views import *
from .confirm_delete_video_generator_connection_views import *


Contents of ../../apps/video_generations/views/update_video_generator_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_video_generator_connection_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, render, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.core.video_generation.utils import VIDEO_GENERATOR_PROVIDER_TYPES
from apps.assistants.models import Assistant
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VideoGeneratorView_Update(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        pk = self.kwargs.get('pk')
        video_generator_connection = get_object_or_404(VideoGeneratorConnection, pk=pk)
        context['video_generator_connection'] = video_generator_connection
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['assistants'] = Assistant.objects.filter(organization__in=context['organizations'])
        context['provider_choices'] = VIDEO_GENERATOR_PROVIDER_TYPES
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_VIDEO_GENERATOR_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_VIDEO_GENERATOR_CONNECTIONS):
            messages.error(self.request, "You do not have permission to update video generator connections.")
            return redirect('video_generations:list')
        ##############################

        pk = self.kwargs.get('pk')
        video_generator_connection = get_object_or_404(VideoGeneratorConnection, pk=pk)
        org_id = request.POST.get('organization')
        agent_id = request.POST.get('assistant')
        name = request.POST.get('name')
        description = request.POST.get('description')
        provider = request.POST.get('provider')
        provider_api_key = request.POST.get('provider_api_key')

        errors = {}
        if not org_id:
            errors['organization'] = 'Organization is required.'
        if not agent_id:
            errors['assistant'] = 'Assistant is required.'
        if not name:
            errors['name'] = 'Name is required.'
        if not description:
            errors['description'] = 'Description is required.'
        if not provider:
            errors['provider'] = 'Provider is required.'
        if not provider_api_key:
            errors['provider_api_key'] = 'Provider API Key is required.'

        if errors:
            context = self.get_context_data()
            context['error_messages'] = errors
            logger.error(f"Error updating the Video Generator Connection. Errors: {errors}")
            return render(request, self.template_name, context)

        orgg = None
        agent = None
        try:
            orgg = Organization.objects.get(id=org_id)
        except Organization.DoesNotExist:
            logger.error(f"Organization with ID {org_id} does not exist.")
            errors['organization'] = 'Selected organization does not exist.'
        try:
            agent = Assistant.objects.get(id=agent_id)
        except Assistant.DoesNotExist:
            logger.error(f"Assistant with ID {agent_id} does not exist.")
            errors['assistant'] = 'Selected assistant does not exist.'
        if errors:
            context = self.get_context_data()
            context['error_messages'] = errors
            logger.error(f"Error updating the Video Generator Connection. Errors: {errors}")
            return render(request, self.template_name, context)

        if orgg is None:
            errors['organization'] = 'Selected organization does not exist.'
            logger.error(f"Error updating the Video Generator Connection. Errors: {errors}")
        if agent is None:
            errors['assistant'] = 'Selected assistant does not exist.'
            logger.error(f"Error updating the Video Generator Connection. Errors: {errors}")
        if errors:
            context = self.get_context_data()
            context['error_messages'] = errors
            logger.error(f"Error updating the Video Generator Connection. Errors: {errors}")
            return render(request, self.template_name, context)

        try:
            video_generator_connection.organization = orgg
            video_generator_connection.assistant = agent
            video_generator_connection.name = name
            video_generator_connection.description = description
            video_generator_connection.provider = provider
            video_generator_connection.provider_api_key = provider_api_key
            video_generator_connection.save()
        except Exception as e:
            logger.error(f"Error updating the Video Generator Connection. Error: {e}")
            messages.error(request, f'Error updating the Video Generator Connection.')
            return redirect('video_generations:list')

        logger.info(f"Video Generator Connection updated by User: {self.request.user.id}.")
        messages.success(request, 'Video Generator Connection updated successfully.')
        return redirect('video_generations:list')


Contents of ../../apps/export_orchestrations/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .endpoints import *
from .export_orchestrations import *


Contents of ../../apps/export_orchestrations/views/endpoints/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .endpoint_export_orchestration_views import *


Contents of ../../apps/export_orchestrations/views/endpoints/endpoint_export_orchestration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: endpoint_export_orchestration_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import json
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.orchestration.orchestration_executor import OrchestrationExecutor
from apps.export_orchestrations.models import ExportOrchestrationAPI, OrchestratorRequestLog
from apps.export_orchestrations.utils import ExportOrchestrationRequestStatusCodes
from apps.orchestrations.models import OrchestrationQuery, OrchestrationQueryLog
from apps.orchestrations.utils import OrchestrationQueryLogTypesNames
from config.settings import BASE_URL

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class ExportOrchestrationAPIHealthCheckView(View):
    def post(self, request, *args, **kwargs):
        endpoint = (BASE_URL + request.path).replace("health", "app")
        api_key = request.headers.get('Authorization')
        try:
            export_assistant = ExportOrchestrationAPI.objects.get(endpoint=endpoint)
        except ExportOrchestrationAPI.DoesNotExist:
            return JsonResponse({
                "message": "Invalid Orchestration endpoint", "data": {}, "status": ExportOrchestrationRequestStatusCodes.NOT_FOUND
            }, status=ExportOrchestrationRequestStatusCodes.NOT_FOUND)

        if not export_assistant.is_online:
            logger.error(f"The Orchestration endpoint is currently offline: {endpoint}")
            return JsonResponse({
                "message": "The Orchestration endpoint is currently offline. Please try again later.", "data": {},
                "status": ExportOrchestrationRequestStatusCodes.SERVICE_OFFLINE
            }, status=ExportOrchestrationRequestStatusCodes.SERVICE_OFFLINE)

        if (not export_assistant.is_public) and export_assistant.custom_api_key != api_key:
            logger.error(f"Invalid Orchestration API key provided for endpoint: {endpoint}")
            return JsonResponse({
                "message": "The Orchestration API key provided is invalid, please provide a valid API key.", "data": {},
                "status": ExportOrchestrationRequestStatusCodes.UNAUTHORIZED
            }, status=ExportOrchestrationRequestStatusCodes.UNAUTHORIZED)

        OrchestratorRequestLog.objects.create(export_orchestration=export_assistant)
        if export_assistant.requests_in_last_hour() > export_assistant.request_limit_per_hour:
            logger.error(f"The Orchestration API request limit has been reached for endpoint: {endpoint}")
            return JsonResponse({
                "error": "The Orchestration API request limit has been reached. Please try again later.",
                "data": {
                    "request_limit_per_hour": export_assistant.request_limit_per_hour,
                    "requests_in_last_hour": export_assistant.requests_in_last_hour()
                },
            }, status=ExportOrchestrationRequestStatusCodes.TOO_MANY_REQUESTS)

        return JsonResponse({
            "message": "The Orchestration endpoint is online and ready to serve requests.", "data": {},
            "status": ExportOrchestrationRequestStatusCodes.OK
        }, status=ExportOrchestrationRequestStatusCodes.OK)


@method_decorator(csrf_exempt, name='dispatch')
class ExportOrchestrationAPIView(View):
    def post(self, request, *args, **kwargs):
        endpoint = BASE_URL + request.path
        api_key = request.headers.get('Authorization')
        try:
            export_assistant: ExportOrchestrationAPI = ExportOrchestrationAPI.objects.get(endpoint=endpoint)
        except ExportOrchestrationAPI.DoesNotExist:
            logger.error(f"Invalid Orchestration endpoint: {endpoint}")
            return JsonResponse({
                "message": "Invalid Orchestration endpoint", "data": {}, "status": ExportOrchestrationRequestStatusCodes.NOT_FOUND
            }, status=ExportOrchestrationRequestStatusCodes.NOT_FOUND)

        if not export_assistant.is_online:
            logger.error(f"The Orchestration endpoint is currently offline: {endpoint}")
            return JsonResponse({
                "message": "The Orchestration endpoint is currently offline. Please try again later.", "data": {},
                "status": ExportOrchestrationRequestStatusCodes.SERVICE_OFFLINE
            }, status=ExportOrchestrationRequestStatusCodes.SERVICE_OFFLINE)

        if (not export_assistant.is_public) and export_assistant.custom_api_key != api_key:
            logger.error(f"Invalid Orchestration API key provided for endpoint: {endpoint}")
            return JsonResponse({
                "message": "The Orchestration API key provided is invalid, please provide a valid API key.", "data": {},
                "status": ExportOrchestrationRequestStatusCodes.UNAUTHORIZED
            }, status=ExportOrchestrationRequestStatusCodes.UNAUTHORIZED)

        OrchestratorRequestLog.objects.create(export_orchestration=export_assistant)
        if export_assistant.requests_in_last_hour() > export_assistant.request_limit_per_hour:
            logger.error(f"The Orchestration API request limit has been reached for endpoint: {endpoint}")
            return JsonResponse({
                "error": "The Orchestration API request limit has been reached. Please try again later.",
                "data": {
                    "request_limit_per_hour": export_assistant.request_limit_per_hour,
                    "requests_in_last_hour": export_assistant.requests_in_last_hour()
                },
            }, status=ExportOrchestrationRequestStatusCodes.TOO_MANY_REQUESTS)

        body = json.loads(request.body)
        try:
            chat_history = body.get('chat_history')
            if len(chat_history) == 0:
                logger.error("Chat history is empty.")
                raise ValueError("Chat history is empty.")
            if "role" not in chat_history[0]:
                logger.error("Each of the chat history elements must contain 'role' key.")
                raise ValueError("Each of the chat history elements must contain 'role' key, which can either"
                                 "be 'system', 'assistant' or 'user'.")
            if chat_history[0]["role"] not in ["system", "assistant", "user"]:
                logger.error("Invalid chat history: The 'role' key in the first element of the chat history must be either 'system',"
                             "'assistant' or 'user'.")
                raise ValueError("The 'role' key in the first element of the chat history must be either 'system',"
                                 "'assistant' or 'user'.")
            if "content" not in chat_history[0]:
                logger.error("Each of the chat history elements must contain 'content' key.")
                raise ValueError("Each of the chat history elements must contain 'content' key.")
            if not isinstance(chat_history[0]["content"], str):
                logger.error("Invalid chat history: The 'content' key in the first element of the chat history must be a string.")
                raise ValueError("The 'content' key in the first element of the chat history must be a string.")
        except Exception as e:
            logger.error(f"Invalid chat history: {str(e)}")
            return JsonResponse({
                "message": "Internal server error: " + str(e), "data": {},
                "status": ExportOrchestrationRequestStatusCodes.INTERNAL_SERVER_ERROR
            }, status=ExportOrchestrationRequestStatusCodes.INTERNAL_SERVER_ERROR)

        user_msg = None
        api_chat: OrchestrationQuery = None
        try:
            for msg in chat_history:
                role = msg["role"]
                content = msg["content"]
                f_uris = []
                img_uris = []
                if "file_uris" in msg and msg["file_uris"] != "":
                    f_uris = msg.get("file_uris", "").split(",") if msg.get("file_uris") else []
                if "image_uris" in msg and msg["image_uris"] != "":
                    img_uris = msg.get("image_uris", "").split(",") if msg.get("image_uris") else []

                f_uris = [uri.strip() for uri in f_uris if uri.strip()] if f_uris else []
                img_uris = [uri.strip() for uri in img_uris if uri.strip()]

                user_msg = content
                api_chat = OrchestrationQuery.objects.create(
                    maestro=export_assistant.orchestrator,
                    query_text=user_msg,
                    created_by_user=export_assistant.created_by_user,
                    last_updated_by_user=export_assistant.created_by_user
                )
                query_log = OrchestrationQueryLog.objects.create(
                    orchestration_query=api_chat,
                    log_type=OrchestrationQueryLogTypesNames.USER,
                    log_text_content=content + f"""
                        -----

                        **IMAGE URLS:**
                        '''
                        {img_uris}
                        '''

                        -----

                        **FILE URLS:**
                        '''
                        {f_uris}
                        '''

                        -----
                    """,
                    log_file_contents=f_uris,
                    log_image_contents=img_uris
                )
                api_chat.logs.add(query_log)
                api_chat.save()

        except Exception as e:
            logger.error(f"Invalid chat history: {str(e)}")
            return JsonResponse({
                "message": "Internal server error: " + str(e), "data": {},
                "status": ExportOrchestrationRequestStatusCodes.INTERNAL_SERVER_ERROR
            }, status=ExportOrchestrationRequestStatusCodes.INTERNAL_SERVER_ERROR)

        try:
            orch_xc = OrchestrationExecutor(maestro=export_assistant.orchestrator, query_chat=api_chat)
            final_output = orch_xc.execute_for_query()
        except Exception as e:
            logger.error(f"Error executing orchestration for endpoint: {endpoint}")
            return JsonResponse({
                "message": "Internal server error: " + str(e), "data": {},
                "status": ExportOrchestrationRequestStatusCodes.INTERNAL_SERVER_ERROR
            }, status=ExportOrchestrationRequestStatusCodes.INTERNAL_SERVER_ERROR)

        response_data = {
            "message": "Success",
            "data": {
                "metadata": {
                    "organization": {"organization_name": export_assistant.orchestrator.organization.name},
                    "assistant": {"assistant_name": export_assistant.orchestrator.name}
                },
                "message": {
                    "assistant_name": export_assistant.orchestrator.name,
                    "content": final_output,
                    "role": "assistant",
                    "media": {"files": [], "images": []}
                }
            }
        }
        logger.info(f"Orchestration executed successfully for endpoint: {endpoint}")
        return JsonResponse(response_data, status=ExportOrchestrationRequestStatusCodes.OK)



Contents of ../../apps/export_orchestrations/views/export_orchestrations/list_export_orchestrations_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_export_orchestrations_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_orchestrations.models import ExportOrchestrationAPI
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from config.settings import MAX_ORCHESTRATIONS_EXPORTS_ORGANIZATION
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ExportOrchestrationView_List(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_EXPORT_ORCHESTRATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_EXPORT_ORCHESTRATION):
            messages.error(self.request, "You do not have permission to list Export Orchestration APIs.")
            return context
        ##############################

        user_context = self.request.user
        max_exp_orchs = MAX_ORCHESTRATIONS_EXPORTS_ORGANIZATION

        try:
            org_data = []
            orgs = Organization.objects.filter(users=user_context)
            for org in orgs:
                n_exp_agents = org.exported_orchestrations.count()
                agents_pct = round((n_exp_agents / max_exp_orchs) * 100, 2)
                exp_agents = org.exported_orchestrations.all()
                for agent in exp_agents:
                    agent.usage_percentage = 100
                org_data.append({
                    'organization': org, 'export_assistants_count': n_exp_agents, 'assistants_percentage': agents_pct,
                    'export_assistants': exp_agents, 'limit': max_exp_orchs
                })
            exp_agents = ExportOrchestrationAPI.objects.filter(created_by_user=user_context)
            context["user"] = user_context
            context["organization_data"] = org_data
            context["export_assistants"] = exp_agents
        except Exception as e:
            messages.error(self.request, f"An error occurred: {str(e)}")
            return context

        logger.info(f"User: {user_context.id} listed Export Orchestration APIs.")
        return context


Contents of ../../apps/export_orchestrations/views/export_orchestrations/delete_export_orchestration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_export_orchestration_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_orchestrations.models import ExportOrchestrationAPI
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExportOrchestrationView_Delete(LoginRequiredMixin, DeleteView):
    model = ExportOrchestrationAPI
    success_url = 'export_orchestrations:list'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_EXPORT_ORCHESTRATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_EXPORT_ORCHESTRATION):
            messages.error(self.request, "You do not have permission to delete Export Orchestration APIs.")
            return redirect('export_orchestrations:list')
        ##############################

        exp_agent = get_object_or_404(ExportOrchestrationAPI, id=self.kwargs['pk'])
        exp_agent.delete()
        success_message = "Export Orchestration deleted successfully."
        org = exp_agent.orchestrator.organization
        org.exported_orchestrations.remove(exp_agent)
        org.save()
        logger.info(f"Export Orchestration was deleted by User: {request.user.id}.")
        messages.success(request, success_message)
        return redirect(self.success_url)


Contents of ../../apps/export_orchestrations/views/export_orchestrations/update_export_orchestration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_export_orchestration_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_orchestrations.models import ExportOrchestrationAPI
from apps.orchestrations.models import Maestro
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExportOrchestrationView_Update(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        exp_agent = get_object_or_404(ExportOrchestrationAPI, pk=self.kwargs['pk'])
        context['export_assistant'] = exp_agent
        context['assistants'] = Maestro.objects.filter(organization__users__in=[self.request.user])
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_EXPORT_ORCHESTRATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_EXPORT_ORCHESTRATION):
            messages.error(self.request, "You do not have permission to update Export Orchestration APIs.")
            return redirect('export_orchestrations:list')
        ##############################

        exp_agent = get_object_or_404(ExportOrchestrationAPI, pk=self.kwargs['pk'])
        exp_agent: ExportOrchestrationAPI
        exp_agent.orchestrator_id = request.POST.get('assistant')
        exp_agent.request_limit_per_hour = request.POST.get('request_limit_per_hour')
        exp_agent.is_public = request.POST.get('is_public') == 'on'
        if exp_agent.orchestrator_id and exp_agent.request_limit_per_hour:
            exp_agent.save()
            messages.success(request, "Export Orchestration updated successfully.")
            return redirect('export_orchestrations:list')
        else:
            messages.error(request, "There was an error updating the Export Orchestration.")
        context = self.get_context_data()
        context.update({'export_assistant': exp_agent,
                        'assistants': Maestro.objects.filter(organization__users__in=[self.request.user]).all()})
        logger.error(f"Export Orchestration was not updated by User: {request.user.id}.")
        return render(request, self.template_name, context)


Contents of ../../apps/export_orchestrations/views/export_orchestrations/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .create_export_orchestration_views import *
from .delete_export_orchestration_views import *
from .list_export_orchestrations_views import *
from .update_export_orchestration_views import *
from .toggle_service_export_orchestrations_views import *


Contents of ../../apps/export_orchestrations/views/export_orchestrations/create_export_orchestration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_export_orchestration_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_orchestrations.management.commands.start_exported_orchestrations import \
    start_endpoint_for_orchestration
from apps.export_orchestrations.models import ExportOrchestrationAPI
from apps.orchestrations.models import Maestro
from apps.user_permissions.utils import PermissionNames
from config.settings import MAX_ORCHESTRATIONS_EXPORTS_ORGANIZATION
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExportOrchestrationView_Create(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_context = self.request.user
        agents = Maestro.objects.filter(organization__users=user_context)
        context["user"] = user_context
        context["assistants"] = agents
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_EXPORT_ORCHESTRATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_EXPORT_ORCHESTRATION):
            messages.error(self.request, "You do not have permission to add Export Orchestration APIs.")
            return redirect('export_orchestrations:list')
        ##############################

        agent_id = request.POST.get('assistant')
        agent = get_object_or_404(Maestro, pk=agent_id)
        is_public = request.POST.get('is_public') == 'on'
        req_limit_hourly = request.POST.get('request_limit_per_hour')

        if ExportOrchestrationAPI.objects.filter(
            created_by_user=request.user).count() > MAX_ORCHESTRATIONS_EXPORTS_ORGANIZATION:
            logger.error(f"User: {request.user.id} tried to create more than {MAX_ORCHESTRATIONS_EXPORTS_ORGANIZATION} "
                         f"Export Orchestration APIs.")
            messages.error(request, f"Maximum number of Export Orchestration APIs reached for the organization.")
            return self.render_to_response(self.get_context_data())

        if not agent_id or not req_limit_hourly:
            logger.error(f"User: {request.user.id} tried to create Export Orchestration API without required fields.")
            messages.error(request, "Orchestration Assistant ID and Request Limit Per Hour are required.")
            return self.render_to_response(self.get_context_data())

        try:
            new_export_assistant = ExportOrchestrationAPI.objects.create(
                orchestrator_id=agent_id, is_public=is_public, request_limit_per_hour=req_limit_hourly,
                created_by_user=request.user)

            org = agent.organization
            if not org.exported_orchestrations:
                org.exported_orchestrations.set([new_export_assistant])
            else:
                org.exported_orchestrations.add(new_export_assistant)
            org.save()
            start_endpoint_for_orchestration(assistant=new_export_assistant)
            logger.info(f"Export Orchestration API was created by User: {request.user.id}.")
            messages.success(request, "Export Orchestration API created successfully!")
            return redirect("export_orchestrations:list")
        except Exception as e:
            logger.error(f"Error creating Export Orchestration API by User: {request.user.id}.")
            messages.error(request, f"Error creating Export Orchestration API: {str(e)}")
            return self.render_to_response(self.get_context_data())


Contents of ../../apps/export_orchestrations/views/export_orchestrations/toggle_service_export_orchestrations_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: toggle_service_export_orchestrations_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import importlib
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_orchestrations.management.commands.start_exported_orchestrations import \
    start_endpoint_for_orchestration
from apps.export_orchestrations.models import ExportOrchestrationAPI
from apps.user_permissions.utils import PermissionNames
from config import settings
from config.settings import EXPORT_ORCHESTRATION_API_BASE_URL


logger = logging.getLogger(__name__)


class ExportOrchestrationView_ToggleService(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_EXPORT_ORCHESTRATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_EXPORT_ORCHESTRATION):
            messages.error(self.request, "You do not have permission to update Export Orchestration APIs.")
            return redirect('export_orchestrations:list')
        ##############################

        exp_agent = get_object_or_404(ExportOrchestrationAPI, pk=self.kwargs['pk'])
        endpoint = EXPORT_ORCHESTRATION_API_BASE_URL + \
                   exp_agent.endpoint.split(EXPORT_ORCHESTRATION_API_BASE_URL)[1]
        api_urls = getattr(importlib.import_module(settings.ROOT_URLCONF), 'urlpatterns')
        exp_agent.is_online = not exp_agent.is_online
        exp_agent.save()
        if exp_agent.is_online:
            if not any(endpoint in str(url) for url in api_urls):
                start_endpoint_for_orchestration(exp_agent)
        logger.info(f"Export Orchestration was toggled by User: {request.user.id}.")
        return redirect('export_orchestrations:list')

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)


Contents of ../../apps/projects/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-24 21:58:24
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 21:58:24
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .team import *
from .project import *


Contents of ../../apps/projects/views/project/delete_project_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_project_views.py
#  Last Modified: 2024-10-24 22:02:10
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:02:10
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.projects.models import ProjectItem
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ProjectsView_ProjectDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        project_id = self.kwargs.get("pk")
        context['project'] = get_object_or_404(ProjectItem, pk=project_id)
        return context

    def post(self, request, *args, **kwargs):
        project_id = self.kwargs.get("pk")
        project = get_object_or_404(ProjectItem, pk=project_id)

        try:
            project.delete()
        except Exception as e:
            messages.error(request, f"An error occurred while deleting the Project: {str(e)}")
            return redirect("projects:project_list")

        messages.success(request, f"Project '{project.project_name}' has been deleted successfully.")
        logger.info(f"Project deleted: {project_id}")
        return redirect('projects:project_list')


Contents of ../../apps/projects/views/project/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-24 22:01:41
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:01:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .list_projects_views import *
from .create_project_views import *
from .delete_project_views import *
from .update_project_views import *


Contents of ../../apps/projects/views/project/list_projects_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_projects_views.py
#  Last Modified: 2024-10-24 22:02:15
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:02:16
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from web_project import TemplateLayout


class ProjectsView_ProjectList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['org_projects'] = {
            org: ProjectItem.objects.filter(organization=org) for org in Organization.objects.filter(
                users__in=[self.request.user]
            )
        }
        return context


Contents of ../../apps/projects/views/project/update_project_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_project_views.py
#  Last Modified: 2024-10-24 22:02:04
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:02:04
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ProjectsView_ProjectUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        project_id = self.kwargs.get("pk")
        project = get_object_or_404(ProjectItem, pk=project_id)
        context['project'] = project
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        return context

    def post(self, request, *args, **kwargs):
        project_id = self.kwargs.get("pk")
        project = get_object_or_404(ProjectItem, pk=project_id)

        try:
            project.organization_id = request.POST.get('organization')
            project.project_name = request.POST.get('project_name')
            project.project_department = request.POST.get('project_department')
            project.project_description = request.POST.get('project_description')
            project.project_status = request.POST.get('project_status')
            project.project_priority = request.POST.get('project_priority')
            project.project_risk_level = request.POST.get('project_risk_level')
            project.project_goals = request.POST.get('project_goals')
            project.project_constraints = request.POST.get('project_constraints')
            project.project_stakeholders = request.POST.get('project_stakeholders')
            project.project_start_date = request.POST.get('project_start_date')
            project.project_end_date = request.POST.get('project_end_date')
            project.project_budget = request.POST.get('project_budget')

            project.save()
        except Exception as e:
            messages.error(request, f"An error occurred while updating the Project: {str(e)}")
            return redirect("projects:project_list")

        messages.success(request, "Project updated successfully!")
        logger.info(f"Project updated successfully: {project.id}")
        return redirect('projects:project_list')


Contents of ../../apps/projects/views/project/create_project_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_project_views.py
#  Last Modified: 2024-10-24 22:01:57
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:01:57
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ProjectsView_ProjectCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        return context

    def post(self, request, *args, **kwargs):
        context_user = request.user
        org_id = request.POST.get('organization')
        project_name = request.POST.get('project_name')
        project_department = request.POST.get('project_department')
        project_description = request.POST.get('project_description')
        project_status = request.POST.get('project_status')
        project_priority = request.POST.get('project_priority')
        project_risk_level = request.POST.get('project_risk_level')
        project_goals = request.POST.get('project_goals')
        project_constraints = request.POST.get('project_constraints')
        project_stakeholders = request.POST.get('project_stakeholders')
        project_start_date = request.POST.get('project_start_date')
        project_end_date = request.POST.get('project_end_date')
        project_budget = request.POST.get('project_budget')

        if not (org_id and project_name and project_department and project_description):
            messages.error(request, "Required fields are missing.")
            return redirect('projects:project_create')

        org = Organization.objects.get(id=org_id)

        try:
            project_item = ProjectItem.objects.create(
                organization=org, project_name=project_name, project_department=project_department,
                project_description=project_description, project_status=project_status,
                project_priority=project_priority, project_risk_level=project_risk_level,
                project_goals=project_goals, project_constraints=project_constraints,
                project_stakeholders=project_stakeholders, project_start_date=project_start_date,
                project_end_date=project_end_date, project_budget=project_budget,
                created_by_user=context_user
            )
        except Exception as e:
            messages.error(request, "Project creation failed.")
            logger.error(f"Project creation failed: {e}")
            return redirect('projects:project_create')

        messages.success(request, "Project created successfully.")
        logger.info(f"Project created successfully: {project_item.id}")
        return redirect('projects:project_list')


Contents of ../../apps/projects/views/team/list_teams_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_teams_views.py
#  Last Modified: 2024-10-24 22:02:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:02:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.organization.models import Organization
from web_project import TemplateLayout


class ProjectsView_TeamList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        org_projects_teams = {}

        for org in user_orgs:
            projects = org.projectitem_set.all()
            project_teams = {}
            for project in projects:
                project_teams[project] = project.project_teams.all()
            org_projects_teams[org] = project_teams

        context['org_projects_teams'] = org_projects_teams
        return context


Contents of ../../apps/projects/views/team/update_team_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_team_views.py
#  Last Modified: 2024-10-24 22:02:39
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:02:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.organization.models import Organization
from apps.projects.models import ProjectTeamItem, ProjectItem
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ProjectsView_TeamUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        team_id = self.kwargs.get('pk')
        team = get_object_or_404(ProjectTeamItem, pk=team_id)
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['projects'] = ProjectItem.objects.filter(organization__in=user_orgs)
        orgs_users = []
        for org in user_orgs:
            org_users = org.users.all()
            orgs_users = orgs_users + list(org_users)
        context['users'] = list(set(orgs_users))
        context['team'] = team
        context['selected_team_members'] = team.team_members.all()
        return context

    def post(self, request, *args, **kwargs):
        team_id = self.kwargs.get('pk')
        team = get_object_or_404(ProjectTeamItem, pk=team_id)
        team_name = request.POST.get("team_name")
        project_id = request.POST.get("project")
        description = request.POST.get("team_description")
        team_lead_id = request.POST.get("team_lead")
        members = request.POST.getlist("team_members")
        if not team_name or not project_id or not team_lead_id:
            messages.error(request, "Team name, project, and team lead are required fields.")
            return redirect("projects:team_update", pk=team_id)

        try:
            project = ProjectItem.objects.get(id=project_id)
            team_lead = User.objects.get(id=team_lead_id)
            team.team_name = team_name
            team.project = project
            team.team_description = description
            team.team_lead = team_lead
            team.save()
            team.team_members.set(User.objects.filter(id__in=members))
        except Exception as e:
            messages.error(request, f"An error occurred while updating the Team: {str(e)}")
            return redirect("projects:team_list")

        messages.success(request, f"Team '{team_name}' has been updated successfully.")
        logger.info(f"Team updated: {team.id}")
        return redirect("projects:team_list")


Contents of ../../apps/projects/views/team/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-24 22:01:45
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:01:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .list_teams_views import *
from .create_team_views import *
from .delete_team_views import *
from .update_team_views import *


Contents of ../../apps/projects/views/team/delete_team_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_team_views.py
#  Last Modified: 2024-10-24 22:02:27
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:02:27
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.projects.models import ProjectTeamItem
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ProjectsView_TeamDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        team_id = self.kwargs.get('pk')
        team = get_object_or_404(ProjectTeamItem, pk=team_id)
        context['team'] = team
        return context

    def post(self, request, *args, **kwargs):
        team_id = self.kwargs.get('pk')
        team = get_object_or_404(ProjectTeamItem, pk=team_id)
        team_name = team.team_name

        try:
            team.delete()
        except Exception as e:
            messages.error(request, f'An error occurred while deleting the Team: {str(e)}')
            return redirect('projects:team_list')

        messages.success(request, f'Team "{team_name}" has been successfully deleted.')
        logger.info(f'Team deleted: {team_name}')
        return redirect('projects:team_list')


Contents of ../../apps/projects/views/team/create_team_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_team_views.py
#  Last Modified: 2024-10-24 22:02:21
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-24 22:02:22
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.organization.models import Organization
from apps.projects.models import ProjectItem, ProjectTeamItem
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ProjectsView_TeamCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['projects'] = ProjectItem.objects.filter(organization__in=user_orgs)
        orgs_users = []
        for org in user_orgs:
            org_users = org.users.all()
            orgs_users = orgs_users + list(org_users)
        orgs_users = list(set(orgs_users))
        context['users'] = orgs_users
        print(context['users'])
        return context

    def post(self, request, *args, **kwargs):
        team_name = request.POST.get("team_name")
        project_id = request.POST.get("project")
        description = request.POST.get("team_description")
        team_lead_id = request.POST.get("team_lead")
        members = request.POST.getlist("team_members")  # Capture selected members
        if not team_name or not project_id or not team_lead_id:
            messages.error(request, "Team name, project, and team lead are required fields.")
            return redirect("projects:team_create")

        try:
            project = ProjectItem.objects.get(id=project_id)
            team_lead = User.objects.get(id=team_lead_id)
            team = ProjectTeamItem.objects.create(
                team_name=team_name,
                project=project,
                team_description=description,
                team_lead=team_lead,
                created_by_user=request.user
            )
            team.team_members.set(User.objects.filter(id__in=members))
        except Exception as e:
            messages.error(request, f"An error occurred while creating the team: {str(e)}")
            return redirect("projects:team_create")

        messages.success(request, f"Team '{team_name}' has been created successfully.")
        logger.info(f"New team created: {team.id}")
        return redirect("projects:team_list")


Contents of ../../apps/user_profile_management/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .remove_credit_card_views import *
from .reset_password_user_profile_views import *
from .list_user_profile_views import *


Contents of ../../apps/user_profile_management/views/reset_password_user_profile_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: reset_password_user_profile_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging
import uuid

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.views.generic import TemplateView

from auth.utils import send_password_reset_email
from config import settings
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class UserProfileView_ResetPassword(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['pk'] = self.kwargs.get('pk')
        return context

    def get(self, request, *args, **kwargs):
        pk = self.get_context_data()['pk']
        try:
            user = User.objects.get(pk=pk)
            email = user.email
            token = str(uuid.uuid4())
            send_password_reset_email(email, token)
            if settings.EMAIL_HOST_USER and settings.EMAIL_HOST_PASSWORD:
                logger.info(f"Password reset email sent to {email}")
                messages.success(request, 'Password reset email sent successfully!')
            else:
                logger.error("Email settings are not configured. Unable to send verification email.")
                messages.error(request, 'Email settings are not configured. Unable to send verification email.')
            logger.info(f"Password reset email sent to {email}")
            messages.success(request, 'Password reset email sent successfully!')
        except Exception as e:
            logger.error(f'Failed to send password reset email: {e}')
            messages.error(request, f'Failed to send password reset email: {e}')
        return self.render_to_response(self.get_context_data())


Contents of ../../apps/user_profile_management/views/remove_credit_card_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: remove_credit_card_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from auth.models import UserCreditCard


logger = logging.getLogger(__name__)


class UserProfileView_CreditCardRemove(LoginRequiredMixin, TemplateView):
    def post(self, request, card_id, *args, **kwargs):
        try:
            card = request.user.credit_cards.get(id=card_id)
            card.delete()
            logger.info(f"Credit card removed by User: {request.user.id}.")
            messages.success(request, 'Credit card removed successfully.')
        except UserCreditCard.DoesNotExist:
            logger.error(f"Credit card not found: {card_id}")
            messages.error(request, 'Credit card not found.')
        return redirect('user_profile_management:list')


Contents of ../../apps/user_profile_management/views/list_user_profile_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_user_profile_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.user_profile_management.forms import ProfileUpdateForm, CreditCardForm
from apps.user_profile_management.utils import infer_credit_card_type
from auth.utils.countries import COUNTRIES
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class UserProfileView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['countries'] = COUNTRIES
        context['profile_form'] = ProfileUpdateForm(instance=self.request.user.profile)
        context['credit_card_form'] = CreditCardForm()
        saved_cards = self.request.user.credit_cards.all()
        cards_with_types = []
        for card in saved_cards:
            card_type = infer_credit_card_type(card.card_number)
            cards_with_types.append({'card': card, 'card_type': card_type})
        context['saved_cards'] = cards_with_types
        return context

    def post(self, request, *args, **kwargs):
        context = self.get_context_data()
        profile = request.user.profile
        if 'first_name' in request.POST:
            profile_form = ProfileUpdateForm(request.POST, request.FILES, instance=profile)
            if profile_form.is_valid():
                profile_form.save()
                logger.info(f"User profile updated: {request.user.id}")
                messages.success(request, 'Your profile was successfully updated!')
                return redirect('user_profile_management:list')
            else:
                logger.error(f"User profile update failed: {request.user.id}")
                messages.error(request, 'Please correct the error(s) below.')
            context = self.get_context_data()
            context['profile_form'] = profile_form
        elif 'card_number' in request.POST:
            credit_card_form = CreditCardForm(request.POST)
            if credit_card_form.is_valid():
                credit_card = credit_card_form.save(commit=False)
                credit_card.user = request.user
                credit_card.save()
                logger.info(f"User credit card added: {request.user.id}")
                messages.success(request, 'Your credit card was successfully updated!')
                return redirect('user_profile_management:list')
            else:
                logger.error(f"User credit card update failed: {request.user.id}")
                messages.error(request, 'Please correct the error(s) below.')
            context['credit_card_form'] = credit_card_form
        return self.render_to_response(context)


Contents of ../../apps/datasource_nosql/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-10 16:16:41
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-10 16:16:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#



Contents of ../../apps/datasource_nosql/views/nosql_query/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-12 13:20:49
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:20:49
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .create_nosql_query_views import *
from .delete_nosql_query_views import *
from .update_nosql_query_views import *
from .list_nosql_queries_views import *


Contents of ../../apps/datasource_nosql/views/nosql_query/update_nosql_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_nosql_query_views.py
#  Last Modified: 2024-10-12 13:22:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:22:36
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.forms import CustomNoSQLQueryForm
from apps.datasource_nosql.models import CustomNoSQLQuery, NoSQLDatabaseConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NoSQLDatabaseView_QueryUpdate(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            query = get_object_or_404(CustomNoSQLQuery, id=kwargs['pk'])
            user_orgs = Organization.objects.filter(users__in=[context_user])
            db_c = NoSQLDatabaseConnection.objects.filter(
                assistant__in=Assistant.objects.filter(organization__in=user_orgs))
            context['database_connections'] = db_c
            context['form'] = CustomNoSQLQueryForm(instance=query)
            context['query'] = query
        except Exception as e:
            logger.error(f"User: {context_user} - NoSQL Query - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating NoSQL Query.')
            return context

        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_CUSTOM_NOSQL_QUERIES
        if not UserPermissionManager.is_authorized(
            user=self.request.user,
            operation=PermissionNames.UPDATE_CUSTOM_NOSQL_QUERIES
        ):
            messages.error(self.request, "You do not have permission to update custom NoSQL queries.")
            return redirect('datasource_nosql:list_queries')
        ##############################

        query = get_object_or_404(CustomNoSQLQuery, id=kwargs['pk'])
        form = CustomNoSQLQueryForm(request.POST, instance=query)
        if form.is_valid():
            form.save()
            logger.info("NoSQL Query updated.")
            messages.success(request, "NoSQL Query updated successfully.")
            return redirect('datasource_nosql:list_queries')
        else:
            logger.error("Error updating NoSQL Query: " + str(form.errors))
            messages.error(request, "Error updating NoSQL Query: " + str(form.errors))
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_nosql/views/nosql_query/create_nosql_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_nosql_query_views.py
#  Last Modified: 2024-10-12 13:22:01
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:22:01
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.forms import CustomNoSQLQueryForm
from apps.datasource_nosql.models import NoSQLDatabaseConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NoSQLDatabaseView_QueryCreate(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            user_orgs = Organization.objects.filter(users__in=[context_user])
            db_c = NoSQLDatabaseConnection.objects.filter(
                assistant__in=Assistant.objects.filter(organization__in=user_orgs))
            context['database_connections'] = db_c
            context['form'] = CustomNoSQLQueryForm()
        except Exception as e:
            logger.error(f"User: {context_user} - NoSQL Query - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating NoSQL Query.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        form = CustomNoSQLQueryForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_CUSTOM_NOSQL_QUERIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_CUSTOM_NOSQL_QUERIES):
            messages.error(self.request, "You do not have permission to create custom NoSQL queries.")
            return redirect('datasource_nosql:list_queries')
        ##############################

        if form.is_valid():
            form.save()
            logger.info("NoSQL Query created.")
            messages.success(request, "NoSQL Query created successfully.")
            return redirect('datasource_nosql:create_query')
        else:
            logger.error("Error creating NoSQL Query.")
            messages.error(request, "Error creating NoSQL Query.")
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_nosql/views/nosql_query/list_nosql_queries_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_nosql_queries_views.py
#  Last Modified: 2024-10-12 13:22:24
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:22:25
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.models import CustomNoSQLQuery
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NoSQLDatabaseView_QueryList(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_CUSTOM_NOSQL_QUERIES
        if not UserPermissionManager.is_authorized(
            user=self.request.user, operation=PermissionNames.LIST_CUSTOM_NOSQL_QUERIES):
            messages.error(self.request, "You do not have permission to list custom NoSQL queries.")
            return context
        ##############################

        context_user = self.request.user
        queries = CustomNoSQLQuery.objects.filter(
            database_connection__assistant__in=Assistant.objects.filter(
                organization__in=context_user.organizations.all())).select_related(
            'database_connection__assistant', 'database_connection__assistant__organization')

        try:
            queries_by_orgs = {}
            for qu in queries:
                org = qu.database_connection.assistant.organization
                agent = qu.database_connection.assistant
                if org not in queries_by_orgs:
                    queries_by_orgs[org] = {}
                if agent not in queries_by_orgs[org]:
                    queries_by_orgs[org][agent] = []
                queries_by_orgs[org][agent].append(qu)
        except Exception as e:
            logger.error(f"User: {context_user} - NoSQL Query - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing NoSQL Queries.')
            return context

        context['queries_by_organization'] = queries_by_orgs
        logger.info(f"NoSQL Queries were listed.")
        return context


Contents of ../../apps/datasource_nosql/views/nosql_query/delete_nosql_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_nosql_query_views.py
#  Last Modified: 2024-10-12 22:17:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 01:17:28
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.models import CustomNoSQLQuery
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class NoSQLDatabaseView_QueryDelete(LoginRequiredMixin, DeleteView):
    model = CustomNoSQLQuery
    success_url = 'datasource_nosql:list_queries'

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_CUSTOM_NOSQL_QUERIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CUSTOM_NOSQL_QUERIES):
            messages.error(self.request, "You do not have permission to delete custom NoSQL queries.")
            return redirect('datasource_nosql:list_queries')
        ##############################

        try:
            self.object = self.get_object()
            self.object.delete()
        except Exception as e:
            logger.error(f"Error deleting NoSQL Query: {e}")
            messages.error(self.request, 'An error occurred while deleting NoSQL Query.')
            return redirect(self.success_url)

        logger.info(f"NoSQL Query {self.object.name} was deleted.")
        messages.success(request, f'NoSQL Query {self.object.name} was deleted successfully.')
        return redirect(self.success_url)


Contents of ../../apps/datasource_nosql/views/nosql_database/delete_nosql_database_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_nosql_database_views.py
#  Last Modified: 2024-10-12 13:21:14
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:21:15
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.models import NoSQLDatabaseConnection
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class NoSQLDatabaseView_ManagerDelete(LoginRequiredMixin, DeleteView):
    model = NoSQLDatabaseConnection
    success_url = 'datasource_nosql:list'

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_NOSQL_DATABASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_NOSQL_DATABASES):
            messages.error(self.request, "You do not have permission to delete NoSQL Data Sources.")
            return redirect('datasource_nosql:list')
        ##############################

        try:
            self.object = self.get_object()
            self.object.delete()
        except Exception as e:
            logger.error(f"Error deleting NoSQL Database Connection: {e}")
            messages.error(self.request, 'An error occurred while deleting NoSQL Database Connection.')
            return redirect(self.success_url)

        logger.info(f"NoSQL Database Connection {self.object.name} was deleted.")
        messages.success(request, f'NoSQL Database Connection {self.object.name} was deleted successfully.')
        return redirect(self.success_url)


Contents of ../../apps/datasource_nosql/views/nosql_database/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-12 13:20:42
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:20:42
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .list_nosql_database_views import *
from .create_nosql_database_views import *
from .delete_nosql_database_views import *
from .update_nosql_database_views import *


Contents of ../../apps/datasource_nosql/views/nosql_database/update_nosql_database_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_nosql_database_views.py
#  Last Modified: 2024-10-12 13:21:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:21:36
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.forms import NoSQLDatabaseConnectionForm
from apps.datasource_nosql.models import NoSQLDatabaseConnection
from apps.datasource_nosql.utils import NOSQL_DATABASE_CHOICES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NoSQLDatabaseView_ManagerUpdate(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            conn = NoSQLDatabaseConnection.objects.get(id=kwargs['pk'])
            user_orgs = context_user.organizations.all()
            agents = Assistant.objects.filter(organization__in=user_orgs)
            context['dbms_choices'] = NOSQL_DATABASE_CHOICES
            context['form'] = NoSQLDatabaseConnectionForm(instance=conn)
            context['assistants'] = agents
            context['connection'] = conn
        except Exception as e:
            logger.error(f"User: {context_user} - NoSQL Data Source - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating NoSQL Data Source.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - UPDATE_NOSQL_DATABASES
        if not UserPermissionManager.is_authorized(
            user=self.request.user, operation=PermissionNames.UPDATE_NOSQL_DATABASES):
            messages.error(self.request, "You do not have permission to update NoSQL Data Sources.")
            return redirect('datasource_nosql:list')
        ##############################

        conn = NoSQLDatabaseConnection.objects.get(id=kwargs['pk'], created_by_user=context_user)
        form = NoSQLDatabaseConnectionForm(request.POST, instance=conn)
        if form.is_valid():
            form.save()
            logger.info(f"NoSQL Data Source updated: {conn}")
            messages.success(request, "NoSQL Data Source updated successfully.")
            return redirect('datasource_nosql:list')
        else:
            logger.error("Error updating NoSQL Data Source: " + str(form.errors))
            messages.error(request, "Error updating NoSQL Data Source: " + str(form.errors))
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_nosql/views/nosql_database/list_nosql_database_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_nosql_database_views.py
#  Last Modified: 2024-10-12 13:21:24
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:21:25
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.models import NoSQLDatabaseConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NoSQLDatabaseView_ManagerList(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_NOSQL_DATABASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_NOSQL_DATABASES):
            messages.error(self.request, "You do not have permission to list NoSQL Data Sources.")
            return context
        ##############################

        context_user = self.request.user

        try:
            c = NoSQLDatabaseConnection.objects.filter(assistant__in=Assistant.objects.filter(
                organization__in=context_user.organizations.all())).select_related('assistant__organization')
            c_by_orgs = {}
            for connection in c:
                orgs = connection.assistant.organization
                agent = connection.assistant
                if orgs not in c_by_orgs:
                    c_by_orgs[orgs] = {}
                if agent not in c_by_orgs[orgs]:
                    c_by_orgs[orgs][agent] = []
                c_by_orgs[orgs][agent].append(connection)
        except Exception as e:
            logger.error(f"User: {context_user} - NoSQL Data Source - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing NoSQL Data Sources.')
            return context

        context['connections_by_organization'] = c_by_orgs
        logger.info(f"NoSQL Database Connections were listed.")
        return context


Contents of ../../apps/datasource_nosql/views/nosql_database/create_nosql_database_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_nosql_database_views.py
#  Last Modified: 2024-10-12 13:21:03
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-12 13:21:03
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.forms import NoSQLDatabaseConnectionForm
from apps.datasource_nosql.utils import NOSQL_DATABASE_CHOICES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NoSQLDatabaseView_ManagerCreate(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            user_orgs = Organization.objects.filter(users__in=[context_user])
            agents = Assistant.objects.filter(organization__in=user_orgs)
            context['dbms_choices'] = NOSQL_DATABASE_CHOICES
            context['form'] = NoSQLDatabaseConnectionForm()
            context['assistants'] = agents
        except Exception as e:
            logger.error(f"User: {context_user} - NoSQL Data Source - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating NoSQL Data Source.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        form = NoSQLDatabaseConnectionForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_NOSQL_DATABASES
        if not UserPermissionManager.is_authorized(
            user=self.request.user, operation=PermissionNames.ADD_NOSQL_DATABASES):
            messages.error(self.request, "You do not have permission to create NoSQL Data Sources.")
            return redirect('datasource_nosql:list')
        ##############################

        if form.is_valid():
            form.save()
            logger.info("NoSQL Data Source created.")
            messages.success(request, "NoSQL Data Source created successfully.")
            return redirect('datasource_nosql:create')
        else:
            logger.error("Error creating NoSQL Data Source.")
            messages.error(request, "Error creating NoSQL Data Source.")
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/ellma/views/ellma_script_manager_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: ellma_script_manager_views.py
#  Last Modified: 2024-10-30 17:39:02
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 17:39:02
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.ellma.models import EllmaScript
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class EllmaScriptView_ManageScripts(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ELLMA_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ELLMA_SCRIPTS):
            messages.error(self.request, "You do not have permission to list eLLMa scripts.")
            return context
        ##############################

        try:
            user_orgs = Organization.objects.filter(users__in=[self.request.user])
            org_scripts = {}
            for org in user_orgs:
                scripts = EllmaScript.objects.filter(organization=org)
                org_scripts[org] = scripts
            context['org_scripts'] = org_scripts
            context["organizations"] = user_orgs
            context['llm_models'] = LLMCore.objects.filter(organization__in=user_orgs)
        except Exception as e:
            messages.error(self.request, f"An error occurred: {str(e)}")
            return context

        return context


Contents of ../../apps/ellma/views/delete_ellma_script_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_ellma_script_views.py
#  Last Modified: 2024-10-30 17:38:52
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 17:38:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.ellma.models import EllmaScript
from apps.user_permissions.utils import PermissionNames


class EllmaScriptView_DeleteScript(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        script_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_ELLMA_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ELLMA_SCRIPTS):
            messages.error(self.request, "You do not have permission to delete eLLMa scripts.")
            return redirect('ellma:manage-scripts')
        ##############################

        try:
            ellma_script = EllmaScript.objects.get(id=script_id)
            ellma_script.delete()
            messages.success(request, "Script deleted successfully.")
        except EllmaScript.DoesNotExist:
            messages.error(request, "Script not found.")

        return redirect('ellma:manage-scripts')


Contents of ../../apps/ellma/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-30 17:36:37
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 17:36:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .create_ellma_script_views import *
from .delete_ellma_script_views import *
from .ellma_script_editor_views import *
from .ellma_script_manager_views import *
from .compile_ellma_script_views import *


Contents of ../../apps/ellma/views/ellma_script_editor_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: ellma_script_editor_views.py
#  Last Modified: 2024-10-30 17:39:14
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 17:39:15
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.ellma.models import EllmaScript
from apps.ellma.utils import ELLMA_TRANSCRIPTION_LANGUAGES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class EllmaScriptView_ScriptEditor(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        script_id = self.kwargs.get('pk')
        context['ellma_script'] = get_object_or_404(EllmaScript, id=script_id)
        context["ELLMA_TRANSCRIPTION_LANGUAGES"] = ELLMA_TRANSCRIPTION_LANGUAGES
        return context

    def post(self, request, *args, **kwargs):
        # Saving the eLLMa script data.
        script_id = self.kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_ELLMA_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_ELLMA_SCRIPTS):
            messages.error(self.request, "You do not have permission to update eLLMa scripts.")
            return redirect('ellma:script-editor', pk=script_id)
        ##############################

        ellma_script = get_object_or_404(EllmaScript, id=script_id)
        script_name = request.POST.get('script_name')
        script_content = request.POST.get('script_content')
        transcription_language = request.POST.get('transcription_language')

        try:
            if not script_name or not transcription_language:
                messages.error(request, "Script name and transcription language are required.")
                return redirect('ellma:script-editor', pk=script_id)

            ellma_script.script_name = script_name
            ellma_script.ellma_script_content = script_content
            ellma_script.ellma_transcription_language = transcription_language
            ellma_script.save()
        except Exception as e:
            messages.error(request, f"Error updating script: {e}")
            return redirect('ellma:script-editor', pk=script_id)

        messages.success(request, "Script updated successfully.")
        return redirect('ellma:script-editor', pk=script_id)


Contents of ../../apps/ellma/views/create_ellma_script_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_ellma_script_views.py
#  Last Modified: 2024-10-30 17:38:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 17:38:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.exceptions import ObjectDoesNotExist
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.ellma.models import EllmaScript
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames


class EllmaScriptView_CreateScript(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_ELLMA_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_ELLMA_SCRIPTS):
            messages.error(self.request, "You do not have permission to create eLLMa scripts.")
            return redirect('ellma:manage-scripts')
        ##############################

        organization_id = request.POST.get('organization')
        llm_model_id = request.POST.get('llm_model')
        script_name = request.POST.get('script_name')
        if not all([organization_id, llm_model_id, script_name]):
            messages.error(request, "Missing required fields.")
            return redirect('ellma:manage-scripts')

        try:
            organization = Organization.objects.get(id=organization_id)
            llm_model = LLMCore.objects.get(id=llm_model_id)
        except ObjectDoesNotExist:
            messages.error(request, "Organization or LLM Model not found.")
            return redirect('ellma:manage-scripts')

        ellma_script = EllmaScript.objects.create(
            organization=organization, llm_model=llm_model, script_name=script_name, created_by_user=request.user
        )
        messages.success(request, f"Script '{ellma_script.script_name}' created successfully.")
        return redirect('ellma:manage-scripts')


Contents of ../../apps/ellma/views/compile_ellma_script_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: compile_ellma_script_views.py
#  Last Modified: 2024-10-30 17:41:13
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 17:41:14
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.exceptions import ObjectDoesNotExist
from django.shortcuts import redirect
from django.views import View

from apps.core.ellma.ellma_execution_manager import EllmaExecutionManager
from apps.core.generative_ai.utils import GPT_DEFAULT_ENCODING_ENGINE, ChatRoles
from apps.core.internal_cost_manager.costs_map import InternalServiceCosts
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.ellma.models import EllmaScript
from apps.llm_transaction.models import LLMTransaction
from apps.llm_transaction.utils import LLMTransactionSourcesTypesNames
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class EllmaScriptView_CompileScript(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        script_id = kwargs.get('pk')
        ellma_transcription_language = request.POST.get('transcription_language')
        ellma_script_content = request.POST.get('script_content')

        script: EllmaScript = EllmaScript.objects.get(id=script_id)
        if not script:
            messages.error(request, "Script not found.")
            logger.error(f"[eLLMa Compilation View] Script not found.")
            return redirect('ellma:manage-scripts')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_ELLMA_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_ELLMA_SCRIPTS):
            messages.error(self.request, "You do not have permission to update eLLMa scripts.")
            return redirect('ellma:script-editor', pk=script_id)
        ##############################

        try:
            # Do not save, since save operation is different
            ellma_script = EllmaScript.objects.get(id=script_id)
            xc = EllmaExecutionManager(script=ellma_script)
            generated_code_output, error = xc.transcribe_via_ai()
            if error:
                logger.error(f"[eLLMa Compilation View] An error occurred during compilation: {error}")
                messages.error(request, f"An error occurred during compilation: {error}")
                return redirect('ellma:script-editor', pk=script_id)
            else:
                print("Generated Code Output: ", generated_code_output)

        except ObjectDoesNotExist:
            messages.error(request, "Script not found.")
            logger.error(f"[eLLMa Compilation View] Script not found.")
            return redirect('ellma:manage-scripts')
        except Exception as e:
            messages.error(request, f"An error occurred during compilation: {str(e)}")
            logger.error(f"[eLLMa Compilation View] An error occurred during compilation: {str(e)}")
            return redirect('ellma:script-editor', pk=script_id)

        # Save the output generation as text
        script.ellma_transcribed_content = generated_code_output
        script.save()
        logger.info(f"[eLLMa Compilation View] Compiled eLLMa Script: {script.script_name}")

        try:
            tx = LLMTransaction(
                organization=script.organization, model=script.llm_model,
                responsible_user=script.created_by_user, responsible_assistant=None,
                encoding_engine=GPT_DEFAULT_ENCODING_ENGINE, llm_cost=InternalServiceCosts.EllmaScripting.COST,
                transaction_type=ChatRoles.SYSTEM,
                transaction_source=LLMTransactionSourcesTypesNames.ELLMA_SCRIPTING, is_tool_cost=True
            )
            tx.save()
            logger.info(f"[eLLMa Compilation View] Created LLMTransaction for eLLMa Scripting Compilation Tool.")
        except Exception as e:
            logger.error(
                f"[eLLMa Compilation View] Error creating LLMTransaction for eLLMa Scripting Compilation Tool. Error: {e}")
            pass

        logger.info(f"[eLLMa Compilation View] Compiled eLLMa Script: {script.script_name}")
        return redirect('ellma:script-editor', pk=script_id)


Contents of ../../apps/slider/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-02 19:21:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 19:21:36
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#




Contents of ../../apps/slider/views/slider_commands/ssh_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: ssh_commands.py
#  Last Modified: 2024-10-15 23:19:20
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:19:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaSSHCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_ssh_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the SSH Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"SSH Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/vect_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: vect_commands.py
#  Last Modified: 2024-10-15 23:19:29
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:19:29
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaVectCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_vect_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Vect Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Vect Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/img_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: gen_commands.py
#  Last Modified: 2024-10-15 23:18:09
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:18:10
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaImgCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_img_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Img Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Img Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/web_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: web_commands.py
#  Last Modified: 2024-10-15 23:18:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:18:49
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaWebCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_web_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Web Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Web Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:17:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .ai_commands_views import *
from .img_commands_views import *
from .sql_commands_views import *
from .ssh_commands_views import *
from .web_commands_views import *
from .nosql_commands_views import *
from .auto_commands_views import *
from .vect_commands_views import *
from .select_commands_views import *


Contents of ../../apps/slider/views/slider_commands/nosql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: nosql_commands.py
#  Last Modified: 2024-10-15 23:19:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:19:06
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaNoSQLCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_nosql_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the NoSQL Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"NoSQL Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/ai_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: ai_commands.py
#  Last Modified: 2024-10-15 23:16:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:16:59
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaAICommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_ai_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the AI Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"AI Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/sql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sql_commands.py
#  Last Modified: 2024-10-15 23:18:57
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:18:57
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaSQLCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_sql_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the SQL Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"SQL Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/repo_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: repo_commands_views.py
#  Last Modified: 2024-10-16 23:32:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-16 23:32:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaRepoCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_repo_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Repo Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Repo Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/auto_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: auto_commands.py
#  Last Modified: 2024-10-15 23:18:00
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:18:01
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaAutoCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_auto_command()
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Auto Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Auto Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/slider_commands/select_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: select_commands.py
#  Last Modified: 2024-10-15 23:17:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-15 23:17:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.slider.slider_executor import SliderExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GenerateViaSelectCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SliderDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            selected_text = request.POST.get('selected_text', "")
            command = request.POST.get('command')
            xc = SliderExecutionManager(slider_document=document)
            response_json = xc.execute_select_command(selected_text=selected_text, command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Select Command: {str(e)}")
            return redirect('slider:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Select Command was executed for Slider Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/folder/slider_folders_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_folders_delete_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:07:13
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderFolder
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SliderView_FolderDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SliderFolder, id=folder_id)
        context['folder'] = folder
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_SLIDER_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SLIDER_FOLDERS):
            messages.error(self.request, "You do not have permission to delete Slider Folders.")
            return redirect('slider:folders_list')
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SliderFolder, id=folder_id)
        folder.delete()
        logger.info(f"Slider Folder was deleted by User: {request.user.id}.")
        return redirect('slider:folders_list')


Contents of ../../apps/slider/views/folder/slider_folders_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_folders_create_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:05:35
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.slider.models import SliderFolder
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_FolderCreate(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_SLIDER_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SLIDER_FOLDERS):
            messages.error(self.request, "You do not have permission to add Slider Folders.")
            return redirect('slider:folders_list')
        ##############################

        organization_id = request.POST.get('organization')
        folder_name = request.POST.get('name')
        description = request.POST.get('description', '')
        meta_context_instructions = request.POST.get('meta_context_instructions', '')

        if organization_id and folder_name:
            organization = Organization.objects.get(id=organization_id)
            SliderFolder.objects.create(
                organization=organization, name=folder_name, description=description,
                meta_context_instructions=meta_context_instructions, created_by_user=request.user
            )
        logger.info(f"Slider Folder was created by User: {request.user.id}.")
        return redirect('slider:folders_list')


Contents of ../../apps/slider/views/folder/slider_folders_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_folders_update_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:05:50
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.slider.models import SliderFolder
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SliderView_FolderUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SliderFolder, id=folder_id)
        organizations = Organization.objects.filter(users__in=[self.request.user])
        context['folder'] = folder
        context['organizations'] = organizations
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_FOLDERS):
            messages.error(self.request, "You do not have permission to update Slider Folders.")
            return redirect('slider:folders_list')
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SliderFolder, id=folder_id)
        folder.name = request.POST.get('name')
        folder.description = request.POST.get('description', '')
        folder.meta_context_instructions = request.POST.get('meta_context_instructions', '')
        organization_id = request.POST.get('organization')
        if organization_id:
            folder.organization_id = organization_id
        folder.save()
        logger.info(f"Slider Folder was updated by User: {request.user.id}.")
        return redirect('slider:folders_list')


Contents of ../../apps/slider/views/folder/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:04:55
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .slider_folders_list_views import *
from .slider_folders_create_views import *
from .slider_folders_delete_views import *
from .slider_folders_update_views import *


Contents of ../../apps/slider/views/folder/slider_folders_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_folders_list_views.py
#  Last Modified: 2024-11-01 05:25:40
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:06:35
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.slider.models import SliderFolder
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SliderView_FolderList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SLIDER_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SLIDER_FOLDERS):
            messages.error(self.request, "You do not have permission to list Slider Folders.")
            return context
        ##############################

        # Get organizations and paginate folders for each
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        org_folders = []
        for org in user_orgs:
            folders = SliderFolder.objects.filter(organization=org)
            paginator = Paginator(folders, 10)
            page_number = self.request.GET.get(f'page_{org.id}', 1)
            page_obj = paginator.get_page(page_number)
            org_folders.append({
                'organization': org,
                'page_obj': page_obj,
            })
        context['org_folders'] = org_folders
        context['organizations'] = user_orgs
        logger.info(f"Slider Folders were listed for User: {self.request.user.id}.")
        return context


Contents of ../../apps/slider/views/document/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:04:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .slider_documents_list_views import *
from .slider_documents_create_views import *
from .slider_documents_delete_views import *
from .slider_documents_save_content_views import *
from .slider_documents_detail_views import *
from .slider_documents_update_views import *


Contents of ../../apps/slider/views/document/slider_documents_detail_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_documents_detail_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:03:21
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SliderView_DocumentDetail(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to list Slider Documents.")
            return context
        ##############################

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        document_id = self.kwargs.get('document_id')
        document = SliderDocument.objects.get(id=document_id)
        context['document'] = document
        context['folder'] = document.document_folder
        content = document.document_content_json_quill
        context['content'] = content
        logger.info(f"Slider Document {document.document_title} was viewed.")
        return context


Contents of ../../apps/slider/views/document/slider_documents_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_documents_create_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:00:22
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderFolder, SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_DocumentCreate(LoginRequiredMixin, View):

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - ADD_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to add Slider Documents.")
            return redirect('slider:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SliderFolder, id=folder_id)
        document = SliderDocument.objects.create(
            organization=folder.organization,
            document_folder=folder,
            document_title=request.POST.get('document_title'),
            copilot_assistant_id=request.POST.get('copilot_assistant'),
            context_instructions=request.POST.get('context_instructions', ''),
            target_audience=request.POST.get('target_audience', ''),
            tone=request.POST.get('tone', ''),
            created_by_user=request.user,
            last_updated_by_user=request.user
        )
        logger.info(f"Slider Document {document.document_title} was created.")
        return redirect('slider:documents_detail', folder_id=folder.id, document_id=document.id)


Contents of ../../apps/slider/views/document/slider_documents_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_documents_delete_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:03:57
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_DocumentDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to delete Slider Documents.")
            return redirect('slider:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        document = get_object_or_404(SliderDocument, id=document_id)
        document.delete()
        logger.info(f"Slider Document {document.document_title} was deleted.")
        return redirect('slider:documents_list', folder_id=folder_id)


Contents of ../../apps/slider/views/document/slider_documents_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_documents_list_views.py
#  Last Modified: 2024-11-01 05:25:40
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:02:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderFolder, SliderDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SliderView_DocumentList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to list Slider Documents.")
            return context
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SliderFolder, id=folder_id)
        documents = SliderDocument.objects.filter(document_folder=folder)
        assistants = Assistant.objects.filter(organization=folder.organization)
        paginator = Paginator(documents, 10)
        page = self.request.GET.get('page')

        try:
            documents = paginator.page(page)
        except PageNotAnInteger:
            documents = paginator.page(1)
        except EmptyPage:
            documents = paginator.page(paginator.num_pages)

        context['folder'] = folder
        context['documents'] = documents
        context['assistants'] = assistants
        logger.info(f"Slider Documents in Folder {folder.name} were listed.")
        return context


Contents of ../../apps/slider/views/document/slider_documents_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_documents_update_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:01:26
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderFolder, SliderDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SliderView_DocumentUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        folder = get_object_or_404(SliderFolder, id=folder_id)
        document = get_object_or_404(SliderDocument, id=document_id, document_folder=folder)
        available_folders = SliderFolder.objects.filter(organization=folder.organization)
        assistants = Assistant.objects.filter(organization=folder.organization)
        context['folder'] = folder
        context['document'] = document
        context['available_folders'] = available_folders
        context['assistants'] = assistants
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        folder = get_object_or_404(SliderFolder, id=folder_id)
        document = get_object_or_404(SliderDocument, id=document_id, document_folder=folder)
        document.document_title = request.POST.get('document_title')
        document.copilot_assistant_id = request.POST.get('copilot_assistant')
        document.document_folder_id = request.POST.get('document_folder')
        document.context_instructions = request.POST.get('context_instructions', '')
        document.target_audience = request.POST.get('target_audience', '')
        document.tone = request.POST.get('tone', '')
        document.last_updated_by_user = request.user
        document.save()
        logger.info(f"Slider Document {document.document_title} was updated.")
        return redirect('slider:documents_list', folder_id=folder_id)


Contents of ../../apps/slider/views/document/slider_documents_save_content_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: slider_documents_save_content_views.py
#  Last Modified: 2024-11-02 20:02:04
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:02:15
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_SaveContent(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Slider Documents.")
            return redirect('slider:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        document = get_object_or_404(SliderDocument, id=document_id)
        document_content = request.POST.get('draft_text')
        if document_content:
            document.document_content_json_quill = document_content
            document.save()
        logger.info(f"Slider Document {document.document_title} was updated.")
        return redirect('slider:documents_detail', folder_id=folder_id, document_id=document_id)


Contents of ../../apps/slider/views/public/public_repo_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_repo_commands_views.py
#  Last Modified: 2024-10-31 03:06:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaRepoCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Repo Command is required.")
            return JsonResponse({"output": None, "message": "Repo Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_repo_command(command=command)
        logger.info(f"Repo Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/public_select_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_select_commands_views.py
#  Last Modified: 2024-10-31 03:06:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:58
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaSelectCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        selected_text = request.POST.get('selected_text', "")
        if selected_text is None:
            logger.error(f"Selected Text is required.")
            return JsonResponse({"output": None, "message": "Selected Text is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        command = request.POST.get('command')
        if command is None:
            logger.error(f"Select Command is required.")
            return JsonResponse({"output": None, "message": "Select Command is required."})

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_select_command(selected_text=selected_text, command=command)
        logger.info(f"Select Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/public_auto_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_auto_commands_views.py
#  Last Modified: 2024-10-31 03:06:10
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:10
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaAutoCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_auto_command()
        logger.info(f"Auto Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/public_sql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_sql_commands_views.py
#  Last Modified: 2024-10-31 03:07:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaSQLCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"SQL Command is required.")
            return JsonResponse({"output": None, "message": "SQL Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_sql_command(command=command)
        logger.info(f"SQL Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 03:04:50
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:04:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .public_img_commands_views import *
from .public_sql_commands_views import *
from .public_ssh_commands_views import *
from .public_web_commands_views import *
from .public_ai_command_views import *
from .public_repo_commands_views import *
from .public_vect_commands_views import *
from .public_auto_commands_views import *
from .public_nosql_commands_views import *
from .public_select_commands_views import *


Contents of ../../apps/slider/views/public/public_web_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_web_commands_views.py
#  Last Modified: 2024-10-31 03:07:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaWebCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Web Command is required.")
            return JsonResponse({"output": None, "message": "Web Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_web_command(command=command)
        logger.info(f"Web Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/public_ai_command_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_ai_command_views.py
#  Last Modified: 2024-10-31 03:05:30
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:05:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaAICommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"AI Command is required.")
            return JsonResponse({"output": None, "message": "AI Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_ai_command(command=command)
        logger.info(f"AI Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/public_nosql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_nosql_commands_views.py
#  Last Modified: 2024-10-31 03:06:43
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaNoSQLCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"NoSQL Command is required.")
            return JsonResponse({"output": None, "message": "NoSQL Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_nosql_command(command=command)
        logger.info(f"NoSQL Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/public_img_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_img_commands_views.py
#  Last Modified: 2024-10-31 03:06:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:06:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaImgCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Img Command is required.")
            return JsonResponse({"output": None, "message": "Img Command is required for image generation."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_img_command(command=command)
        logger.info(f"Img Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/public_ssh_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_ssh_commands_views.py
#  Last Modified: 2024-10-31 03:07:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaSSHCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"SSH Command is required.")
            return JsonResponse({"output": None, "message": "SSH Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_ssh_command(command=command)
        logger.info(f"SSH Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/public/public_vect_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_vect_commands_views.py
#  Last Modified: 2024-10-31 03:07:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:07:27
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.slider.slider_executor_public import SliderExecutionManager_Public
from apps.slider.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SliderView_PublicGenerateViaVectCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Vect Command is required.")
            return JsonResponse({"output": None, "message": "Vect Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SliderExecutionManager_Public(slider_google_apps_connection=connection_object,
                                           text_content=text_content)
        response_json = xc.execute_vect_command(command=command)
        logger.info(f"Vect Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/slider/views/google_apps_connection/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 05:36:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:08:15
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .google_apps_connection_list_views import *
from .google_apps_connection_create_views import *
from .google_apps_connection_delete_views import *
from .google_apps_connection_update_views import *


Contents of ../../apps/slider/views/google_apps_connection/google_apps_connection_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_create_views.py
#  Last Modified: 2024-10-31 03:23:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:23:17
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderGoogleAppsConnection
from apps.slider.utils import generate_google_apps_connection_api_key
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SliderView_GoogleAppsConnectionCreate(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_SLIDER_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SLIDER_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to add Slider Google Apps Connections.")
            return redirect('slider:google_apps_connections_list')
        ##############################

        assistant_id = request.POST.get('assistant')
        if not assistant_id:
            messages.error(request, "Assistant field is required.")
            return redirect('slider:google_apps_connections_list')

        assistant = get_object_or_404(Assistant, id=assistant_id)

        try:
            connection, created = SliderGoogleAppsConnection.objects.get_or_create(
                owner_user=request.user, slider_assistant=assistant,
                defaults={'connection_api_key': generate_google_apps_connection_api_key()}
            )

            if not created:
                messages.warning(request, "A connection for this model already exists. Please renew if necessary.")
            else:
                messages.success(request, "Connection successfully created.")
        except Exception as e:
            messages.error(request, f"An error occurred while creating the connection: {str(e)}")
            logger.error(f"An error occurred while creating the connection: {str(e)}")
            return redirect('slider:google_apps_connections_list')

        logger.info(f"Google Apps Connection was created for Assistant: {assistant.id}.")
        return redirect('slider:google_apps_connections_list')


Contents of ../../apps/slider/views/google_apps_connection/google_apps_connection_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_delete_views.py
#  Last Modified: 2024-10-31 03:23:40
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 03:23:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderGoogleAppsConnection
from apps.user_permissions.utils import PermissionNames


class SliderView_GoogleAppsConnectionDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_SLIDER_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SLIDER_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete Slider Google Apps Connections.")
            return redirect('slider:google_apps_connections_list')
        ##############################

        connection = get_object_or_404(SliderGoogleAppsConnection, id=connection_id, owner_user=request.user)

        try:
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection.")
            return redirect('slider:google_apps_connections_list')

        messages.success(request, "Connection successfully deleted.")
        return redirect('slider:google_apps_connections_list')


Contents of ../../apps/slider/views/google_apps_connection/google_apps_connection_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_list_views.py
#  Last Modified: 2024-11-02 19:40:34
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:09:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.slider.models import SliderGoogleAppsConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class SliderView_GoogleAppsConnectionList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SLIDER_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SLIDER_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to list Slider Google Apps Connections.")
            return context
        ##############################

        context['connections'] = SliderGoogleAppsConnection.objects.filter(owner_user=self.request.user)
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['assistants'] = Assistant.objects.filter(organization__in=user_orgs)
        return context


Contents of ../../apps/slider/views/google_apps_connection/google_apps_connection_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_update_views.py
#  Last Modified: 2024-11-02 19:40:34
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-02 20:10:05
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.slider.models import SliderGoogleAppsConnection
from apps.slider.utils import generate_google_apps_connection_api_key
from apps.user_permissions.utils import PermissionNames


class SliderView_GoogleAppsConnectionUpdate(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('pk')
        assistant_id = request.POST.get('assistant')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SLIDER_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SLIDER_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to update Slider Google Apps Connections.")
            return redirect('slider:google_apps_connections_list')
        ##############################

        try:
            connection = get_object_or_404(SliderGoogleAppsConnection, id=connection_id, owner_user=request.user)
            connection.connection_api_key = generate_google_apps_connection_api_key()
            new_assistant = Assistant.objects.get(id=assistant_id)
            connection.slider_assistant = new_assistant
            connection.save()
        except Exception as e:
            messages.error(request, "An error occurred while updating the API key.")
            return redirect('slider:google_apps_connections_list')

        messages.success(request, "API key successfully updated.")
        return redirect('slider:google_apps_connections_list')


Contents of ../../apps/starred_messages/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_starred_messages_views import *
from .delete_starred_messages_views import *


Contents of ../../apps/starred_messages/views/delete_starred_messages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_starred_messages_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.starred_messages.models import StarredMessage
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class StarredMessageView_Delete(LoginRequiredMixin, DeleteView):
    model = StarredMessage
    success_url = 'starred_messages:list'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        context_user = request.user
        starred_message = get_object_or_404(StarredMessage, id=self.kwargs['pk'])

        ##############################
        # PERMISSION CHECK FOR - REMOVE_STARRED_MESSAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_STARRED_MESSAGES):
            messages.error(self.request, "You do not have permission to remove starred messages.")
            return redirect('starred_messages:list')
        ##############################

        try:
            starred_message.delete()
            success_message = "Starred message deleted successfully."
            starred_message.chat_message.starred = False
            starred_message.chat_message.save()
        except Exception as e:
            logger.error(f"An error occurred while deleting the starred message: {str(e)}")
            messages.error(request, f"An error occurred while deleting the starred message: {str(e)}")
            return redirect('starred_messages:list')

        messages.success(request, success_message)
        logger.info(f"Starred message was deleted by User: {context_user.id}.")
        return redirect(self.success_url)


Contents of ../../apps/starred_messages/views/list_starred_messages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_starred_messages_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.starred_messages.models import StarredMessage
from apps.user_permissions.utils import PermissionNames
from config.settings import MEDIA_URL
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class StarredMessageView_List(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_STARRED_MESSAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_STARRED_MESSAGES):
            messages.error(self.request, "You do not have permission to view starred messages.")
            return context
        ##############################

        user = self.request.user
        starred_msgs = StarredMessage.objects.filter(user=user).select_related('chat_message', 'assistant',
                                                                                   'organization', 'chat')
        org_agents_msgs = {}
        for msg in starred_msgs:
            org_name = msg.organization.name
            agent_name = msg.assistant.name
            if org_name not in org_agents_msgs:
                org_agents_msgs[org_name] = {}
            if agent_name not in org_agents_msgs[org_name]:
                org_agents_msgs[org_name][agent_name] = []
            org_agents_msgs[org_name][agent_name].append(msg)
        context.update({'org_assistants_messages': org_agents_msgs, 'base_url': MEDIA_URL})
        logger.info(f"Starred messages list was viewed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/audit_logs/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-11 05:32:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-11 05:32:36
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


Contents of ../../apps/sheetos/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 18:32:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:21:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .public import *
from .sheetos_commands import *
from .google_apps_connection import *
from .folder import *
from .document import *


Contents of ../../apps/sheetos/views/folder/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 19:21:23
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:21:24
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .sheetos_folder_list_views import *
from .sheetos_folder_create_views import *
from .sheetos_folder_delete_views import *
from .sheetos_folder_update_views import *


Contents of ../../apps/sheetos/views/folder/sheetos_folder_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_folder_update_views.py
#  Last Modified: 2024-10-31 19:24:58
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:24:58
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.sheetos.models import SheetosFolder
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SheetosView_FolderUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SheetosFolder, id=folder_id)
        organizations = Organization.objects.filter(users__in=[self.request.user])
        context['folder'] = folder
        context['organizations'] = organizations
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_FOLDERS):
            messages.error(self.request, "You do not have permission to update Sheetos Folders.")
            return redirect('sheetos:folders_list')
        ##############################

        folder_id = self.kwargs['folder_id']

        try:
            folder = get_object_or_404(SheetosFolder, id=folder_id)
            folder.name = request.POST.get('name')
            folder.description = request.POST.get('description', '')
            folder.meta_context_instructions = request.POST.get('meta_context_instructions', '')
            organization_id = request.POST.get('organization')
            if organization_id:
                folder.organization_id = organization_id
            folder.save()
        except Exception as e:
            messages.error(request, f"An error occurred while updating the Sheetos Folder: {str(e)}")
            return redirect('sheetos:folders_list')

        logger.info(f"Sheetos Folder was updated by User: {request.user.id}.")
        return redirect('sheetos:folders_list')


Contents of ../../apps/sheetos/views/folder/sheetos_folder_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_folder_list_views.py
#  Last Modified: 2024-10-31 19:25:07
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:25:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.sheetos.models import SheetosFolder
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SheetosView_FolderList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SHEETOS_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SHEETOS_FOLDERS):
            messages.error(self.request, "You do not have permission to list Sheetos Folders.")
            return context
        ##############################

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        org_folders = []
        for org in user_orgs:
            folders = SheetosFolder.objects.filter(organization=org)
            paginator = Paginator(folders, 10)
            page = self.request.GET.get(f'page_{org.id}')
            try:
                folders = paginator.page(page)
            except PageNotAnInteger:
                folders = paginator.page(1)
            except EmptyPage:
                folders = paginator.page(paginator.num_pages)
            org_folders.append({
                'organization': org,
                'folders': folders,
                'paginator': paginator,
                'page_obj': folders,
            })

        context['org_folders'] = org_folders
        context['organizations'] = user_orgs
        logger.info(f"Sheetos Folders were listed for User: {self.request.user.id}.")
        return context


Contents of ../../apps/sheetos/views/folder/sheetos_folder_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_folder_delete_views.py
#  Last Modified: 2024-10-31 19:25:14
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:25:15
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosFolder
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SheetosView_FolderDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SheetosFolder, id=folder_id)
        context['folder'] = folder
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_SHEETOS_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SHEETOS_FOLDERS):
            messages.error(self.request, "You do not have permission to delete Sheetos Folders.")
            return redirect('sheetos:folders_list')
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SheetosFolder, id=folder_id)

        try:
            folder.delete()
        except Exception as e:
            messages.error(request, f"An error occurred while deleting the Sheetos Folder: {str(e)}")
            return redirect('sheetos:folders_list')

        logger.info(f"Sheetos Folder was deleted by User: {request.user.id}.")
        return redirect('sheetos:folders_list')


Contents of ../../apps/sheetos/views/folder/sheetos_folder_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_folder_create_views.py
#  Last Modified: 2024-10-31 19:24:50
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:24:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.sheetos.models import SheetosFolder
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_FolderCreate(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_SHEETOS_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SHEETOS_FOLDERS):
            messages.error(self.request, "You do not have permission to add Sheetos Folders.")
            return redirect('sheetos:folders_list')
        ##############################

        organization_id = request.POST.get('organization')
        folder_name = request.POST.get('name')
        description = request.POST.get('description', '')
        meta_context_instructions = request.POST.get('meta_context_instructions', '')

        try:
            if organization_id and folder_name:
                organization = Organization.objects.get(id=organization_id)
                SheetosFolder.objects.create(
                    organization=organization, name=folder_name, description=description,
                    meta_context_instructions=meta_context_instructions, created_by_user=request.user
                )
        except Exception as e:
            messages.error(request, f"An error occurred while creating the Sheetos Folder: {str(e)}")
            return redirect('sheetos:folders_list')

        logger.info(f"Sheetos Folder was created by User: {request.user.id}.")
        return redirect('sheetos:folders_list')


Contents of ../../apps/sheetos/views/document/sheetos_document_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_document_delete_views.py
#  Last Modified: 2024-10-31 19:23:43
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:23:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_DocumentDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to delete Sheetos Documents.")
            return redirect('sheetos:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        print("test")
        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        document = get_object_or_404(SheetosDocument, id=document_id)

        try:
            document.delete()
        except Exception as e:
            messages.error(request, f"An error occurred while deleting the Sheetos Document: {str(e)}")
            return redirect('sheetos:documents_list', folder_id=folder_id)

        logger.info(f"Sheetos Document {document.document_title} was deleted.")
        return redirect('sheetos:documents_list', folder_id=folder_id)


Contents of ../../apps/sheetos/views/document/sheetos_document_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_document_create_views.py
#  Last Modified: 2024-10-31 19:23:21
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:30:13
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosFolder, SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_DocumentCreate(LoginRequiredMixin, View):

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to add Sheetos Documents.")
            return redirect('sheetos:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SheetosFolder, id=folder_id)

        try:
            document = SheetosDocument.objects.create(
                organization=folder.organization,
                document_folder=folder,
                document_title=request.POST.get('document_title'),
                copilot_assistant_id=request.POST.get('copilot_assistant'),
                context_instructions=request.POST.get('context_instructions', ''),
                target_audience=request.POST.get('target_audience', ''),
                tone=request.POST.get('tone', ''),
                created_by_user=request.user,
                last_updated_by_user=request.user
            )
        except Exception as e:
            messages.error(request, f"An error occurred while creating the Sheetos Document: {str(e)}")
            return redirect('sheetos:documents_list', folder_id=folder.id)

        logger.info(f"Sheetos Document {document.document_title} was created.")
        return redirect('sheetos:documents_detail', folder_id=folder.id, document_id=document.id)


Contents of ../../apps/sheetos/views/document/sheetos_document_detail_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_document_detail_views.py
#  Last Modified: 2024-10-31 19:23:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:23:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SheetosView_DocumentDetail(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to list Sheetos Documents.")
            return context
        ##############################

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        document_id = self.kwargs.get('document_id')
        document = SheetosDocument.objects.get(id=document_id)
        context['document'] = document
        context['folder'] = document.document_folder
        content = document.document_content_json_quill
        context['content'] = content
        logger.info(f"Sheetos Document {document.document_title} was viewed.")
        return context


Contents of ../../apps/sheetos/views/document/sheetos_document_save_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_document_save_views.py
#  Last Modified: 2024-10-31 19:24:15
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:24:15
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_SaveContent(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        document = get_object_or_404(SheetosDocument, id=document_id)
        document_content = request.POST.get('draft_text')

        try:
            if document_content:
                document.document_content_json_quill = document_content
                document.save()
        except Exception as e:
            messages.error(request, f"An error occurred while saving the Sheetos Document: {str(e)}")
            return redirect('sheetos:documents_detail', folder_id=folder_id, document_id=document_id)

        logger.info(f"Sheetos Document {document.document_title} was updated.")
        return redirect('sheetos:documents_detail', folder_id=folder_id, document_id=document_id)


Contents of ../../apps/sheetos/views/document/sheetos_document_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_document_update_views.py
#  Last Modified: 2024-10-31 19:23:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:23:36
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosFolder, SheetosDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SheetosView_DocumentUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        folder = get_object_or_404(SheetosFolder, id=folder_id)
        document = get_object_or_404(SheetosDocument, id=document_id, document_folder=folder)
        available_folders = SheetosFolder.objects.filter(organization=folder.organization)
        assistants = Assistant.objects.filter(organization=folder.organization)
        context['folder'] = folder
        context['document'] = document
        context['available_folders'] = available_folders
        context['assistants'] = assistants
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_list', folder_id=self.kwargs['folder_id'])
        ##############################

        folder_id = self.kwargs['folder_id']
        document_id = self.kwargs['document_id']
        folder = get_object_or_404(SheetosFolder, id=folder_id)

        try:
            document = get_object_or_404(SheetosDocument, id=document_id, document_folder=folder)
            document.document_title = request.POST.get('document_title')
            document.copilot_assistant_id = request.POST.get('copilot_assistant')
            document.document_folder_id = request.POST.get('document_folder')
            document.context_instructions = request.POST.get('context_instructions', '')
            document.target_audience = request.POST.get('target_audience', '')
            document.tone = request.POST.get('tone', '')
            document.last_updated_by_user = request.user
            document.save()
        except Exception as e:
            messages.error(request, f"An error occurred while updating the Sheetos Document: {str(e)}")
            return redirect('sheetos:documents_list', folder_id=folder_id)

        logger.info(f"Sheetos Document {document.document_title} was updated.")
        return redirect('sheetos:documents_list', folder_id=folder_id)


Contents of ../../apps/sheetos/views/document/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 19:21:18
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:21:18
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .sheetos_document_list_views import *
from .sheetos_document_save_views import *
from .sheetos_document_create_views import *
from .sheetos_document_delete_views import *
from .sheetos_document_update_views import *
from .sheetos_document_detail_views import *


Contents of ../../apps/sheetos/views/document/sheetos_document_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sheetos_document_list_views.py
#  Last Modified: 2024-10-31 19:23:28
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:23:28
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosFolder, SheetosDocument
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SheetosView_DocumentList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to list Sheetos Documents.")
            return context
        ##############################

        folder_id = self.kwargs['folder_id']
        folder = get_object_or_404(SheetosFolder, id=folder_id)
        documents = SheetosDocument.objects.filter(document_folder=folder)
        assistants = Assistant.objects.filter(organization=folder.organization)
        paginator = Paginator(documents, 10)
        page = self.request.GET.get('page')
        try:
            documents = paginator.page(page)
        except PageNotAnInteger:
            documents = paginator.page(1)
        except EmptyPage:
            documents = paginator.page(paginator.num_pages)
        context['folder'] = folder
        context['documents'] = documents
        context['assistants'] = assistants
        logger.info(f"Sheetos Documents in Folder {folder.name} were listed.")
        return context


Contents of ../../apps/sheetos/views/sheetos_commands/ssh_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: ssh_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaSSHCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_ssh_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the SSH Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"SSH Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/sheetos_commands/vect_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: vect_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaVectCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_vect_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Vect Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Vect Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/sheetos_commands/web_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: web_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaWebCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_web_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Web Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Web Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/sheetos_commands/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 19:21:42
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:21:42
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .ai_commands_views import *
from .sql_commands_views import *
from .ssh_commands_views import *
from .web_commands_views import *
from .auto_commands_views import *
from .repo_commands_views import *
from .vect_commands_views import *
from .nosql_commands_views import *
from .select_commands_views import *


Contents of ../../apps/sheetos/views/sheetos_commands/nosql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: nosql_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaNoSQLCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_nosql_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the NoSQL Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"NoSQL Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/sheetos_commands/ai_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: ai_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:25
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaAICommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_ai_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the AI Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"AI Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/sheetos_commands/sql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sql_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaSQLCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_sql_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the SQL Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"SQL Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/sheetos_commands/repo_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: repo_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaRepoCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            command = request.POST.get('command')
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_repo_command(command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Repo Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Repo Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/sheetos_commands/auto_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: auto_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:28
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaAutoCommand(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_auto_command()
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Auto Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Auto Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/sheetos_commands/select_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: select_commands_views.py
#  Last Modified: 2024-10-17 16:15:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:27:35
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.sheetos.sheetos_executor import SheetosExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GenerateViaSelectCommand(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        document_id = request.POST.get('document_id')
        document = get_object_or_404(SheetosDocument, pk=document_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to update Sheetos Documents.")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)
        ##############################

        try:
            selected_data = request.POST.get('selected_text', "")
            command = request.POST.get('command')
            xc = SheetosExecutionManager(sheetos_document=document)
            response_json = xc.execute_select_command(selected_data=selected_data, command=command)
        except Exception as e:
            messages.error(request, f"An error occurred while executing the Select Command: {str(e)}")
            return redirect('sheetos:documents_detail',
                            folder_id=document.document_folder.id, document_id=document_id)

        logger.info(f"Select Command was executed for Sheetos Document: {document.id}.")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/public_repo_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_repo_commands_views.py
#  Last Modified: 2024-10-31 05:36:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:29:02
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaRepoCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Repo Command is required.")
            return JsonResponse({"output": None, "message": "Repo Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_repo_command(command=command)
        logger.info(f"Repo Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/public_select_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_select_commands_views.py
#  Last Modified: 2024-10-31 16:49:33
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:29:04
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaSelectCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        selected_data = request.POST.get('selected_text', "")
        if selected_data is None:
            logger.error(f"Selected Text is required.")
            return JsonResponse({"output": None, "message": "Selected Text is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        command = request.POST.get('command')
        if command is None:
            logger.error(f"Select Command is required.")
            return JsonResponse({"output": None, "message": "Select Command is required."})

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_select_command(selected_data=selected_data, command=command)
        logger.info(f"Select Command was executed for Google Apps Connection: {connection_object}")
        print("response_json: ", response_json)
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/public_auto_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_auto_commands_views.py
#  Last Modified: 2024-10-31 16:49:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:28:56
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaAutoCommand(View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_auto_command()
        logger.info(f"Auto Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/public_sql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_sql_commands_views.py
#  Last Modified: 2024-10-31 05:36:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:29:06
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaSQLCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"SQL Command is required.")
            return JsonResponse({"output": None, "message": "SQL Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_sql_command(command=command)
        logger.info(f"SQL Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 19:21:37
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:21:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#




Contents of ../../apps/sheetos/views/public/public_web_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_web_commands_views.py
#  Last Modified: 2024-10-31 05:36:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:29:12
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaWebCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Web Command is required.")
            return JsonResponse({"output": None, "message": "Web Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_web_command(command=command)
        logger.info(f"Web Command was executed for Google Apps Connection: {connection_object}")
        print("response_json: ", response_json)
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/public_ai_command_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_ai_command_views.py
#  Last Modified: 2024-10-31 05:36:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:28:54
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaAICommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        print("command: ", command)
        if command is None:
            logger.error(f"AI Command is required.")
            return JsonResponse({"output": None, "message": "AI Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_ai_command(command=command)
        logger.info(f"AI Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/public_nosql_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_nosql_commands_views.py
#  Last Modified: 2024-10-31 05:36:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:29:00
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaNoSQLCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"NoSQL Command is required.")
            return JsonResponse({"output": None, "message": "NoSQL Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_nosql_command(command=command)
        logger.info(f"NoSQL Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/public_ssh_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_ssh_commands_views.py
#  Last Modified: 2024-10-31 05:36:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:29:08
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaSSHCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"SSH Command is required.")
            return JsonResponse({"output": None, "message": "SSH Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_ssh_command(command=command)
        logger.info(f"SSH Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/public/public_vect_commands_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: public_vect_commands_views.py
#  Last Modified: 2024-10-31 05:36:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:29:10
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.sheetos.sheetos_executor_public import SheetosExecutionManager_Public
from apps.sheetos.utils import is_valid_google_apps_authentication_key

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class SheetosView_PublicGenerateViaVectCommand(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        command = request.POST.get('command')
        if command is None:
            logger.error(f"Vect Command is required.")
            return JsonResponse({"output": None, "message": "Vect Command is required."})

        text_content = request.POST.get('text_content')
        if text_content is None:
            logger.error(f"Text Content is None, assuming empty string.")
            text_content = ""

        # auth key check
        authentication_key = request.POST.get('authentication_key')
        if authentication_key is None:
            logger.error(f"Google Apps Authentication Key is required.")
            return JsonResponse({"output": None, "message": "Google Apps Authentication Key is required."})

        connection_object = is_valid_google_apps_authentication_key(authentication_key=authentication_key)
        if not connection_object:
            logger.error(f"Invalid Google Apps Authentication Key.")
            return JsonResponse({"output": None, "message": "Invalid Google Apps Authentication Key."})

        xc = SheetosExecutionManager_Public(sheetos_google_apps_connection=connection_object,
                                            text_content=text_content)
        response_json = xc.execute_vect_command(command=command)
        logger.info(f"Vect Command was executed for Google Apps Connection: {connection_object}")
        return JsonResponse(response_json)


Contents of ../../apps/sheetos/views/google_apps_connection/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-31 19:21:29
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:21:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .google_apps_connection_list_views import *
from .google_apps_connection_update_views import *
from .google_apps_connection_delete_views import *
from .google_apps_connection_create_views import *


Contents of ../../apps/sheetos/views/google_apps_connection/google_apps_connection_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_create_views.py
#  Last Modified: 2024-10-31 19:25:44
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:25:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosGoogleAppsConnection
from apps.sheetos.utils import generate_google_apps_connection_api_key
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SheetosView_GoogleAppsConnectionCreate(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_SHEETOS_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SHEETOS_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to add Sheetos Google Apps Connections.")
            return redirect('sheetos:google_apps_connections_list')
        ##############################

        assistant_id = request.POST.get('assistant')
        if not assistant_id:
            messages.error(request, "Assistant field is required.")
            return redirect('sheetos:google_apps_connections_list')

        assistant = get_object_or_404(Assistant, id=assistant_id)

        try:
            connection, created = SheetosGoogleAppsConnection.objects.get_or_create(
                owner_user=request.user, sheetos_assistant=assistant,
                defaults={'connection_api_key': generate_google_apps_connection_api_key()}
            )

            if not created:
                messages.warning(request, "A connection for this model already exists. Please renew if necessary.")
            else:
                messages.success(request, "Connection successfully created.")
        except Exception as e:
            logger.error(f"An error occurred while creating the Sheetos Google Apps Connection: {str(e)}")
            messages.error(request, f"An error occurred while creating the Sheetos Google Apps Connection: {str(e)}")
            return redirect('sheetos:google_apps_connections_list')

        logger.info(f"Sheetos Google Apps Connection was created by User: {request.user.id}.")
        return redirect('sheetos:google_apps_connections_list')


Contents of ../../apps/sheetos/views/google_apps_connection/google_apps_connection_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_delete_views.py
#  Last Modified: 2024-10-31 19:26:12
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:26:13
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosGoogleAppsConnection
from apps.user_permissions.utils import PermissionNames


class SheetosView_GoogleAppsConnectionDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_SHEETOS_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SHEETOS_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete Sheetos Google Apps Connections.")
            return redirect('sheetos:google_apps_connections_list')
        ##############################

        connection = get_object_or_404(SheetosGoogleAppsConnection, id=connection_id, owner_user=request.user)

        try:
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection.")
            return redirect('sheetos:google_apps_connections_list')

        messages.success(request, "Connection successfully deleted.")
        return redirect('sheetos:google_apps_connections_list')




Contents of ../../apps/sheetos/views/google_apps_connection/google_apps_connection_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_list_views.py
#  Last Modified: 2024-10-31 19:25:54
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:25:55
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.sheetos.models import SheetosGoogleAppsConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class SheetosView_GoogleAppsConnectionList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SHEETOS_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SHEETOS_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to list Sheetos Google Apps Connections.")
            return context
        ##############################

        context['connections'] = SheetosGoogleAppsConnection.objects.filter(owner_user=self.request.user)
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['assistants'] = Assistant.objects.filter(organization__in=user_orgs)
        return context


Contents of ../../apps/sheetos/views/google_apps_connection/google_apps_connection_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: google_apps_connection_update_views.py
#  Last Modified: 2024-10-31 19:26:02
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 19:26:02
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosGoogleAppsConnection
from apps.sheetos.utils import generate_google_apps_connection_api_key
from apps.user_permissions.utils import PermissionNames


class SheetosView_GoogleAppsConnectionUpdate(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('pk')
        assistant_id = request.POST.get('assistant')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SHEETOS_GOOGLE_APPS_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SHEETOS_GOOGLE_APPS_CONNECTIONS):
            messages.error(self.request, "You do not have permission to update Sheetos Google Apps Connections.")
            return redirect('sheetos:google_apps_connections_list')
        ##############################

        try:
            connection = get_object_or_404(SheetosGoogleAppsConnection, id=connection_id, owner_user=request.user)
            connection.connection_api_key = generate_google_apps_connection_api_key()
            new_assistant = Assistant.objects.get(id=assistant_id)
            connection.sheetos_assistant = new_assistant
            connection.save()
        except Exception as e:
            messages.error(request, "An error occurred while updating the API key.")
            return redirect('sheetos:google_apps_connections_list')

        messages.success(request, "API key successfully updated.")
        return redirect('sheetos:google_apps_connections_list')



Contents of ../../apps/finetuning/views/add_finetuning_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: add_finetuning_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.finetuning.forms import FineTunedModelConnectionForm
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class FineTuningView_Add(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = FineTunedModelConnectionForm()
        return context

    def post(self, request, *args, **kwargs):
        context_user = request.user

        ##############################
        # PERMISSION CHECK FOR - ADD_FINETUNING_MODEL
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_FINETUNING_MODEL):
            messages.error(self.request, "You do not have permission to add Finetuning Model.")
            return redirect('finetuning:list')
        ##############################

        form = FineTunedModelConnectionForm(request.POST)
        if form.is_valid():
            connection = form.save(commit=False)
            connection.created_by_user = request.user
            connection.save()
        logger.info(f"FineTuning Model was added by User: {context_user.id}.")
        return redirect('finetuning:list')


Contents of ../../apps/finetuning/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .add_finetuning_views import *
from .list_finetunings_views import *
from .delete_finetuning_views import *


Contents of ../../apps/finetuning/views/delete_finetuning_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_finetuning_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.finetuning.models import FineTunedModelConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class FineTuningView_Delete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['connection'] = get_object_or_404(FineTunedModelConnection, id=kwargs['pk'],
                                                  created_by_user=self.request.user)
        return context

    def post(self, request, *args, **kwargs):
        context_user = request.user

        ##############################
        # PERMISSION CHECK FOR - DELETE_FINETUNING_MODEL
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_FINETUNING_MODEL):
            messages.error(self.request, "You do not have permission to delete Finetuning Model.")
            return redirect('finetuning:list')
        ##############################

        c = get_object_or_404(FineTunedModelConnection, id=kwargs['pk'], created_by_user=request.user)

        try:
            c.delete()
        except Exception as e:
            logger.error(f"Error deleting FineTunedModelConnection: {e}")
            messages.error(request, "Error deleting FineTunedModelConnection.")
            return redirect('finetuning:list')

        logger.info(f"FineTuning Model was deleted by User: {context_user.id}.")
        return redirect('finetuning:list')


Contents of ../../apps/finetuning/views/list_finetunings_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_finetunings_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.finetuning.forms import FineTunedModelConnectionForm
from apps.finetuning.models import FineTunedModelConnection
from apps.finetuning.utils import FineTuningModelProvidersNames, FineTunedModelTypesNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class FineTuningView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_FINETUNING_MODEL
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_FINETUNING_MODEL):
            messages.error(self.request, "You do not have permission to list Finetuning Model.")
            return context
        ##############################

        try:
            orgs = Organization.objects.filter(users__in=[self.request.user])
            data = []
            for organization in orgs:
                cs = FineTunedModelConnection.objects.filter(organization=organization,
                                                             created_by_user=self.request.user)
                data.append({'organization': organization, 'connections': cs})
        except Exception as e:
            logger.error(f"Error listing FineTunedModelConnection: {e}")
            messages.error(self.request, "Error listing FineTunedModelConnection.")
            return context

        context['data'] = data
        context['form'] = FineTunedModelConnectionForm()
        context['organizations'] = orgs
        context['providers'] = FineTuningModelProvidersNames.as_list()
        context['model_types'] = FineTunedModelTypesNames.as_list()
        logger.info(f"Fine-tuning Models were listed by User: {self.request.user.id}.")
        return context

    def post(self, request, *args, **kwargs):
        form = FineTunedModelConnectionForm(request.POST)
        if form.is_valid():
            c = form.save(commit=False)
            c.created_by_user = request.user
            c.save()
            return redirect('finetuning:list')
        context = self.get_context_data(**kwargs)
        context['form'] = form
        logger.error(f"Finetuning Model was not added by User: {request.user.id}.")
        return self.render_to_response(context)


Contents of ../../apps/export_leanmods/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .export_leanmods import *
from .endpoints import *


Contents of ../../apps/export_leanmods/views/endpoints/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .endpoint_export_leanmod_views import *


Contents of ../../apps/export_leanmods/views/endpoints/endpoint_export_leanmod_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: endpoint_export_leanmod_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import json
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
from apps.export_leanmods.models import ExportLeanmodAssistantAPI, LeanmodRequestLog
from apps.export_leanmods.utils import LeanModAssistantStatusCodes
from apps.multimodal_chat.models import MultimodalLeanChat, MultimodalLeanChatMessage
from apps.multimodal_chat.utils import generate_chat_name, SourcesForMultimodalChatsNames
from config.settings import BASE_URL


logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class ExportLeanmodAssistantAPIHealthCheckView(View):
    def post(self, request, *args, **kwargs):
        endpoint = (BASE_URL + request.path).replace("health", "app")
        api_key = request.headers.get('Authorization')
        try:
            export_assistant = ExportLeanmodAssistantAPI.objects.get(endpoint=endpoint)
        except ExportLeanmodAssistantAPI.DoesNotExist:
            logger.error(f"Invalid LeanMod endpoint: {endpoint}")
            return JsonResponse({
                "message": "Invalid LeanMod endpoint", "data": {}, "status": LeanModAssistantStatusCodes.NOT_FOUND
            }, status=LeanModAssistantStatusCodes.NOT_FOUND)

        if not export_assistant.is_online:
            logger.error(f"The LeanMod  is currently offline: {endpoint}")
            return JsonResponse({
                "message": "The LeanMod endpoint is currently offline. Please try again later.", "data": {},
                "status": LeanModAssistantStatusCodes.SERVICE_OFFLINE
            }, status=LeanModAssistantStatusCodes.SERVICE_OFFLINE)

        if (not export_assistant.is_public) and export_assistant.custom_api_key != api_key:
            logger.error(f"Invalid LeanMod API key provided for endpoint: {endpoint}")
            return JsonResponse({
                "message": "The LeanMod API key provided is invalid, please provide a valid API key.", "data": {},
                "status": LeanModAssistantStatusCodes.UNAUTHORIZED
            }, status=LeanModAssistantStatusCodes.UNAUTHORIZED)

        return JsonResponse({
                "message": "The LeanMod endpoint is online and healthy.", "data": {},
                "status": LeanModAssistantStatusCodes.OK
            }, status=LeanModAssistantStatusCodes.OK
        )


@method_decorator(csrf_exempt, name='dispatch')
class ExportLeanmodAssistantAPIView(View):
    def post(self, request, *args, **kwargs):
        endpoint = BASE_URL + request.path
        api_key = request.headers.get('Authorization')
        try:
            exp_agent = ExportLeanmodAssistantAPI.objects.get(endpoint=endpoint)
        except ExportLeanmodAssistantAPI.DoesNotExist:
            logger.error(f"Invalid LeanMod endpoint: {endpoint}")
            return JsonResponse({
                "message": "Invalid LeanMod endpoint", "data": {}, "status": LeanModAssistantStatusCodes.NOT_FOUND
            }, status=LeanModAssistantStatusCodes.NOT_FOUND)

        if not exp_agent.is_online:
            logger.error(f"The LeanMod endpoint is currently offline: {endpoint}")
            return JsonResponse({
                "message": "The LeanMod endpoint is currently offline. Please try again later.", "data": {},
                "status": LeanModAssistantStatusCodes.SERVICE_OFFLINE
            }, status=LeanModAssistantStatusCodes.SERVICE_OFFLINE)

        if (not exp_agent.is_public) and exp_agent.custom_api_key != api_key:
            logger.error(f"Invalid LeanMod API key provided for endpoint: {endpoint}")
            return JsonResponse({
                "message": "The LeanMod API key provided is invalid, please provide a valid API key.", "data": {},
                "status": LeanModAssistantStatusCodes.UNAUTHORIZED
            }, status=LeanModAssistantStatusCodes.UNAUTHORIZED)

        LeanmodRequestLog.objects.create(export_lean_assistant=exp_agent)
        if exp_agent.requests_in_last_hour() > exp_agent.request_limit_per_hour:
            logger.error(f"The API request limit has been reached for endpoint: {endpoint}")
            return JsonResponse({
                "error": "The API request limit has been reached. Please try again later.",
                "data": {
                    "request_limit_per_hour": exp_agent.request_limit_per_hour,
                    "requests_in_last_hour": exp_agent.requests_in_last_hour()
                }, }, status=LeanModAssistantStatusCodes.TOO_MANY_REQUESTS)

        body = json.loads(request.body)
        try:
            chat_history = body.get('chat_history')
            if len(chat_history) == 0:
                logger.error("Chat history is empty.")
                raise ValueError("Chat history is empty.")

            api_chat = MultimodalLeanChat.objects.create(
                organization=exp_agent.lean_assistant.organization,
                lean_assistant=exp_agent.lean_assistant,
                user=exp_agent.created_by_user,
                chat_name=generate_chat_name(),
                created_by_user=exp_agent.created_by_user,
                chat_source=SourcesForMultimodalChatsNames.API
            )

            user_message = None
            for message in chat_history:
                role = message["role"]
                content = message["content"]
                file_uris = []
                image_uris = []
                if "file_uris" in message and message["file_uris"] != "":
                    file_uris = message.get("file_uris", "").split(",") if message.get("file_uris") else []
                if "image_uris" in message and message["image_uris"] != "":
                    image_uris = message.get("image_uris", "").split(",") if message.get("image_uris") else []

                file_uris = [uri.strip() for uri in file_uris if uri.strip()] if file_uris else []
                image_uris = [uri.strip() for uri in image_uris if uri.strip()]

                api_chat.lean_chat_messages.create(
                    multimodal_lean_chat=api_chat, sender_type=role.upper(),
                    message_text_content=content, message_file_contents=file_uris,
                    message_image_contents=image_uris
                )
                user_message = api_chat.lean_chat_messages.filter(sender_type=role.upper()).last()

        except Exception as e:
            logger.error(f"Invalid chat history provided: {str(e)}")
            return JsonResponse({
                "message": "Internal server error: " + str(e),
                "data": {}, "status": LeanModAssistantStatusCodes.INTERNAL_SERVER_ERROR
            }, status=LeanModAssistantStatusCodes.INTERNAL_SERVER_ERROR)

        try:
            llm_client = GenerativeAIDecodeController.get_lean(
                assistant=exp_agent.lean_assistant,
                multimodal_chat=api_chat
            )
            llm_response_text, file_uris, image_uris = llm_client.respond(
                latest_message=user_message, with_media=True
            )
            MultimodalLeanChatMessage.objects.create(
                multimodal_lean_chat=api_chat, sender_type='ASSISTANT', message_text_content=llm_response_text
            )
        except Exception as e:
            logger.error(f"Error generating response for endpoint: {endpoint}")
            return JsonResponse({
                "message": "Internal server error: " + str(e), "data": {},
                "status": LeanModAssistantStatusCodes.INTERNAL_SERVER_ERROR
            }, status=LeanModAssistantStatusCodes.INTERNAL_SERVER_ERROR)

        response_data = {
            "message": "Success", "data": {
                "metadata": {
                    "organization": {"organization_name": exp_agent.lean_assistant.organization.name},
                    "assistant": {"assistant_name": exp_agent.lean_assistant.name},
                    "chat": {"chat_name": api_chat.chat_name}
                },
                "message": {
                    "assistant_name": exp_agent.lean_assistant.name,
                    "content": llm_response_text,
                    "role": "assistant",
                    "media": {"files": file_uris, "images": image_uris}
                }
            }
        }
        logger.info(f"Leanmod Assistant API response generated for endpoint: {endpoint}")
        return JsonResponse(response_data, status=LeanModAssistantStatusCodes.OK)



Contents of ../../apps/export_leanmods/views/export_leanmods/delete_export_leanmod_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_export_leanmod_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_leanmods.models import ExportLeanmodAssistantAPI
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExportLeanModView_Delete(LoginRequiredMixin, DeleteView):
    model = ExportLeanmodAssistantAPI
    success_url = 'export_leanmods:list'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_EXPORT_LEANMOD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_EXPORT_LEANMOD):
            messages.error(self.request, "You do not have permission to delete Export LeanMod Assistant APIs.")
            return redirect('export_leanmods:list')
        ##############################

        exp_leanmod = get_object_or_404(ExportLeanmodAssistantAPI, id=self.kwargs['pk'])
        exp_leanmod.delete()
        success_message = "Export LeanMod Assistant deleted successfully."
        org = exp_leanmod.lean_assistant.organization
        org.exported_leanmods.remove(exp_leanmod)
        org.save()
        logger.info(f"Export LeanMod Assistant was deleted by User: {request.user.id}.")
        messages.success(request, success_message)
        return redirect(self.success_url)


Contents of ../../apps/export_leanmods/views/export_leanmods/toggle_service_export_leanmods_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: toggle_service_export_leanmods_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import importlib
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_leanmods.management.commands.start_exported_leanmods import start_endpoint_for_leanmod
from apps.export_leanmods.models import ExportLeanmodAssistantAPI
from apps.user_permissions.utils import PermissionNames
from config import settings
from config.settings import EXPORT_LEANMOD_API_BASE_URL

logger = logging.getLogger(__name__)


class ExportLeanModView_ToggleService(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_EXPORT_LEANMOD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_EXPORT_LEANMOD):
            messages.error(self.request, "You do not have permission to update Export LeanMod Assistant APIs.")
            return redirect('export_leanmods:list')
        ##############################

        try:
            exp_agent = get_object_or_404(ExportLeanmodAssistantAPI, pk=self.kwargs['pk'])
            endpoint = EXPORT_LEANMOD_API_BASE_URL + exp_agent.endpoint.split(EXPORT_LEANMOD_API_BASE_URL)[1]
            api_urls = getattr(importlib.import_module(settings.ROOT_URLCONF), 'urlpatterns')
            exp_agent.is_online = not exp_agent.is_online
            exp_agent.save()
            if exp_agent.is_online:
                if not any(endpoint in str(url) for url in api_urls):
                    start_endpoint_for_leanmod(exp_agent)
        except Exception as e:
            logger.error(f"Error toggling Export LeanMod Assistant: {e}")
            messages.error(request, "Error toggling Export LeanMod Assistant.")
            return redirect('export_leanmods:list')

        logger.info(f"Export LeanMod Assistant was toggled by User: {request.user.id}.")
        return redirect('export_leanmods:list')

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)


Contents of ../../apps/export_leanmods/views/export_leanmods/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_export_leanmods_views import *
from .create_export_leanmod_views import *
from .delete_export_leanmod_views import *
from .update_export_leanmod_views import *
from .toggle_service_export_leanmods_views import *


Contents of ../../apps/export_leanmods/views/export_leanmods/list_export_leanmods_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_export_leanmods_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_leanmods.models import ExportLeanmodAssistantAPI
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from config import settings
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ExportLeanModView_List(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_EXPORT_LEANMOD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_EXPORT_LEANMOD):
            messages.error(self.request, "You do not have permission to list Export LeanMod Assistant APIs.")
            return context
        ##############################

        user_context = self.request.user
        max_exp_leanmods = settings.MAX_LEANMODS_EXPORTS_ORGANIZATION

        try:
            org_data = []
            orgs = Organization.objects.filter(users=user_context)
            for org in orgs:
                exp_leanmods_count = org.exported_leanmods.count()
                agents_pct = round((exp_leanmods_count / max_exp_leanmods) * 100, 2)
                exp_agents = org.exported_leanmods.all()
                for agent in exp_agents:
                    agent.usage_percentage = 100
                org_data.append({
                    'organization': org, 'export_assistants_count': exp_leanmods_count,
                    'assistants_percentage': agents_pct, 'export_assistants': exp_agents, 'limit': max_exp_leanmods})
            exp_agents = ExportLeanmodAssistantAPI.objects.filter(created_by_user=user_context)
            context["user"] = user_context
            context["organization_data"] = org_data
            context["export_assistants"] = exp_agents
        except Exception as e:
            messages.error(self.request, f"An error occurred: {str(e)}")
            return context

        logger.info(f"User: {user_context.id} listed Export LeanMod Assistant APIs.")
        return context


Contents of ../../apps/export_leanmods/views/export_leanmods/create_export_leanmod_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_export_leanmod_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_leanmods.management.commands.start_exported_leanmods import start_endpoint_for_leanmod
from apps.export_leanmods.models import ExportLeanmodAssistantAPI
from apps.leanmod.models import LeanAssistant
from apps.user_permissions.utils import PermissionNames
from config.settings import MAX_LEANMODS_EXPORTS_ORGANIZATION
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExportLeanModView_Create(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_context = self.request.user
        agents = LeanAssistant.objects.filter(organization__users=user_context)
        context["user"] = user_context
        context["assistants"] = agents
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_EXPORT_LEANMOD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_EXPORT_LEANMOD):
            messages.error(self.request, "You do not have permission to add Export LeanMod Assistant APIs.")
            return redirect('export_leanmods:list')
        ##############################

        agent_id = request.POST.get('assistant')
        agent = get_object_or_404(LeanAssistant, pk=agent_id)
        is_public = request.POST.get('is_public') == 'on'
        req_limit_hourly = request.POST.get('request_limit_per_hour')
        if ExportLeanmodAssistantAPI.objects.filter(
            created_by_user=request.user).count() > MAX_LEANMODS_EXPORTS_ORGANIZATION:
            logger.error(f"User: {request.user.id} tried to create more than {MAX_LEANMODS_EXPORTS_ORGANIZATION} "
                         f"Export LeanMod Assistant APIs.")
            messages.error(request, f"Maximum number of Export LeanMod Assistant APIs reached for the organization.")
            return self.render_to_response(self.get_context_data())

        if not agent_id or not req_limit_hourly:
            logger.error(f"User: {request.user.id} tried to create Export LeanMod Assistant API without required fields.")
            messages.error(request, "LeanMod Assistant ID and Request Limit Per Hour are required.")
            return self.render_to_response(self.get_context_data())
        try:
            new_exp_leanmod = ExportLeanmodAssistantAPI.objects.create(
                lean_assistant_id=agent_id, is_public=is_public, request_limit_per_hour=req_limit_hourly,
                created_by_user=request.user)

            org = agent.organization
            if not org.exported_leanmods:
                org.exported_leanmods.set([new_exp_leanmod])
            else:
                org.exported_leanmods.add(new_exp_leanmod)
            org.save()
            start_endpoint_for_leanmod(assistant=new_exp_leanmod)
            logger.info(f"Export LeanMod Assistant API was created by User: {request.user.id}.")
            messages.success(request, "Export LeanMod Assistant API created successfully!")
            return redirect("export_leanmods:list")
        except Exception as e:
            logger.error(f"Error creating Export LeanMod Assistant API by User: {request.user.id}.")
            messages.error(request, f"Error creating Export LeanMod Assistant API: {str(e)}")
            return self.render_to_response(self.get_context_data())


Contents of ../../apps/export_leanmods/views/export_leanmods/update_export_leanmod_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_export_leanmod_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_leanmods.models import ExportLeanmodAssistantAPI
from apps.leanmod.models import LeanAssistant
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExportLeanModView_Update(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        exp_agent = get_object_or_404(ExportLeanmodAssistantAPI, pk=self.kwargs['pk'])
        context['export_assistant'] = exp_agent
        context['assistants'] = LeanAssistant.objects.filter(organization__users__in=[self.request.user])
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_EXPORT_LEANMOD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_EXPORT_LEANMOD):
            messages.error(self.request, "You do not have permission to update Export LeanMod Assistant APIs.")
            return redirect('export_leanmods:list')
        ##############################

        exp_agent = get_object_or_404(ExportLeanmodAssistantAPI, pk=self.kwargs['pk'])
        exp_agent: ExportLeanmodAssistantAPI
        exp_agent.lean_assistant_id = request.POST.get('assistant')
        exp_agent.request_limit_per_hour = request.POST.get('request_limit_per_hour')
        exp_agent.is_public = request.POST.get('is_public') == 'on'
        if exp_agent.lean_assistant_id and exp_agent.request_limit_per_hour:
            exp_agent.save()
            logger.info(f"Export LeanMod Assistant was updated by User: {request.user.id}.")
            messages.success(request, "Export LeanMod Assistant updated successfully.")
            return redirect('export_leanmods:list')
        else:
            logger.error(f"Export LeanMod Assistant was not updated by User: {request.user.id}.")
            messages.error(request, "There was an error updating the LeanMod Export Assistant.")
        context = self.get_context_data()
        context.update({
                'export_assistant': exp_agent,
                'assistants': LeanAssistant.objects.filter(organization__users__in=[self.request.user]).all()
            })
        return render(request, self.template_name, context)


Contents of ../../apps/hadron_prime/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-17 21:41:52
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 21:41:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .node import *
from .topic import *
from .system import *
from .endpoints import *
from .log_node_sase import *
from .log_topic_message import *
from .log_node_publish_history import *
from .log_node_execution_history import *
from .log_node_speech_history import *
from .connect_assistant import *


Contents of ../../apps/hadron_prime/views/endpoints/speak_with_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: speak_with_system_views.py
#  Last Modified: 2024-10-22 13:56:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 13:56:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import json
import logging

from django.contrib import messages
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.hadron_prime.hadron_prime_executor import HadronPrimeExecutor
from apps.hadron_prime.models import HadronNode

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class HadronPrimeView_SpeakWithHadronNode(View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        try:
            api_key = request.headers.get('Authorization', None)
            if not api_key:
                return JsonResponse({
                    "success": False,
                    "error": "API key is missing from the request. Make sure to provide the HTTP header 'Authorization' with the API key.",
                    "data": {}
                })
            if "Bearer" in api_key:
                api_key = (api_key.replace("Bearer ", "").replace("bearer ", "").replace("BEARER ", "")
                           .replace("Bearer", "").replace("bearer", "").replace("BEARER", ""))
                logger.info("Format of the API key is fixed to remove Bearer prefix.")
            else:
                logger.info("API key format is already correct, no fix applied.")

            node = get_object_or_404(HadronNode, id=kwargs['pk'])
            if api_key != node.activation_trigger_authentication_key:
                return JsonResponse({
                    "success": False,
                    "error": "Invalid API key provided.",
                    "data": {}
                })

            try:
                request_body = json.loads(request.body.decode('utf-8'))
            except Exception as e:
                return JsonResponse({
                    "success": False,
                    "error": f"Error parsing request body: {str(e)}",
                    "data": {}
                })

            user_query_text = request_body.get('user_query_text', None)
            if not user_query_text or user_query_text == "":
                return JsonResponse({
                    "success": False,
                    "error": "User query text is missing from the request.",
                    "data": {}
                })

            xc = HadronPrimeExecutor(node=node, execution_log_object=None)
            response_text, success, error = xc.generate_node_speech(user_query_text=user_query_text)
            if error:
                logger.error(f"Error occurred while generating speech for the Hadron Node: {error}")
                return JsonResponse({
                    "success": False,
                    "error": error,
                    "data": {}
                })

            logger.info(f"Hadron Node speech generation completed with status: {success}")
            return JsonResponse({
                "success": success,
                "error": error,
                "data": {
                    "response": response_text
                }
            })

        except Exception as e:
            return JsonResponse({
                "success": False,
                "error": f"Internal Server Error: {str(e)}",
                "data": {}
            })


class HadronPrimeView_SpeakWithHadronNodeViaForm(View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        node_id = request.POST.get('node_id', None)
        id_token = request.POST.get('id_token', None)
        try:
            api_key = request.POST.get('api_key', None)
            if not api_key:
                messages.error(request, "API key is missing from the request. Make sure to provide the API key.")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)

            node = get_object_or_404(HadronNode, id=node_id)

            if id_token != node.activation_trigger_hashed_param:
                messages.error(request, "Invalid ID token provided.")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)
            if api_key != node.activation_trigger_authentication_key:
                messages.error(request, "Invalid API key provided.")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)

            user_query_text = request.POST.get('user_query_text', None)
            if not user_query_text or user_query_text == "":
                messages.error(request, "User query text is missing from the request.")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)

            xc = HadronPrimeExecutor(node=node, execution_log_object=None)
            _, success, error = xc.generate_node_speech(user_query_text=user_query_text)
            if error:
                logger.error(f"Error occurred while generating speech for the Hadron Node: {error}")
                messages.error(request, f"Error occurred while generating speech for the Hadron Node: {error}")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)

            logger.info(f"Hadron Node speech generation completed with status: {success}")
            messages.success(request, "Hadron Node speech generation completed successfully.")
            return redirect('hadron_prime:detail_hadron_node', pk=node_id)

        except Exception as e:
            messages.error(request, f"Internal Server Error: {str(e)}")
            return redirect('hadron_prime:detail_hadron_node', pk=node_id)


Contents of ../../apps/hadron_prime/views/endpoints/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-17 22:52:42
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:52:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .trigger_activate_hadron_node_views import *
from .speak_with_node_views import *


Contents of ../../apps/hadron_prime/views/endpoints/trigger_activate_hadron_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: trigger_activate_hadron_node_views.py
#  Last Modified: 2024-10-17 22:54:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:54:19
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.http import JsonResponse
from django.shortcuts import get_object_or_404, redirect
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.hadron_prime.hadron_prime_executor import HadronPrimeExecutor
from apps.core.hadron_prime.utils import NodeExecutionProcessLogTexts
from apps.hadron_prime.models import HadronNode, HadronNodeExecutionLog
from apps.hadron_prime.utils import HadronNodeExecutionStatusesNames

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class HadronPrimeView_TriggerActiveHadronNode(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        try:
            api_key = request.headers.get('Authorization', None)
            if not api_key:
                return JsonResponse({"success": False, "error": "API key is missing from the request. Make sure to "
                                                                "provide the HTTP header 'Authorization' with the "
                                                                "API key."})
            if "Bearer" in api_key:
                api_key = (api_key.replace("Bearer ", "").replace("bearer ", "").replace("BEARER ", "")
                           .replace("Bearer", "").replace("bearer", "").replace("BEARER", ""))
                logger.info("Format of the API key is fixed to remove Bearer prefix.")
            else:
                logger.info("API key format is already correct, no fix applied.")

            node = get_object_or_404(HadronNode, id=kwargs['pk'])
            if api_key != node.activation_trigger_authentication_key:
                return JsonResponse({"success": False, "error": "Invalid API key provided."})

            xc_log = HadronNodeExecutionLog.objects.create(
                node=node, execution_log=None, execution_status=HadronNodeExecutionStatusesNames.PENDING,
                created_at=timezone.now())
            xc_log.save()
            xc_log.execution_log = ""
            xc_log.execution_log += NodeExecutionProcessLogTexts.system_initialized(node=node)
            xc_log.execution_log += NodeExecutionProcessLogTexts.topics_initialized(node=node)
            xc_log.execution_log += NodeExecutionProcessLogTexts.node_initialized(node=node)
            node.execution_logs.add(xc_log)
            node.save()

            xc = HadronPrimeExecutor(node=node, execution_log_object=xc_log)
            success, error = xc.execute_hadron_node()
            if error:
                logger.error(f"Error occurred while executing the Hadron Node: {error}")
                xc_log.execution_status = HadronNodeExecutionStatusesNames.FAILED
                xc_log.execution_log += NodeExecutionProcessLogTexts.process_failed(error_log=error)
                xc_log.save()
                return JsonResponse({"success": False, "error": error})

            logger.info(f"Hadron Node execution completed with status: {success}")
            return JsonResponse({"success": success, "error": error})

        except Exception as e:
            return JsonResponse({"success": False, "error": f"Internal Server Error: {str(e)}"})


class HadronPrimeView_TriggerActiveHadronNodeViaForm(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        node_id = request.POST.get('node_id', None)
        id_token = request.POST.get('id_token', None)
        try:
            api_key = request.POST.get('api_key', None)
            if not api_key:
                messages.error(request, "API key is missing from the request. Make sure to provide the API key.")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)

            node = get_object_or_404(HadronNode, id=node_id)

            if id_token != node.activation_trigger_hashed_param:
                messages.error(request, "Invalid ID token provided.")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)
            if api_key != node.activation_trigger_authentication_key:
                messages.error(request, "Invalid API key provided.")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)

            xc_log = HadronNodeExecutionLog.objects.create(
                node=node, execution_log=None, execution_status=HadronNodeExecutionStatusesNames.PENDING,
                created_at=timezone.now())
            xc_log.save()
            xc_log.execution_log = ""
            xc_log.execution_log += NodeExecutionProcessLogTexts.system_initialized(node=node)
            xc_log.execution_log += NodeExecutionProcessLogTexts.topics_initialized(node=node)
            xc_log.execution_log += NodeExecutionProcessLogTexts.node_initialized(node=node)
            node.execution_logs.add(xc_log)
            node.save()

            xc = HadronPrimeExecutor(node=node, execution_log_object=xc_log)
            success, error = xc.execute_hadron_node()
            if error:
                logger.error(f"Error occurred while executing the Hadron Node: {error}")
                xc_log.execution_status = HadronNodeExecutionStatusesNames.FAILED
                xc_log.execution_log += NodeExecutionProcessLogTexts.process_failed(error_log=error)
                xc_log.save()
                messages.error(request, f"Error occurred while executing the Hadron Node: {error}")
                return redirect('hadron_prime:detail_hadron_node', pk=node_id)

            logger.info(f"Hadron Node execution completed with status: {success}")
            messages.success(request, "Hadron Node execution completed successfully.")
            return redirect('hadron_prime:detail_hadron_node', pk=node_id)

        except Exception as e:
            messages.error(request, f"Internal Server Error: {str(e)}")
            return redirect('hadron_prime:detail_hadron_node', pk=node_id)


Contents of ../../apps/hadron_prime/views/log_node_sase/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-18 22:51:39
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 22:51:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .delete_all_sase_logs_for_node_views import *


Contents of ../../apps/hadron_prime/views/log_node_sase/delete_all_sase_logs_for_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_sase_logs_for_node_views.py
#  Last Modified: 2024-10-18 22:52:18
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 22:52:19
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode, HadronStateErrorActionStateErrorLog
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class HadronPrimeView_DeleteAllNodeSASELogs(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        node_id = kwargs.get('pk')
        node = HadronNode.objects.get(id=node_id)
        hadron_sase_logs = HadronStateErrorActionStateErrorLog.objects.filter(node=node)

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_NODE_SASE_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_NODE_SASE_LOGS):
            messages.error(self.request, "You do not have permission to delete hadron node SEASE logs.")
            return redirect('hadron_prime:detail_hadron_node', pk=node_id)
        ##############################

        try:
            for hadron_sase_log in hadron_sase_logs:
                hadron_sase_log.delete()
            logger.info(f"All hadron SEASE logs associated with the node have been deleted.")
            messages.success(request, "All hadron SEASE logs associated with the node have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron SEASE logs for node: {e}")
            messages.error(request, f"Error deleting hadron SEASE logs for node: {e}")
        return redirect('hadron_prime:detail_hadron_node', pk=node_id)


Contents of ../../apps/hadron_prime/views/log_node_publish_history/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-18 22:52:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 22:52:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .delete_all_publish_history_logs_for_node_views import *


Contents of ../../apps/hadron_prime/views/log_node_publish_history/delete_all_publish_history_logs_for_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_publish_history_logs_for_node_views.py
#  Last Modified: 2024-10-18 22:52:57
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 22:52:57
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode, HadronTopicMessage
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class HadronPrimeView_DeleteAllNodePublishHistoryLogs(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        node_id = kwargs.get('pk')
        sender_node = HadronNode.objects.get(id=node_id)
        hadron_publish_history_logs = HadronTopicMessage.objects.filter(sender_node=sender_node)

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_NODE_PUBLISH_HISTORY_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_NODE_PUBLISH_HISTORY_LOGS):
            messages.error(self.request, "You do not have permission to delete hadron node publish history nodes.")
            return redirect('hadron_prime:detail_hadron_node', pk=node_id)
        ##############################

        try:
            for hadron_publish_history_log in hadron_publish_history_logs:
                hadron_publish_history_log.delete()
            logger.info(f"All hadron publish history logs associated with the node have been deleted.")
            messages.success(request, "All hadron publish history logs associated with the node have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron publish history logs for node: {e}")
            messages.error(request, f"Error deleting hadron publish history logs for node: {e}")
        return redirect('hadron_prime:detail_hadron_node', pk=node_id)


Contents of ../../apps/hadron_prime/views/topic/delete_hadron_topics_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_hadron_topics_views.py
#  Last Modified: 2024-10-17 22:50:34
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:50:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronTopic
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_DeleteHadronTopic(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        topic_id = kwargs.get('pk')
        hadron_topic = get_object_or_404(HadronTopic, id=topic_id)
        context['hadron_topic'] = hadron_topic
        return context

    def post(self, request, *args, **kwargs):
        topic_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_TOPICS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_TOPICS):
            messages.error(self.request, "You do not have permission to delete Hadron Topics.")
            return redirect('hadron_prime:list_hadron_system')
        ##############################

        hadron_topic = get_object_or_404(HadronTopic, id=topic_id)

        try:
            hadron_topic.delete()
        except Exception as e:
            logger.error(f"Error deleting Hadron Topic: {e}")
            messages.error(request, f"Error deleting Hadron Topic: {e}")
            return redirect('hadron_prime:detail_hadron_topic', pk=topic_id)

        logger.info(f'Hadron Topic "{hadron_topic.topic_name}" has been deleted successfully.')
        messages.success(request, f'Hadron Topic "{hadron_topic.topic_name}" has been deleted successfully.')
        return redirect('hadron_prime:list_hadron_system')


Contents of ../../apps/hadron_prime/views/topic/create_hadron_topic_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_hadron_topic_views.py
#  Last Modified: 2024-10-17 22:50:07
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:50:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem, HadronTopic
from apps.hadron_prime.utils import HADRON_TOPIC_CATEGORIES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_CreateHadronTopic(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        systems = HadronSystem.objects.filter(organization__in=user_orgs)

        context['organizations'] = user_orgs
        context['systems'] = systems
        context['topic_categories'] = HADRON_TOPIC_CATEGORIES
        return context

    def post(self, request, *args, **kwargs):
        system_id = request.POST.get('system')

        ##############################
        # PERMISSION CHECK FOR - CREATE_HADRON_TOPICS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_HADRON_TOPICS):
            messages.error(self.request, "You do not have permission to create Hadron Topics.")
            return redirect('hadron_prime:list_hadron_system')
        ##############################

        topic_name = request.POST.get('topic_name')
        topic_description = request.POST.get('topic_description')
        topic_purpose = request.POST.get('topic_purpose')
        topic_category = request.POST.get('topic_category')

        if not system_id or not topic_name or not topic_category:
            logger.error('The required fields are not filled out.')
            messages.error(request, 'Please fill out all required fields.')
            return redirect('hadron_prime:create_hadron_topic')

        try:
            system = HadronSystem.objects.get(id=system_id)
            HadronTopic.objects.create(
                system=system, topic_name=topic_name, topic_description=topic_description,
                topic_purpose=topic_purpose, topic_category=topic_category, created_by_user=request.user)
        except Exception as e:
            logger.error(f"Error creating Hadron Topic: {e}")
            messages.error(request, f"Error creating Hadron Topic: {e}")
            return redirect('hadron_prime:create_hadron_topic')

        logger.info(f'Hadron Topic "{topic_name}" created.')
        messages.success(request, f'Hadron Topic "{topic_name}" created successfully.')
        return redirect('hadron_prime:list_hadron_system')


Contents of ../../apps/hadron_prime/views/topic/update_hadron_topic_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_hadron_topic_views.py
#  Last Modified: 2024-10-17 22:50:20
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:50:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem, HadronTopic
from apps.hadron_prime.utils import HADRON_TOPIC_CATEGORIES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_UpdateHadronTopic(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        topic_id = kwargs.get('pk')
        hadron_topic = get_object_or_404(HadronTopic, id=topic_id)

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        systems = HadronSystem.objects.filter(organization__in=user_orgs)

        context['hadron_topic'] = hadron_topic
        context['systems'] = systems
        context['topic_categories'] = HADRON_TOPIC_CATEGORIES
        return context

    def post(self, request, *args, **kwargs):
        topic_id = kwargs.get('pk')
        hadron_topic = get_object_or_404(HadronTopic, id=topic_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_HADRON_TOPICS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_HADRON_TOPICS):
            messages.error(self.request, "You do not have permission to update Hadron Topics.")
            return redirect('hadron_prime:list_hadron_system')
        ##############################

        system_id = request.POST.get('system')
        topic_name = request.POST.get('topic_name')
        topic_description = request.POST.get('topic_description')
        topic_purpose = request.POST.get('topic_purpose')
        if not system_id or not topic_name:
            logger.error('The required fields are not filled out.')
            messages.error(request, 'Please fill out all required fields.')
            return redirect('hadron_prime:update_hadron_topic', pk=topic_id)

        try:
            system = HadronSystem.objects.get(id=system_id)
            hadron_topic.system = system
            hadron_topic.topic_name = topic_name
            hadron_topic.topic_description = topic_description
            hadron_topic.topic_purpose = topic_purpose
            hadron_topic.save()
        except Exception as e:
            logger.error(f"Error updating Hadron Topic: {e}")
            messages.error(request, f"Error updating Hadron Topic: {e}")
            return redirect('hadron_prime:update_hadron_topic', pk=topic_id)

        logger.info(f'Hadron Topic "{hadron_topic.topic_name}" updated.')
        messages.success(request, f'Hadron Topic "{hadron_topic.topic_name}" updated successfully.')
        return redirect('hadron_prime:detail_hadron_topic', pk=topic_id)


Contents of ../../apps/hadron_prime/views/topic/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-17 22:50:12
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:50:12
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .create_hadron_topic_views import *
from .update_hadron_topic_views import *
from .delete_hadron_topics_views import *
from .detail_hadron_topic_views import *


Contents of ../../apps/hadron_prime/views/topic/detail_hadron_topic_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_hadron_topic_views.py
#  Last Modified: 2024-10-18 00:17:11
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 00:17:12
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronTopic, HadronTopicMessage
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class HadronPrimeView_DetailHadronTopic(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        topic_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - LIST_HADRON_TOPICS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_HADRON_TOPICS):
            messages.error(self.request, "You do not have permission to list Hadron Topics.")
            return context
        ##############################

        hadron_topic = get_object_or_404(HadronTopic, id=topic_id)
        messages_list = HadronTopicMessage.objects.filter(topic=hadron_topic).order_by('-created_at')
        paginator = Paginator(messages_list, 10)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['hadron_topic'] = hadron_topic
        context['page_obj'] = page_obj
        return context


Contents of ../../apps/hadron_prime/views/log_topic_message/delete_all_topic_message_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_topic_message_logs_views.py
#  Last Modified: 2024-10-18 22:53:24
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 22:53:25
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronTopic, HadronTopicMessage
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class HadronPrimeView_DeleteAllTopicMessages(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        topic_id = kwargs.get('pk')
        topic = HadronTopic.objects.get(id=topic_id)
        hadron_topic_messages = HadronTopicMessage.objects.filter(topic=topic)

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_TOPIC_MESSAGE_HISTORY_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_TOPIC_MESSAGE_HISTORY_LOGS):
            messages.error(self.request, "You do not have permission to delete hadron topic message history logs.")
            return redirect('hadron_prime:detail_hadron_topic', pk=topic_id)
        ##############################

        try:
            for hadron_topic_message in hadron_topic_messages:
                hadron_topic_message.delete()
            logger.info(f"All hadron message history associated with the topic have been deleted.")
            messages.success(request, "All hadron message history associated with the topic have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron message history for topic: {e}")
            messages.error(request, f"Error deleting hadron message history for topic: {e}")
        return redirect('hadron_prime:detail_hadron_topic', pk=topic_id)


Contents of ../../apps/hadron_prime/views/log_topic_message/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-18 22:53:07
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 22:53:08
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .delete_all_topic_message_logs_views import *


Contents of ../../apps/hadron_prime/views/system/delete_hadron_system_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_hadron_system_views.py
#  Last Modified: 2024-10-17 22:52:25
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:52:25
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_DeleteHadronSystem(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        system_id = kwargs.get('pk')
        hadron_system = get_object_or_404(HadronSystem, id=system_id)
        context['hadron_system'] = hadron_system
        return context

    def post(self, request, *args, **kwargs):
        system_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_SYSTEMS):
            messages.error(self.request, "You do not have permission to delete Hadron Systems.")
            return redirect('hadron_prime:list_hadron_system')
        ##############################

        hadron_system = get_object_or_404(HadronSystem, id=system_id)

        try:
            hadron_system.delete()
        except Exception as e:
            logger.error(f"Error deleting Hadron System: {e}")
            messages.error(request, f"Error deleting Hadron System: {e}")
            return redirect('hadron_prime:detail_hadron_system', pk=system_id)

            logger.info(f'Hadron System "{hadron_system.system_name}" has been deleted successfully.')
            messages.success(request, f'Hadron System "{hadron_system.system_name}" has been deleted successfully.')
        return redirect('hadron_prime:list_hadron_system')


Contents of ../../apps/hadron_prime/views/system/update_hadron_system_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_hadron_system_views.py
#  Last Modified: 2024-10-17 22:52:14
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:52:14
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_UpdateHadronSystem(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        system_id = kwargs.get('pk')
        hadron_system = get_object_or_404(HadronSystem, id=system_id)
        user_orgs = Organization.objects.filter(users__in=[self.request.user])

        context['hadron_system'] = hadron_system
        context['organizations'] = user_orgs
        return context

    def post(self, request, *args, **kwargs):
        system_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_HADRON_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_HADRON_SYSTEMS):
            messages.error(self.request, "You do not have permission to update Hadron Systems.")
            return redirect('hadron_prime:list_hadron_system')
        ##############################

        hadron_system = get_object_or_404(HadronSystem, id=system_id)
        organization_id = request.POST.get('organization')
        system_name = request.POST.get('system_name')
        system_description = request.POST.get('system_description')
        if not organization_id or not system_name:
            logger.error('The required fields are not filled out.')
            messages.error(request, 'Please fill out all required fields.')
            return redirect('hadron_prime:update_hadron_system', pk=system_id)

        try:
            organization = Organization.objects.get(id=organization_id)
            hadron_system.organization = organization
            hadron_system.system_name = system_name
            hadron_system.system_description = system_description
            hadron_system.save()
        except Exception as e:
            logger.error(f"Error updating Hadron System: {e}")
            messages.error(request, f"Error updating Hadron System: {e}")
            return redirect('hadron_prime:update_hadron_system', pk=system_id)

        logger.info(f'Hadron System "{hadron_system.system_name}" updated.')
        messages.success(request, f'Hadron System "{hadron_system.system_name}" updated successfully.')
        return redirect('hadron_prime:list_hadron_system')


Contents of ../../apps/hadron_prime/views/system/list_hadron_system_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_hadron_system_views.py
#  Last Modified: 2024-10-17 22:52:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:52:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_ListHadronSystem(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_HADRON_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_HADRON_SYSTEMS):
            messages.error(self.request, "You do not have permission to list Hadron Systems.")
            return context
        ##############################

        try:
            user_orgs = Organization.objects.filter(users__in=[self.request.user])
            systems_by_org = {org: HadronSystem.objects.filter(organization=org) for org in user_orgs}
            context['systems_by_org'] = systems_by_org
        except Exception as e:
            messages.error(self.request, f"Error listing Hadron Systems: {e}")
            logger.error(f"Error listing Hadron Systems: {e}")
            return context

        return context


Contents of ../../apps/hadron_prime/views/system/create_hadron_system_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_hadron_system_views.py
#  Last Modified: 2024-10-17 22:52:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:52:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_CreateHadronSystem(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['organizations'] = user_orgs
        return context

    def post(self, request, *args, **kwargs):
        organization_id = request.POST.get('organization')

        ##############################
        # PERMISSION CHECK FOR - CREATE_HADRON_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_HADRON_SYSTEMS):
            messages.error(self.request, "You do not have permission to create Hadron Systems.")
            return redirect('hadron_prime:list_hadron_system')
        ##############################

        system_name = request.POST.get('system_name')
        system_description = request.POST.get('system_description')

        if not organization_id or not system_name:
            logger.error('The required fields are not filled out.')
            messages.error(request, 'Please fill out all required fields.')
            return redirect('create_hadron_system')

        try:
            organization = Organization.objects.get(id=organization_id)
            hadron_system = HadronSystem.objects.create(
                organization=organization, system_name=system_name, system_description=system_description,
                created_by_user=request.user)
        except Exception as e:
            logger.error(f"Error creating Hadron System: {e}")
            messages.error(request, f"Error creating Hadron System: {e}")
            return redirect('create_hadron_system')

        logger.info(f'Hadron System "{hadron_system.system_name}" created.')
        messages.success(request, f'Hadron System "{hadron_system.system_name}" created successfully.')
        return redirect('hadron_prime:list_hadron_system')


Contents of ../../apps/hadron_prime/views/system/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-17 22:53:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:53:16
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .list_hadron_system_views import *
from .create_hadron_system_views import *
from .delete_hadron_system_views import *
from .update_hadron_system_views import *
from .detail_hadron_system_views import *


Contents of ../../apps/hadron_prime/views/system/detail_hadron_system_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_hadron_system_views.py
#  Last Modified: 2024-10-18 00:28:09
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 00:28:09
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem, HadronNode, HadronTopic
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class HadronPrimeView_DetailHadronSystem(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        system_id = self.kwargs['pk']

        ##############################
        # PERMISSION CHECK FOR - LIST_HADRON_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_HADRON_SYSTEMS):
            messages.error(self.request, "You do not have permission to list Hadron Systems.")
            return context
        ##############################

        system = HadronSystem.objects.get(pk=system_id)
        nodes = HadronNode.objects.filter(system=system)
        topics = HadronTopic.objects.filter(system=system)
        nodes_paginator = Paginator(nodes, 10)
        topics_paginator = Paginator(topics, 10)
        nodes_page_number = self.request.GET.get('nodes_page')
        topics_page_number = self.request.GET.get('topics_page')
        nodes_page_obj = nodes_paginator.get_page(nodes_page_number)
        topics_page_obj = topics_paginator.get_page(topics_page_number)
        context['hadron_system'] = system
        context['nodes_page_obj'] = nodes_page_obj
        context['topics_page_obj'] = topics_page_obj
        return context


Contents of ../../apps/hadron_prime/views/log_node_speech_history/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-22 13:59:03
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 13:59:03
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .delete_all_node_speech_logs import *


Contents of ../../apps/hadron_prime/views/log_node_speech_history/delete_all_node_speech_logs.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_system_speech_logs.py
#  Last Modified: 2024-10-22 13:59:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 13:59:26
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode, HadronNodeSpeechLog
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class HadronPrimeView_DeleteAllNodeSpeechLogs(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        node_id = kwargs.get('pk')
        node = HadronNode.objects.get(id=node_id)
        hadron_node_speech_logs = HadronNodeSpeechLog.objects.filter(node=node)

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_NODE_SPEECH_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_NODE_SPEECH_LOGS):
            messages.error(self.request, "You do not have permission to delete hadron node speech logs")
            return redirect('hadron_prime:detail_hadron_node', pk=node_id)
        ##############################

        try:
            for hadron_node_speech_log in hadron_node_speech_logs:
                hadron_node_speech_log.delete()
            logger.info(f"All hadron speech logs associated with the node have been deleted.")
            messages.success(request, "All hadron speech logs associated with the node have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron speech logs for node: {e}")
            messages.error(request, f"Error deleting hadron speech logs for node: {e}")
        return redirect('hadron_prime:detail_hadron_node', pk=node_id)


Contents of ../../apps/hadron_prime/views/log_node_execution_history/delete_all_execution_logs_for_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_execution_logs_for_node_views.py
#  Last Modified: 2024-10-18 22:51:23
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 22:51:24
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNodeExecutionLog, HadronNode
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class HadronPrimeView_DeleteAllNodeExecutionLogs(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        node_id = kwargs.get('pk')
        node = HadronNode.objects.get(id=node_id)
        hadron_node_exec_logs = HadronNodeExecutionLog.objects.filter(node=node)

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_NODE_EXECUTION_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_NODE_EXECUTION_LOGS):
            messages.error(self.request, "You do not have permission to delete hadron node execution nodes.")
            return redirect('hadron_prime:detail_hadron_node', pk=node_id)
        ##############################

        try:
            for hadron_node_exec_log in hadron_node_exec_logs:
                hadron_node_exec_log.delete()
            logger.info(f"All hadron execution logs associated with the node have been deleted.")
            messages.success(request, "All hadron execution logs associated with the node have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron execution logs for node: {e}")
            messages.error(request, f"Error deleting hadron execution logs for node: {e}")
        return redirect('hadron_prime:detail_hadron_node', pk=node_id)


Contents of ../../apps/hadron_prime/views/log_node_execution_history/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-18 22:51:05
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 22:51:06
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .delete_all_execution_logs_for_node_views import *


Contents of ../../apps/hadron_prime/views/node/regenerate_node_api_key_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: regenerate_node_api_key_views.py
#  Last Modified: 2024-10-18 19:02:13
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 19:02:14
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import secrets

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode
from apps.hadron_prime.utils import HADRON_NODE_AUTHENTICATION_KEY_TOKEN_SIZE
import logging

from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class HadronPrimeView_RegenerateNodeApiKey(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        node_id = kwargs.get('pk')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_HADRON_NODES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_HADRON_NODES):
            messages.error(self.request, "You do not have permission to regenerate API Key for Hadron Node.")
            return JsonResponse({'error': 'You do not have permission to regenerate API Key for Hadron Node.'})
        ##############################

        node = HadronNode.objects.get(id=node_id)
        new_token = str(secrets.token_urlsafe(HADRON_NODE_AUTHENTICATION_KEY_TOKEN_SIZE))
        node.activation_trigger_authentication_key = new_token
        logger.info(f"New Node API Key regenerated for node: {node.node_name}")
        node.save()
        return JsonResponse({'new_token': new_token})


Contents of ../../apps/hadron_prime/views/node/create_hadron_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_hadron_node_views.py
#  Last Modified: 2024-10-17 22:51:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:51:19
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem, HadronNode, HadronTopic
from apps.leanmod.models import ExpertNetwork
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_CreateHadronNode(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        systems = HadronSystem.objects.filter(organization__in=user_orgs)
        llm_models = LLMCore.objects.filter(organization__in=user_orgs)
        expert_networks = ExpertNetwork.objects.filter(organization__in=user_orgs)
        topics = HadronTopic.objects.filter(system__organization__in=user_orgs)
        context['organizations'] = user_orgs
        context['systems'] = systems
        context['llm_models'] = llm_models
        context['expert_networks'] = expert_networks
        context['topics'] = topics
        return context

    def post(self, request, *args, **kwargs):
        # Get data from POST request
        system_id = request.POST.get('system')

        ##############################
        # PERMISSION CHECK FOR - CREATE_HADRON_NODES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_HADRON_NODES):
            messages.error(self.request, "You do not have permission to create Hadron Nodes.")
            return redirect('hadron_prime:detail_hadron_system', pk=system_id)
        ##############################

        llm_model_id = request.POST.get('llm_model')
        node_name = request.POST.get('node_name')
        node_description = request.POST.get('node_description')
        optional_instructions = request.POST.get('optional_instructions')

        # Retrieve Current State fields
        current_state_curl = request.POST.get('current_state_curl')
        current_state_input_desc = request.POST.get('current_state_input_params_description')
        current_state_output_desc = request.POST.get('current_state_output_params_description')
        # Retrieve Goal State fields
        goal_state_curl = request.POST.get('goal_state_curl')
        goal_state_input_desc = request.POST.get('goal_state_input_params_description')
        goal_state_output_desc = request.POST.get('goal_state_output_params_description')
        # Retrieve error calculation
        error_calculation_curl = request.POST.get('error_calculation_curl')
        error_calculation_input_desc = request.POST.get('error_calculation_input_params_description')
        error_calculation_output_desc = request.POST.get('error_calculation_output_params_description')
        # Retrieve Sensory Measurements fields
        measurements_curl = request.POST.get('measurements_curl')
        measurements_input_desc = request.POST.get('measurements_input_params_description')
        measurements_output_desc = request.POST.get('measurements_output_params_description')
        # Retrieve Action Set fields
        action_set_curl = request.POST.get('action_set_curl')
        action_set_input_desc = request.POST.get('action_set_input_params_description')
        action_set_output_desc = request.POST.get('action_set_output_params_description')
        # Retrieve Analytic Calculation fields
        analytic_calculation_curl = request.POST.get('analytic_calculation_curl')
        analytic_calculation_input_desc = request.POST.get('analytic_calculation_input_params_description')
        analytic_calculation_output_desc = request.POST.get('analytic_calculation_output_params_description')
        # Retrieve Actuation fields
        actuation_curl = request.POST.get('actuation_curl')
        actuation_input_desc = request.POST.get('actuation_input_params_description')
        actuation_output_desc = request.POST.get('actuation_output_params_description')
        # Additional fields if required for relations:
        subscribed_topics = request.POST.getlist('subscribed_topics')
        expert_networks = request.POST.getlist('expert_networks')
        # Lookback memory sizes
        state_action_state_lookback_memory_size = request.POST.get('state_action_state_lookback_memory_size')
        publishing_history_lookback_memory_size = request.POST.get('publishing_history_lookback_memory_size')
        topic_messages_history_lookback_memory_size = request.POST.get('topic_messages_history_lookback_memory_size')

        try:
            # Create the HadronNode object
            node = HadronNode.objects.create(
                system_id=system_id, llm_model_id=llm_model_id, node_name=node_name, node_description=node_description,
                optional_instructions=optional_instructions, current_state_curl=current_state_curl,
                current_state_input_params_description=current_state_input_desc,
                current_state_output_params_description=current_state_output_desc, goal_state_curl=goal_state_curl,
                goal_state_input_params_description=goal_state_input_desc,
                goal_state_output_params_description=goal_state_output_desc,
                error_calculation_curl=error_calculation_curl,
                error_calculation_input_params_description=error_calculation_input_desc,
                error_calculation_output_params_description=error_calculation_output_desc,
                measurements_curl=measurements_curl,
                measurements_input_params_description=measurements_input_desc,
                measurements_output_params_description=measurements_output_desc, action_set_curl=action_set_curl,
                action_set_input_params_description=action_set_input_desc,
                action_set_output_params_description=action_set_output_desc,
                analytic_calculation_curl=analytic_calculation_curl,
                analytic_calculation_input_params_description=analytic_calculation_input_desc,
                analytic_calculation_output_params_description=analytic_calculation_output_desc,
                actuation_curl=actuation_curl, actuation_input_params_description=actuation_input_desc,
                actuation_output_params_description=actuation_output_desc, created_by_user=request.user,
                publishing_history_lookback_memory_size=publishing_history_lookback_memory_size,
                state_action_state_lookback_memory_size=state_action_state_lookback_memory_size,
                topic_messages_history_lookback_memory_size=topic_messages_history_lookback_memory_size)

            # Save relations (ManyToMany fields)
            node.subscribed_topics.set(subscribed_topics)
            node.expert_networks.set(expert_networks)
        except Exception as e:
            logger.error(f'Error creating node: {e}')
            messages.error(request, f'Error creating node: {e}')
            return redirect('hadron_prime:detail_hadron_system', pk=system_id)

        logger.info(f'Node created: {node}')
        messages.success(request, 'Node created successfully.')
        return redirect('hadron_prime:detail_hadron_system', pk=system_id)


Contents of ../../apps/hadron_prime/views/node/update_hadron_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_hadron_node_views.py
#  Last Modified: 2024-10-17 22:51:25
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:51:25
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode, HadronTopic, HadronSystem
from apps.llm_core.models import LLMCore
from apps.leanmod.models import ExpertNetwork
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_UpdateHadronNode(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        systems = HadronSystem.objects.filter(organization__in=user_orgs)
        llm_models = LLMCore.objects.filter(organization__in=user_orgs)
        expert_networks = ExpertNetwork.objects.filter(organization__in=user_orgs)
        topics = HadronTopic.objects.filter(system__organization__in=user_orgs)
        node = get_object_or_404(HadronNode, pk=self.kwargs['pk'])
        selected_topic_ids = list(node.subscribed_topics.values_list('id', flat=True))
        selected_expert_network_ids = list(node.expert_networks.values_list('id', flat=True))

        context['node'] = node
        context['systems'] = systems
        context['llm_models'] = llm_models
        context['expert_networks'] = expert_networks
        context['topics'] = topics
        context['selected_topic_ids'] = selected_topic_ids
        context['selected_expert_network_ids'] = selected_expert_network_ids
        return context

    def post(self, request, *args, **kwargs):
        node = get_object_or_404(HadronNode, pk=self.kwargs['pk'])
        system_id = request.POST.get('system')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_HADRON_NODES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_HADRON_NODES):
            messages.error(self.request, "You do not have permission to update Hadron Nodes.")
            return redirect('hadron_prime:detail_hadron_system', pk=node.system_id)
        ##############################

        llm_model_id = request.POST.get('llm_model')
        node_name = request.POST.get('node_name')
        node_description = request.POST.get('node_description')
        optional_instructions = request.POST.get('optional_instructions')

        # Retrieve Current State fields
        current_state_curl = request.POST.get('current_state_curl')
        current_state_input_desc = request.POST.get('current_state_input_params_description')
        current_state_output_desc = request.POST.get('current_state_output_params_description')
        # Retrieve Goal State fields
        goal_state_curl = request.POST.get('goal_state_curl')
        goal_state_input_desc = request.POST.get('goal_state_input_params_description')
        goal_state_output_desc = request.POST.get('goal_state_output_params_description')
        # Retrieve error calculation
        error_calculation_curl = request.POST.get('error_calculation_curl')
        error_calculation_input_desc = request.POST.get('error_calculation_input_params_description')
        error_calculation_output_desc = request.POST.get('error_calculation_output_params_description')
        # Retrieve Sensory Measurements fields
        measurements_curl = request.POST.get('measurements_curl')
        measurements_input_desc = request.POST.get('measurements_input_params_description')
        measurements_output_desc = request.POST.get('measurements_output_params_description')
        # Retrieve Action Set fields
        action_set_curl = request.POST.get('action_set_curl')
        action_set_input_desc = request.POST.get('action_set_input_params_description')
        action_set_output_desc = request.POST.get('action_set_output_params_description')
        # Retrieve Analytic Calculation fields
        analytic_calculation_curl = request.POST.get('analytic_calculation_curl')
        analytic_calculation_input_desc = request.POST.get('analytic_calculation_input_params_description')
        analytic_calculation_output_desc = request.POST.get('analytic_calculation_output_params_description')
        # Retrieve Actuation fields
        actuation_curl = request.POST.get('actuation_curl')
        actuation_input_desc = request.POST.get('actuation_input_params_description')
        actuation_output_desc = request.POST.get('actuation_output_params_description')
        # Additional fields if required for relations:
        subscribed_topics = request.POST.getlist('subscribed_topics')
        expert_networks = request.POST.getlist('expert_networks')
        # Lookback memory sizes
        state_action_state_lookback_memory_size = request.POST.get('state_action_state_lookback_memory_size')
        publishing_history_lookback_memory_size = request.POST.get('publishing_history_lookback_memory_size')
        topic_messages_history_lookback_memory_size = request.POST.get('topic_messages_history_lookback_memory_size')

        # Update the node object

        try:
            node.system_id = system_id
            node.llm_model_id = llm_model_id
            node.node_name = node_name
            node.node_description = node_description
            node.optional_instructions = optional_instructions
            node.current_state_curl = current_state_curl
            node.current_state_input_params_description = current_state_input_desc
            node.current_state_output_params_description = current_state_output_desc
            node.goal_state_curl = goal_state_curl
            node.goal_state_input_params_description = goal_state_input_desc
            node.goal_state_output_params_description = goal_state_output_desc
            node.error_calculation_curl = error_calculation_curl
            node.error_calculation_input_params_description = error_calculation_input_desc
            node.error_calculation_output_params_description = error_calculation_output_desc
            node.measurements_curl = measurements_curl
            node.measurements_input_params_description = measurements_input_desc
            node.measurements_output_params_description = measurements_output_desc
            node.action_set_curl = action_set_curl
            node.action_set_input_params_description = action_set_input_desc
            node.action_set_output_params_description = action_set_output_desc
            node.analytic_calculation_curl = analytic_calculation_curl
            node.analytic_calculation_input_params_description = analytic_calculation_input_desc
            node.analytic_calculation_output_params_description = analytic_calculation_output_desc
            node.actuation_curl = actuation_curl
            node.actuation_input_params_description = actuation_input_desc
            node.actuation_output_params_description = actuation_output_desc
            node.state_action_state_lookback_memory_size = state_action_state_lookback_memory_size
            node.publishing_history_lookback_memory_size = publishing_history_lookback_memory_size
            node.topic_messages_history_lookback_memory_size = topic_messages_history_lookback_memory_size

            node.save()
            node.subscribed_topics.set(subscribed_topics)
            node.expert_networks.set(expert_networks)
        except Exception as e:
            logger.error(f"Error updating Hadron Node: {e}")
            messages.error(request, f"Error updating Hadron Node: {e}")
            return redirect('hadron_prime:detail_hadron_node', pk=node.id)

        logger.info(f'Node updated: {node}')
        messages.success(request, 'Node updated successfully.')
        return redirect('hadron_prime:detail_hadron_node', pk=node.id)


Contents of ../../apps/hadron_prime/views/node/detail_hadron_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_hadron_node_views.py
#  Last Modified: 2024-10-18 00:24:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 00:24:17
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode
from apps.user_permissions.utils import PermissionNames
from config.settings import BASE_URL
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_DetailHadronNode(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_HADRON_NODES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_HADRON_NODES):
            messages.error(self.request, "You do not have permission to list Hadron Nodes.")
            return context
        ##############################

        node = get_object_or_404(HadronNode, id=kwargs['pk'])
        context['node'] = node

        # Fetch speech logs
        speech_logs = node.speech_logs.all().order_by('-created_at')
        paginator_speech_logs = Paginator(speech_logs, 10)
        page_number_speech_logs = self.request.GET.get('speech_logs_page')
        context['speech_logs_page_obj'] = paginator_speech_logs.get_page(page_number_speech_logs)
        # Fetch execution logs
        execution_logs = node.execution_logs.all().order_by('-created_at')
        paginator_exec_logs = Paginator(execution_logs, 10)
        page_number_exec_logs = self.request.GET.get('execution_logs_page')
        context['execution_logs_page_obj'] = paginator_exec_logs.get_page(page_number_exec_logs)
        # Fetch state-error-action-state-error logs
        seas_logs = node.state_action_state_history_logs.all().order_by('-created_at')
        paginator_seas_logs = Paginator(seas_logs, 10)
        page_number_seas_logs = self.request.GET.get('seas_logs_page')
        context['seas_logs_page_obj'] = paginator_seas_logs.get_page(page_number_seas_logs)
        # Fetch publishing logs (HadronTopicMessages)
        topic_messages = node.publishing_history_logs.all().order_by('-created_at')
        paginator_topic_logs = Paginator(topic_messages, 10)
        page_number_topic_logs = self.request.GET.get('publishing_logs_page')
        context['publishing_logs_page_obj'] = paginator_topic_logs.get_page(page_number_topic_logs)
        context["BASE_URL"] = BASE_URL
        return context


Contents of ../../apps/hadron_prime/views/node/delete_hadron_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_hadron_node_views.py
#  Last Modified: 2024-10-17 22:51:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:51:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_DeleteHadronNode(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        node = get_object_or_404(HadronNode, id=kwargs['pk'])
        context['node'] = node
        return context

    def post(self, request, *args, **kwargs):
        node = get_object_or_404(HadronNode, id=kwargs['pk'])

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_NODES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_NODES):
            messages.error(self.request, "You do not have permission to delete Hadron Nodes.")
            return redirect('hadron_prime:detail_hadron_node', pk=node.id)
        ##############################

        try:
            node.delete()
        except Exception as e:
            logger.error(f"Error deleting Hadron Node: {e}")
            messages.error(request, f"Error deleting Hadron Node: {e}")
            return redirect('hadron_prime:detail_hadron_node', pk=node.id)

            logger.info(f'Hadron Node "{node.node_name}" deleted by user "{request.user}".')
            messages.success(request, f'The Hadron Node "{node.node_name}" was successfully deleted.')
        return redirect('hadron_prime:detail_hadron_system', pk=node.system.id)


Contents of ../../apps/hadron_prime/views/node/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-17 22:51:07
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 22:51:08
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .delete_hadron_node_views import *
from .update_hadron_node_views import *
from .create_hadron_node_views import *
from .detail_hadron_node_views import *
from .regenerate_node_api_key_views import *


Contents of ../../apps/hadron_prime/views/connect_assistant/connect_assistant_to_hadron_node_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: connect_assistant_to_hadron_node_views.py
#  Last Modified: 2024-11-13 03:48:00
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 03:48:00
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode, HadronSystem, HadronNodeAssistantConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class HadronPrimeView_ConnectAssistantToHadronNode(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user]).all()
        assistants = Assistant.objects.filter(organization__in=user_orgs).all()
        hadron_systems = HadronSystem.objects.filter(organization__in=user_orgs).all()
        hadron_nodes = HadronNode.objects.filter(system__in=hadron_systems).all()
        context["assistants"] = assistants
        context["hadron_nodes"] = hadron_nodes
        context["existing_connections"] = HadronNodeAssistantConnection.objects.filter(
            assistant__organization__in=user_orgs).all()
        return context

    def post(self, request, *args, **kwargs):
        assistant_id = self.request.POST.get("assistant_id")
        node_id = self.request.POST.get("node_id")

        ##############################
        # PERMISSION CHECK FOR - CONNECT_ASSISTANTS_TO_HADRON_NODE
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CONNECT_ASSISTANTS_TO_HADRON_NODE):
            messages.error(self.request, "You do not have permission to connect an assistant to a hadron prime node.")
            return self.render_to_response(self.get_context_data())
        ##############################

        assistant = Assistant.objects.get(id=assistant_id)
        hadron_node = HadronNode.objects.get(id=node_id)

        try:
            HadronNodeAssistantConnection.objects.create(
                assistant=assistant,
                hadron_prime_node=hadron_node,
                created_by_user=self.request.user
            )
        except Exception as e:
            messages.error(self.request, f"Error while connecting assistant to Hadron Prime node: {e}")
            logger.error(f"Error while connecting assistant to Hadron Prime node: {e}")

        messages.success(self.request, "Assistant connected to Hadron Prime node successfully.")
        return self.render_to_response(self.get_context_data())


Contents of ../../apps/hadron_prime/views/connect_assistant/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-13 03:47:20
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 03:47:21
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .delete_assistant_connection_views import *
from .connect_assistant_to_hadron_node_views import *


Contents of ../../apps/hadron_prime/views/connect_assistant/delete_assistant_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_assistant_connection_views.py
#  Last Modified: 2024-11-13 03:48:20
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 03:48:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNodeAssistantConnection
from apps.user_permissions.utils import PermissionNames


class HadronPrimeView_AssistantConnectionDelete(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get("pk")

        ##############################
        # PERMISSION CHECK FOR - DISCONNECT_ASSISTANTS_FROM_HADRON_NODE
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DISCONNECT_ASSISTANTS_FROM_HADRON_NODE):
            messages.error(self.request, "You do not have permission to disconnect an assistant from a Hadron Prime Node.")
            return redirect("hadron_prime:connect_assistant")
        ##############################

        try:
            connection = HadronNodeAssistantConnection.objects.get(id=connection_id)
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection: " + str(e))
            return redirect("hadron_prime:connect_assistant")

        messages.success(request, "Connection deleted successfully.")
        return redirect("hadron_prime:connect_assistant")


Contents of ../../apps/support_system/views/detail_support_ticket_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_support_ticket_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.support_system.models import SupportTicket, SupportTicketResponse
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class SupportView_TicketDetail(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SUPPORT_TICKETS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SUPPORT_TICKETS):
            messages.error(self.request, "You do not have permission to view support tickets.")
            return context
        ##############################

        ticket = get_object_or_404(SupportTicket, pk=self.kwargs['pk'], user=self.request.user)
        context['ticket'] = ticket
        context['responses'] = ticket.responses.all().order_by('created_at')
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SUPPORT_TICKETS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SUPPORT_TICKETS):
            messages.error(self.request, "You do not have permission to update/modify support tickets.")
            return redirect('support_system:list')
        ##############################

        ticket = get_object_or_404(SupportTicket, pk=self.kwargs['pk'], user=request.user)
        output = request.POST.get('response')
        if output:
            SupportTicketResponse.objects.create(ticket=ticket, user=request.user, response=output)
        logger.info(f"Support ticket response was added by User: {request.user.id}.")
        return redirect('support_system:detail', pk=ticket.pk)


Contents of ../../apps/support_system/views/create_support_ticket_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_support_ticket_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.support_system.forms.support_ticket_forms import SupportTicketForm
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class SupportView_TicketCreate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = SupportTicketForm()
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_SUPPORT_TICKETS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_SUPPORT_TICKETS):
            messages.error(self.request, "You do not have permission to create support tickets.")
            return redirect('support_system:list')
        ##############################

        form = SupportTicketForm(request.POST, request.FILES)
        if form.is_valid():
            ticket = form.save(commit=False)
            ticket.user = request.user
            ticket.save()
            logger.info(f"Support ticket was created by User: {self.request.user.id}.")
            return redirect('support_system:list')
        else:
            context = self.get_context_data()
            context['form'] = form
            logger.error(f"Support ticket creation failed for User: {self.request.user.id}.")
            return self.render_to_response(context)


Contents of ../../apps/support_system/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_support_tickets_views import *
from .create_support_ticket_views import *
from .detail_support_ticket_views import *


Contents of ../../apps/support_system/views/list_support_tickets_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_support_tickets_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.support_system.models import SupportTicket
from apps.support_system.utils import TICKET_STATUS_PRIORITY_MAP
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class SupportView_TicketList(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SUPPORT_TICKETS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SUPPORT_TICKETS):
            messages.error(self.request, "You do not have permission to view support tickets.")
            return context
        ##############################

        queryset = SupportTicket.objects.filter(user=self.request.user)
        status_priority = TICKET_STATUS_PRIORITY_MAP
        sorted_queryset = sorted(queryset, key=lambda ticket: (status_priority.get(ticket.status, 99),
                                                               ticket.updated_at, ticket.created_at, ticket.priority),
                                 reverse=True)
        paginator = Paginator(sorted_queryset, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        logger.info(f"Support ticket list was viewed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/datasource_file_systems/views/create_file_system_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_file_system_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.datasource_file_systems.utils import DATASOURCE_FILE_SYSTEMS_OS_TYPES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class FileSystemView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user
        orgs = context_user.organizations.filter(users__in=[context_user])
        context['assistants'] = Assistant.objects.filter(organization__in=orgs)
        context['os_choices'] = DATASOURCE_FILE_SYSTEMS_OS_TYPES
        context['user'] = context_user
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_FILE_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_FILE_SYSTEMS):
            messages.error(self.request, "You do not have permission to create a file system connection.")
            return redirect('datasource_file_systems:list')
        ##############################

        name = request.POST.get('name')
        description = request.POST.get('description')
        os_type = request.POST.get('os_type')
        agent_id = request.POST.get('assistant')
        host_url = request.POST.get('host_url')
        port = request.POST.get('port', 22)
        username = request.POST.get('username')
        password = request.POST.get('password')
        os_read_limit_tokens = request.POST.get('os_read_limit_tokens', 5_000)
        is_read_only = request.POST.get('is_read_only') == 'on'
        created_by_user = request.user

        try:
            agent = Assistant.objects.get(id=agent_id)
            conn = DataSourceFileSystem.objects.create(
                name=name, description=description, os_type=os_type, assistant=agent, host_url=host_url,
                port=port, username=username, password=password, os_read_limit_tokens=os_read_limit_tokens,
                is_read_only=is_read_only, created_by_user=created_by_user
            )
            conn.save()
            logger.info(f"Data Source File System created successfully.")
            messages.success(request, 'Data Source File System created successfully.')
            return redirect('datasource_file_systems:list')
        except Assistant.DoesNotExist:
            logger.error(f'Invalid assistant selected.')
            messages.error(request, 'Invalid assistant selected.')
            return redirect('datasource_file_systems:create')
        except Exception as e:
            logger.error(f'Error creating Data Source File System: {e}')
            messages.error(request, f'Error creating Data Source File System: {e}')
            return redirect('datasource_file_systems:list')


Contents of ../../apps/datasource_file_systems/views/update_file_system_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_file_system_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.datasource_file_systems.utils import DATASOURCE_FILE_SYSTEMS_OS_TYPES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class FileSystemView_Update(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user
        orgs = context_user.organizations.filter(users__in=[context_user])
        context['assistants'] = Assistant.objects.filter(organization__in=orgs)
        context['os_choices'] = DATASOURCE_FILE_SYSTEMS_OS_TYPES
        context['user'] = context_user
        try:
            conn = DataSourceFileSystem.objects.get(pk=kwargs['pk'])
            context['connection'] = conn
        except DataSourceFileSystem.DoesNotExist:
            messages.error(self.request, 'Data Source File System not found.')
            return redirect('datasource_file_systems:list')
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_FILE_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_FILE_SYSTEMS):
            messages.error(self.request, "You do not have permission to update a file system connection.")
            return redirect('datasource_file_systems:list')
        ##############################

        try:
            c = get_object_or_404(DataSourceFileSystem, pk=kwargs['pk'])
        except DataSourceFileSystem.DoesNotExist:
            messages.error(request, 'Data Source File System not found.')
            return redirect('datasource_file_systems:list')

        c.name = request.POST.get('name')
        c.description = request.POST.get('description')
        c.os_type = request.POST.get('os_type')
        assistant_id = request.POST.get('assistant')
        c.host_url = request.POST.get('host_url')
        c.port = request.POST.get('port', 22)
        c.username = request.POST.get('username')
        c.password = request.POST.get('password')
        c.os_read_limit_tokens = request.POST.get('os_read_limit_tokens', 5_000)
        c.is_read_only = request.POST.get('is_read_only') == 'on'

        try:
            agent = Assistant.objects.get(id=assistant_id)
            c.assistant = agent
        except Assistant.DoesNotExist:
            logger.error(f'Invalid assistant selected.')
            messages.error(request, 'Invalid assistant selected.')
            return redirect('datasource_file_systems:update', kwargs={'pk': kwargs['pk']})

        try:
            c.save()
            logger.info(f"Data Source File System updated successfully.")
            messages.success(request, 'Data Source File System updated successfully.')
            return redirect('datasource_file_systems:list')
        except Exception as e:
            logger.error(f'Error updating Data Source File System: {e}')
            messages.error(request, f'Error updating Data Source File System: {e}')
            return redirect('datasource_file_systems:update', kwargs={'pk': kwargs['pk']})


Contents of ../../apps/datasource_file_systems/views/list_file_systems_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_file_systems_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class FileSystemView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_FILE_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_FILE_SYSTEMS):
            messages.error(self.request, "You do not have permission to list file system connections.")
            return context
        ##############################

        try:
            context_user = self.request.user
            conns_by_orgs = {}
            agents = Assistant.objects.filter(
                organization__in=context_user.organizations.filter(users__in=[context_user]))
            for agent in agents:
                org = agent.organization
                if org not in conns_by_orgs:
                    conns_by_orgs[org] = {}
                if agent not in conns_by_orgs[org]:
                    conns_by_orgs[org][agent] = []
                conns = DataSourceFileSystem.objects.filter(assistant=agent)
                conns_by_orgs[org][agent].extend(conns)
            context['connections_by_organization'] = conns_by_orgs
            context['user'] = context_user
        except Exception as e:
            logger.error(f"User: {self.request.user} - File System - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing file system connections.')
            return context

        logger.info(f"File System Connections were listed.")
        return context


Contents of ../../apps/datasource_file_systems/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .create_file_system_views import *
from .delete_file_system_views import *
from .update_file_system_views import *
from .list_file_systems_views import *


Contents of ../../apps/datasource_file_systems/views/delete_file_system_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_file_system_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class FileSystemView_Delete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_FILE_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_FILE_SYSTEMS):
            messages.error(self.request, "You do not have permission to delete file system connections.")
            return redirect('datasource_file_systems:list')
        ##############################

        conn = get_object_or_404(DataSourceFileSystem, pk=kwargs['pk'])

        try:
            conn.delete()
        except Exception as e:
            logger.error(f"User: {request.user} - File System - Delete Error: {e}")
            messages.error(request, 'An error occurred while deleting the file system connection.')
            return redirect('datasource_file_systems:list')

        logger.info(f"[FileSystemView_Delete] File System Connection Deleted: {conn}")
        return redirect('datasource_file_systems:list')


Contents of ../../apps/dashboard/views/main_dashboard_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: main_dashboard_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.utils import timezone
from django.views.generic import TemplateView

from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
from apps.dashboard.utils import INITIAL_STATISTICS_N_DAYS_BACK, build_statistics_for_graph
from apps.dashboard.utils.class_utils import TransactionStatisticsManager
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DashboardView_Main(LoginRequiredMixin, TemplateView):
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user

        try:
            orgs = Organization.objects.filter(users__in=[user])
            manager = TransactionStatisticsManager(user=user)
            data_statistics = manager.statistics
            last_n_days = INITIAL_STATISTICS_N_DAYS_BACK
            context["days"] = last_n_days
            ai_models = LLMCore.objects.filter(organization__in=orgs)
            context["llm_models"] = ai_models
            last_update_datetime = timezone.now().strftime("%Y-%m-%d %H:%M:%S")
            context["last_update_datetime"] = last_update_datetime
            context = build_statistics_for_graph(statistics=data_statistics, context=context)
        except Exception as e:
            logger.error(f"Error getting main dashboard context data: {e}")
            return context

        logger.info(f"User: {user} - Statistics: {data_statistics}")
        return context

    def post(self, request, *args, **kwargs):
        context = self.get_context_data()
        context_user = request.user

        try:
            ai_model = request.POST.get("llm_model")
            llm_core = LLMCore.objects.get(id=ai_model)
            manager = TransactionStatisticsManager(user=context_user)
            data_statistics = manager.statistics
            response = GenerativeAIDecodeController.provide_analysis(llm_model=llm_core, statistics=data_statistics)
            context.update(response=response)
        except Exception as e:
            logger.error(f"Error getting main dashboard context data: {e}")
            return context

        logger.info(f"AI Model: {llm_core.nickname} - Response: {response}")
        return self.render_to_response(context)


Contents of ../../apps/dashboard/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .main_dashboard_views import *
from .refresh_dashboard_views import *
from .change_statistics_interval_views import *


Contents of ../../apps/dashboard/views/refresh_dashboard_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: refresh_dashboard_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.utils import timezone
from django.views.generic import TemplateView

from apps.dashboard.utils import TransactionStatisticsManager, build_statistics_for_graph
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DashboardView_Refresh(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.get_context_data()
        user = self.request.user

        try:
            orgs = Organization.objects.filter(users__in=[user])
            ai_models = LLMCore.objects.filter(organization__in=orgs)
            context["llm_models"] = ai_models
            last_n_days = self.kwargs.get("days")
            if last_n_days == "all":
                last_n_days = 10_000
                context["days"] = "all"
            else:
                context["days"] = last_n_days

            manager = TransactionStatisticsManager(user=self.request.user, last_days=int(last_n_days))
            data_statistics = manager.statistics
            last_update_datetime = timezone.now().strftime("%Y-%m-%d %H:%M:%S")
            context["last_update_datetime"] = last_update_datetime
            context = build_statistics_for_graph(statistics=data_statistics, context=context)
        except Exception as e:
            logger.error(f"Error getting main dashboard context data: {e}")
            return context

        logger.info(f"User: {user} - Statistics: {data_statistics}")
        return self.render_to_response(context)


Contents of ../../apps/dashboard/views/change_statistics_interval_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: change_statistics_interval_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from django.views.generic import TemplateView

from apps.dashboard.utils import CONST_MINUTES, TransactionStatisticsManager, build_statistics_for_graph
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class DashboardView_ChangeStatisticsInterval(LoginRequiredMixin, TemplateView):
    @method_decorator(cache_page(30 * CONST_MINUTES))  # 30 minutes
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.get_context_data()
        user = self.request.user

        try:
            orgs = Organization.objects.filter(users__in=[user])
            ai_models = LLMCore.objects.filter(organization__in=orgs)
            context["llm_models"] = ai_models
            last_n_days = self.kwargs.get("days")

            if last_n_days == "0" or last_n_days == 0:
                last_n_days = 10_000
                context["days"] = "all"
            else:
                context["days"] = last_n_days

            manager = TransactionStatisticsManager(user=self.request.user, last_days=int(last_n_days))
            data_statistics = manager.statistics
            last_update_datetime = timezone.now().strftime("%Y-%m-%d %H:%M:%S")
            context["last_update_datetime"] = last_update_datetime
            context = build_statistics_for_graph(statistics=data_statistics, context=context)
        except Exception as e:
            logger.error(f"Error getting statistics for the user: {e}")
            return context

        logger.info(f"User {user.id} requested statistics for the last {last_n_days} days.")
        return self.render_to_response(context)


Contents of ../../apps/orchestrations/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .query import *
from .orchestration import *
from .connect_reactant_assistant import *


Contents of ../../apps/orchestrations/views/orchestration/create_orchestration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_orchestration_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.llm_core.models import LLMCore
from apps.orchestrations.forms import MaestroForm
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class OrchestrationView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = MaestroForm()
        context['organizations'] = Organization.objects.filter(users=self.request.user)
        context['llm_models'] = LLMCore.objects.filter(organization__in=context['organizations'])
        context['assistants'] = Assistant.objects.filter(organization__in=context['organizations'])
        return context

    def post(self, request, *args, **kwargs):
        form = MaestroForm(request.POST, request.FILES)

        ##############################
        # PERMISSION CHECK FOR - ADD_ORCHESTRATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_ORCHESTRATIONS):
            messages.error(self.request, "You do not have permission to create orchestrations.")
            return redirect('orchestrations:list')
        ##############################

        if form.is_valid():
            maestro = form.save(commit=False)
            maestro.created_by_user = request.user
            maestro.last_updated_by_user = request.user
            maestro.save()
            workers = request.POST.getlist('workers')
            maestro.workers.set(workers)
            logger.info(f"Orchestration was created by User: {self.request.user.id}.")
            return redirect('orchestrations:list')
        else:
            error_msgs = form.errors
            context = self.get_context_data(**kwargs)
            context['form'] = form
            context['error_messages'] = error_msgs
            logger.error(f"Orchestration creation failed by User: {self.request.user.id}.")
            return self.render_to_response(context)


Contents of ../../apps/orchestrations/views/orchestration/list_orchestrations_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_orchestrations_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models import Maestro
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class OrchestrationView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ORCHESTRATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ORCHESTRATIONS):
            messages.error(self.request, "You do not have permission to list orchestrations.")
            return context
        ##############################

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        orchestrations = Maestro.objects.filter(organization__in=user_orgs)
        orchestrations_by_org = {}
        for org in user_orgs:
            orchestrations_by_org[org] = orchestrations.filter(organization=org)
        context['orchestrations_by_organization'] = orchestrations_by_org
        logger.info(f"Orchestrations were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/orchestrations/views/orchestration/delete_orchestration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_orchestration_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models import Maestro
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class OrchestrationView_Delete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        orchestration = get_object_or_404(Maestro, pk=kwargs['pk'])
        context['orchestration'] = orchestration
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_ORCHESTRATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ORCHESTRATIONS):
            messages.error(self.request, "You do not have permission to delete orchestrations.")
            return redirect('orchestrations:list')
        ##############################

        orchestration = get_object_or_404(Maestro, pk=kwargs['pk'])
        orchestration_name = orchestration.name

        try:
            orchestration.delete()
        except Exception as e:
            messages.error(request, f"An error occurred while deleting the Orchestration: {str(e)}")
            return redirect("orchestrations:list")

        logger.info(f"Orchestration was deleted by User: {self.request.user.id}.")
        messages.success(request, f'Orchestration "{orchestration_name}" has been successfully deleted.')
        return redirect('orchestrations:list')


Contents of ../../apps/orchestrations/views/orchestration/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_orchestrations_views import *
from .delete_orchestration_views import *
from .update_orchestration_views import *
from .create_orchestration_views import *


Contents of ../../apps/orchestrations/views/orchestration/update_orchestration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_orchestration_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.llm_core.models import LLMCore
from apps.orchestrations.forms import MaestroForm
from apps.orchestrations.models import Maestro
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class OrchestrationView_Update(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        orchestration = get_object_or_404(Maestro, pk=kwargs['pk'])
        context['form'] = MaestroForm(instance=orchestration)
        context['orchestration'] = orchestration
        context['organizations'] = Organization.objects.filter(users=self.request.user)
        context['llm_models'] = LLMCore.objects.filter(organization__in=context['organizations'])
        context['assistants'] = Assistant.objects.filter(organization__in=context['organizations'])
        context['selected_workers'] = orchestration.workers.all().values_list('id', flat=True)
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_ORCHESTRATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_ORCHESTRATIONS):
            messages.error(self.request, "You do not have permission to update orchestrations.")
            return redirect('orchestrations:list')
        ##############################

        orchestration = get_object_or_404(Maestro, pk=kwargs['pk'])
        form = MaestroForm(request.POST, request.FILES, instance=orchestration)
        if form.is_valid():
            updated_orchestration = form.save(commit=False)
            updated_orchestration.last_updated_by_user = request.user  # Update last_updated_by_user field
            updated_orchestration.save()
            workers = request.POST.getlist('workers')
            updated_orchestration.workers.set(workers)
            logger.info(f"Orchestration was updated by User: {self.request.user.id}.")
            return redirect('orchestrations:update', pk=kwargs['pk'])
        else:
            context = self.get_context_data(**kwargs)
            context['form'] = form
            context['error_messages'] = form.errors
            logger.error(f"Orchestration update failed by User: {self.request.user.id}.")
            return self.render_to_response(context)


Contents of ../../apps/orchestrations/views/connect_reactant_assistant/connect_reactant_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: connect_reactant_assistant_views.py
#  Last Modified: 2024-11-13 04:34:09
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 04:34:09
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models import Maestro, OrchestrationReactantAssistantConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class OrchestrationView_ConnectReactantAssistantToOrchestration(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user]).all()
        assistants = Assistant.objects.filter(organization__in=user_orgs).all()
        orchestration_maestros = Maestro.objects.filter(organization__in=user_orgs).all()
        context["assistants"] = assistants
        context["orchestration_maestros"] = orchestration_maestros
        context["existing_connections"] = OrchestrationReactantAssistantConnection.objects.filter(assistant__organization__in=user_orgs).all()
        return context

    def post(self, request, *args, **kwargs):
        assistant_id = self.request.POST.get("assistant_id")
        maestro_instance_id = self.request.POST.get("maestro_instance_id")

        ##############################
        # PERMISSION CHECK FOR - CONNECT_REACTANT_ASSISTANTS_TO_ORCHESTRATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CONNECT_REACTANT_ASSISTANTS_TO_ORCHESTRATION):
            messages.error(self.request, "You do not have permission to connect reactant assistants to an orchestration.")
            return self.render_to_response(self.get_context_data())
        ##############################

        assistant = Assistant.objects.get(id=assistant_id)
        maestro_instance = Maestro.objects.get(id=maestro_instance_id)

        try:
            OrchestrationReactantAssistantConnection.objects.create(
                assistant=assistant,
                orchestration_maestro=maestro_instance,
                created_by_user=self.request.user
            )
        except Exception as e:
            messages.error(self.request, f"Error while connecting reactant assistant to Orchestration Maestro: {e}")
            logger.error(f"Error while connecting reactant assistant to Orchestration Maestro: {e}")

        messages.success(self.request, "Reactant assistant connected to Orchestration Maestro successfully.")
        return self.render_to_response(self.get_context_data())



Contents of ../../apps/orchestrations/views/connect_reactant_assistant/disconnect_reactant_assistant_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: disconnect_reactant_assistant_connection_views.py
#  Last Modified: 2024-11-13 04:37:45
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 04:37:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models import OrchestrationReactantAssistantConnection
from apps.user_permissions.utils import PermissionNames


class OrchestrationView_AssistantConnectionDelete(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get("pk")

        ##############################
        # PERMISSION CHECK FOR - DISCONNECT_REACTANT_ASSISTANTS_FROM_ORCHESTRATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DISCONNECT_REACTANT_ASSISTANTS_FROM_ORCHESTRATION):
            messages.error(self.request, "You do not have permission to disconnect reactant assistants from an orchestration.")
            return redirect("orchestrations:connect_assistant")
        ##############################

        try:
            connection = OrchestrationReactantAssistantConnection.objects.get(id=connection_id)
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection: " + str(e))
            return redirect("orchestrations:connect_assistant")

        messages.success(request, "Connection deleted successfully.")
        return redirect("orchestrations:connect_assistant")


Contents of ../../apps/orchestrations/views/connect_reactant_assistant/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-13 04:34:12
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 04:34:13
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .connect_reactant_assistant_views import *
from .disconnect_reactant_assistant_connection_views import *


Contents of ../../apps/orchestrations/views/query/list_orchestration_queries_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_orchestration_queries_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import base64
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.orchestration.orchestration_executor import OrchestrationExecutor
from apps.core.media_managers.media_manager_execution_handler import MediaManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models import Maestro, OrchestrationQuery, OrchestrationQueryLog
from apps.orchestrations.utils import OrchestrationQueryLogTypesNames
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class OrchestrationView_QueryList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        maestro_id = kwargs['pk']
        maestro = get_object_or_404(Maestro, id=maestro_id)
        query_chats = OrchestrationQuery.objects.filter(created_by_user=self.request.user, maestro=maestro)
        context['maestro'] = maestro
        context['query_chats'] = query_chats
        context['maestro_list'] = Maestro.objects.all()
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_ORCHESTRATION_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_AND_USE_ORCHESTRATION_CHATS):
            messages.error(self.request, "You do not have permission to create and use orchestration queries.")
            return redirect('orchestrations:list')
        ##############################

        maestro_id = request.POST.get('maestro_id')
        query_text = request.POST.get('query_text')
        attached_images = request.FILES.getlist('attached_images[]')
        attached_files = request.FILES.getlist('attached_files[]')

        sketch_image_full_uris_list = self._handle_sketch_image(request)
        edit_image_full_uris_list = self._handle_edit_image(request)
        self._handle_save_images(attached_images, edit_image_full_uris_list, sketch_image_full_uris_list)
        file_full_uris = self._handle_save_files(attached_files)
        self._handle_record_audio(file_full_uris, request)
        maestro = get_object_or_404(Maestro, id=maestro_id)
        query_chat = OrchestrationQuery.objects.create(
            maestro=maestro, query_text=query_text, created_by_user=request.user, last_updated_by_user=request.user)
        query_log = OrchestrationQueryLog.objects.create(
            orchestration_query=query_chat, log_type=OrchestrationQueryLogTypesNames.USER,
            log_text_content=query_text + f"""
                        -----

                        **IMAGE URLS:**
                        '''
                        {attached_images}
                        '''

                        -----

                        **FILE URLS:**
                        '''
                        {attached_files}
                        '''

                        -----
                    """, log_file_contents=attached_images, log_image_contents=attached_files)
        query_chat.logs.add(query_log)
        query_chat.save()
        orch_xc = OrchestrationExecutor(maestro=maestro, query_chat=query_chat)
        final_response = orch_xc.execute_for_query()

        logger.info(f"Orchestration query was created by User: {self.request.user.id}.")
        return redirect('orchestrations:query_detail', pk=maestro_id, query_id=query_chat.id)

    @staticmethod
    def _handle_record_audio(file_full_uris, request):
        record_audio = request.POST.get('record_audio')
        audio_full_uri = None
        if record_audio:
            audio_base_64 = request.POST.get('record_audio')
            audio_bytes = base64.b64decode(audio_base_64.split("base64,")[1].encode())
            audio_full_uri = MediaManager.save_files_and_return_uris([(audio_bytes, 'audio.webm')])[0]
        if audio_full_uri:
            file_full_uris.append(audio_full_uri)
        logger.info(f"Audio was saved successfully.")
        return

    @staticmethod
    def _handle_save_files(attached_files):
        file_bytes_list = []
        for file in attached_files:
            file_name = file.name
            try:
                file_bytes = file.read()
                logger.info(f"File was saved successfully.")
            except Exception as e:
                logger.error(f"File was not saved successfully.")
                continue
            file_bytes_list.append((file_bytes, file_name))
        file_full_uris = MediaManager.save_files_and_return_uris(file_bytes_list)
        return file_full_uris

    @staticmethod
    def _handle_save_images(attached_images, edit_image_full_uris_list, sketch_image_full_uris_list):
        image_bytes_list = []
        for image in attached_images:
            try:
                image_bytes = image.read()
                logger.info(f"Image was saved successfully.")
            except Exception as e:
                logger.error(f"Image was not saved successfully.")
                continue
            image_bytes_list.append(image_bytes)
        image_full_uris = MediaManager.save_images_and_return_uris(image_bytes_list)
        if sketch_image_full_uris_list:
            image_full_uris.extend(sketch_image_full_uris_list)
        if edit_image_full_uris_list:
            image_full_uris.extend(edit_image_full_uris_list)

    @staticmethod
    def _handle_edit_image(request):
        edit_image_bytes_dict = {'edit_image': None, 'edit_image_mask': None}
        attached_edit_image = request.FILES.get('edit_image')
        attached_edit_image_mask = request.POST.get('edit_image_mask')
        edit_image_full_uris_list = []
        try:
            edit_image_bytes = attached_edit_image.read()
            edit_image_mask_bytes = base64.b64decode(attached_edit_image_mask.split("base64,")[1].encode())
            edit_image_bytes_dict['edit_image'] = edit_image_bytes
            edit_image_bytes_dict['edit_image_mask'] = edit_image_mask_bytes
            edit_image_full_uris_list = MediaManager.save_edit_image_and_masked_image(
                edit_img_map=edit_image_bytes_dict)
            logger.info(f"Edit image was saved successfully.")
        except Exception as e:
            logger.error(f"Edit image was not saved successfully.")
            pass
        return edit_image_full_uris_list

    @staticmethod
    def _handle_sketch_image(request):
        sketch_image = {'sketch_image': None}
        attached_canvas_image = request.POST.get('sketch_image')
        sketch_image_full_uris_list = []
        try:
            sketch_image_bytes = base64.b64decode(attached_canvas_image.split("base64,")[1].encode())
            sketch_image['sketch_image'] = sketch_image_bytes
            sketch_image_full_uris_list = MediaManager.save_sketch(sketch_data_map=sketch_image)
            logger.info(f"Sketch image was saved successfully.")
        except Exception as e:
            logger.error(f"Sketch image was not saved successfully.")
            pass
        return sketch_image_full_uris_list


Contents of ../../apps/orchestrations/views/query/detail_orchestration_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_orchestration_query_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models.query import OrchestrationQuery
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class OrchestrationView_QueryDetail(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_ORCHESTRATION_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_AND_USE_ORCHESTRATION_CHATS):
            messages.error(self.request, "You do not have permission to create and use orchestration queries.")
            return context
        ##############################

        query_id = self.kwargs.get('query_id')
        query = get_object_or_404(OrchestrationQuery, id=query_id)
        context['query'] = query
        context['logs'] = query.logs.all()
        logger.info(f"Orchestration query was viewed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/orchestrations/views/query/delete_orchestration_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_orchestration_query_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models.query import OrchestrationQuery
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class OrchestrationView_QueryDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        query_id = self.kwargs['query_id']
        context['query'] = get_object_or_404(OrchestrationQuery, pk=query_id)
        context['orchestration'] = context['query'].maestro
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - REMOVE_ORCHESTRATION_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_ORCHESTRATION_CHATS):
            messages.error(self.request, "You do not have permission to remove orchestration queries.")
            return redirect('orchestrations:list')
        ##############################

        query_id = self.kwargs['query_id']
        query = get_object_or_404(OrchestrationQuery, pk=query_id)
        maestro_id = query.maestro.id

        try:
            query.delete()
        except Exception as e:
            messages.error(request, f"An error occurred while deleting the Orchestration Query: {str(e)}")
            return redirect("orchestrations:query_list", pk=maestro_id)

        logger.info(f"Orchestration query was deleted by User: {self.request.user.id}.")
        return redirect('orchestrations:query_list', pk=maestro_id)


Contents of ../../apps/orchestrations/views/query/rerun_orchestration_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: rerun_orchestration_query_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.orchestration.orchestration_executor import OrchestrationExecutor
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models import OrchestrationQueryLog
from apps.orchestrations.models.query import OrchestrationQuery
from apps.orchestrations.utils import OrchestrationQueryLogTypesNames
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class OrchestrationView_QueryRerun(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        #############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_ORCHESTRATION_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_AND_USE_ORCHESTRATION_CHATS):
            messages.error(self.request, "You do not have permission to create and use orchestration queries.")
            return redirect('orchestrations:list')
        ##############################

        query_id = self.kwargs.get('query_id')
        query = get_object_or_404(OrchestrationQuery, id=query_id)
        query_text = query.query_text
        attached_images = request.FILES.getlist('attached_images[]', [])
        attached_files = request.FILES.getlist('attached_files[]', [])

        try:
            query.logs.all().delete()
            query_log = OrchestrationQueryLog.objects.create(
                orchestration_query=query, log_type=OrchestrationQueryLogTypesNames.USER,
                log_text_content=query_text + f"""
                            -----

                            **IMAGE URLS:**
                            '''
                            {attached_images}
                            '''

                            -----

                            **FILE URLS:**
                            '''
                            {attached_files}
                            '''

                            -----
                        """, log_file_contents=attached_files, log_image_contents=attached_images)
            query.logs.add(query_log)
            query.save()

            orch_xc = OrchestrationExecutor(
                maestro=query.maestro,
                query_chat=query
            )
            final_response = orch_xc.execute_for_query()

        except Exception as e:
            messages.error(request, f"An error occurred while rerunning the Orchestration Query: {str(e)}")
            return redirect("orchestrations:query_detail", pk=query.maestro.id, query_id=query.id)

        logger.info(f"Orchestration query was rerun by User: {self.request.user.id}.")
        return redirect('orchestrations:query_detail', pk=query.maestro.id, query_id=query.id)


Contents of ../../apps/orchestrations/views/query/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .rerun_orchestration_query_views import *
from .delete_orchestration_query_views import *
from .detail_orchestration_query_views import *
from .list_orchestration_queries_views import *


Contents of ../../apps/integrations/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-05 19:21:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-05 19:21:16
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .list_integration_categories_views import *
from .store_integration_category_views import *
from .integrate_assistant_to_organization_views import *


Contents of ../../apps/integrations/views/integrate_assistant_to_organization_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: integrate_assistant_to_organization_views.py
#  Last Modified: 2024-11-05 20:12:33
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-05 20:12:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.datasource_codebase.models import CodeRepositoryStorageConnection, CodeBaseRepository, \
    CodeBaseRepositoryChunk
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection, KnowledgeBaseDocument, \
    KnowledgeBaseDocumentChunk
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection, DataSourceMediaStorageItem
from apps.datasource_ml_models.models import DataSourceMLModelConnection, DataSourceMLModelItem
from apps.datasource_nosql.models import NoSQLDatabaseConnection, CustomNoSQLQuery
from apps.datasource_sql.models import SQLDatabaseConnection, CustomSQLQuery
from apps.hadron_prime.models import HadronNodeAssistantConnection
from apps.integrations.models import AssistantIntegrationCategory, AssistantIntegration
from apps.llm_core.models import LLMCore
from apps.metakanban.models import MetaKanbanAssistantConnection
from apps.metatempo.models import MetaTempoAssistantConnection
from apps.orchestrations.models import OrchestrationReactantAssistantConnection
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection


logger = logging.getLogger(__name__)


class IntegrationView_IntegrateAssistantToOrganization(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        #############################################################################################################
        #  USER DEFINED PROPERTIES
        #############################################################################################################
        # Configuration:
        #   i. organization
        #   ii. llm_model
        #############################################################################################################
        #  DATA SOURCE ADDITIONS (A 'DUPLICATE' of the data source connection must be created) (OPTIONAL)
        #############################################################################################################
        # i. Web Browsers (Optional) -- (WEB)
        # ii. SSH File Systems (Optional) -- (SSH)
        # iii. SQL Databases (Optional) -- (SQL)
        # iv. NoSQL Databases (Optional) -- (NOSQL)
        # v. Knowledge Bases (Optional) -- (KB + DOCS)
        # vi. Code Bases (Optional) -- (CODE)
        # vii. Media Storages (Optional) -- (MEDIA + FILES)
        # viii. ML models (Optional) -- (ML)
        # ix. Video Generators (Optional) -- (VID)
        # x. Projects (Optional) -- (PROJECT)
        # _
        # _____ new _____
        # _
        # xi. Hadron Node <> Assistant Connections
        # xii. MetaKanban <> Assistant Connections
        # xiii. MetaTempo <> Assistant Connections
        # xiv. Orchestration <> Assistant Connections
        #############################################################################################################
        # MULTI-MODALITIES (Can be later MODIFIED BY USER, but on creation content PASSED FROM BIMOD STAFF) (OPTIONAL)
        #############################################################################################################
        # i. Custom Functions
        # ii. Custom APIs
        # iii. Custom Scripts
        #############################################################################################################

        category_id = request.POST.get('category_id')
        category = AssistantIntegrationCategory.objects.get(id=category_id)
        user = request.user

        ##############################
        # PERMISSION CHECK FOR - INTEGRATE_PLUG_AND_PLAY_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.INTEGRATE_PLUG_AND_PLAY_AGENTS):
            messages.error(self.request, "You do not have permission to integrate plug-and-play agents.")
            return redirect('integrations:store', category_slug=category.category_slug)
        ##############################

        integration_id = request.POST.get('integration_id')
        integration_data = AssistantIntegration.objects.get(id=integration_id)

        organization_id = request.POST.get('organization')
        llm_model_id = request.POST.get('llm_model')
        web_browser_id = request.POST.get('web_browser')
        file_system_id = request.POST.get('file_system')
        sql_database_id = request.POST.get('sql_database')
        nosql_database_id = request.POST.get('nosql_database')
        knowledge_base_id = request.POST.get('knowledge_base')
        code_base_id = request.POST.get('code_base')
        media_storage_id = request.POST.get('media_storage')
        ml_storage_id = request.POST.get('ml_storage')
        video_generator_id = request.POST.get('video_generator')
        project_item_id = request.POST.get('project_item')
        hadron_node_conn_id = request.POST.get('hadron_node')
        metakanban_conn_id = request.POST.get('metakanban')
        metatempo_conn_id = request.POST.get('metatempo')
        orchestration_conn_id = request.POST.get('orchestration')

        print("Hadron node id: ", hadron_node_conn_id)
        print("MetaKanban id: ", metakanban_conn_id)
        print("MetaTempo id: ", metatempo_conn_id)
        print("Orchestration id: ", orchestration_conn_id)

        organization = Organization.objects.get(id=organization_id)
        llm_model = LLMCore.objects.get(id=llm_model_id)

        web_browser = None
        if web_browser_id:
            web_browser = DataSourceBrowserConnection.objects.get(id=web_browser_id)
        file_system = None
        if file_system_id:
            file_system = DataSourceFileSystem.objects.get(id=file_system_id)
        sql_database = None
        if sql_database_id:
            sql_database = SQLDatabaseConnection.objects.get(id=sql_database_id)
        nosql_database = None
        if nosql_database_id:
            nosql_database = NoSQLDatabaseConnection.objects.get(id=nosql_database_id)
        knowledge_base = None
        if knowledge_base_id:
            knowledge_base = DocumentKnowledgeBaseConnection.objects.get(id=knowledge_base_id)
        code_base = None
        if code_base_id:
            code_base = CodeRepositoryStorageConnection.objects.get(id=code_base_id)
        media_storage = None
        if media_storage_id:
            media_storage = DataSourceMediaStorageConnection.objects.get(id=media_storage_id)
        ml_storage = None
        if ml_storage_id:
            ml_storage = DataSourceMLModelConnection.objects.get(id=ml_storage_id)
        video_generator = None
        if video_generator_id:
            video_generator = VideoGeneratorConnection.objects.get(id=video_generator_id)
        project_item = None
        if project_item_id:
            project_item = ProjectItem.objects.get(id=project_item_id)
        hadron_node = None
        if hadron_node_conn_id:
            hadron_node = HadronNodeAssistantConnection.objects.get(id=hadron_node_conn_id)
        metakanban = None
        if metakanban_conn_id:
            metakanban = MetaKanbanAssistantConnection.objects.get(id=metakanban_conn_id)
        metatempo = None
        if metatempo_conn_id:
            metatempo = MetaTempoAssistantConnection.objects.get(id=metatempo_conn_id)
        orchestration = None
        if orchestration_conn_id:
            orchestration = OrchestrationReactantAssistantConnection.objects.get(id=orchestration_conn_id)

        # Step 1: Create the assistant
        created_assistant = Assistant.objects.create(
            organization=organization,
            llm_model=llm_model,
            name=integration_data.integration_name,
            description=integration_data.integration_description,
            instructions=integration_data.integration_instructions,
            response_template=integration_data.integration_response_template,
            audience=integration_data.integration_audience,
            tone=integration_data.integration_tone,
            assistant_image=integration_data.integration_assistant_image,
            max_retry_count=integration_data.integration_max_retries,
            tool_max_attempts_per_instance=integration_data.integration_max_tool_retries,
            tool_max_chains=integration_data.integration_max_tool_pipelines,
            max_context_messages=integration_data.integration_max_message_memory,
            time_awareness=integration_data.integration_time_awareness,
            place_awareness=integration_data.integration_location_awareness,
            multi_step_reasoning_capability_choice=integration_data.integration_multi_step_reasoning,
            image_generation_capability=integration_data.integration_image_generation_capability,
            context_overflow_strategy=integration_data.integration_context_overflow_strategy,
            response_language=integration_data.integration_response_language,
            glossary=integration_data.integration_glossary,
            ner_integration=integration_data.ner_integration,
            created_by_user=user,
            last_updated_by_user=user
        )
        if project_item:
            created_assistant.project_items.set([project_item])
        created_assistant.save()

        # Step 2: Create a copy of the web browser
        try:
            if web_browser:
                duplicated_web_browser = web_browser
                duplicated_web_browser.pk = None
                duplicated_web_browser.assistant = created_assistant
                duplicated_web_browser.created_by_user = user
                duplicated_web_browser.save()
                created_assistant.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the web browser.')
            logger.error(f"Error occurred while integrating the web browser: {e}")

        # Step 3: Create a copy of the file system
        try:
            if file_system:
                duplicated_file_system = file_system
                duplicated_file_system.pk = None
                duplicated_file_system.assistant = created_assistant
                duplicated_file_system.created_by_user = user
                duplicated_file_system.save()
                created_assistant.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the file system.')
            logger.error(f"Error occurred while integrating the file system: {e}")

        # Step 4: Create a copy of the video generator
        try:
            if video_generator:
                duplicated_video_generator = video_generator
                duplicated_video_generator.pk = None
                duplicated_video_generator.organization = organization
                duplicated_video_generator.assistant = created_assistant
                duplicated_video_generator.created_by_user = user
                duplicated_video_generator.save()
                created_assistant.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the video generator.')
            logger.error(f"Error occurred while integrating the video generator: {e}")

        # Step 5: Create a copy of the SQL database
        try:
            if sql_database:
                sql_database: SQLDatabaseConnection
                duplicated_sql_database = sql_database
                duplicated_sql_database.pk = None
                duplicated_sql_database.assistant = created_assistant
                duplicated_sql_database.created_by_user = user
                duplicated_sql_database.save()
                created_assistant.save()

                sql_queries = sql_database.custom_queries.all()
                for sql_query in sql_queries:
                    sql_query: CustomSQLQuery
                    duplicated_sql_query = sql_query
                    duplicated_sql_query: CustomSQLQuery
                    duplicated_sql_query.pk = None
                    duplicated_sql_query.database_connection = duplicated_sql_database
                    duplicated_sql_query.save()
                    duplicated_sql_database.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the SQL database.')
            logger.error(f"Error occurred while integrating the SQL database: {e}")

        # Step 6: Create a copy of the NoSQL database
        try:
            if nosql_database:
                nosql_database: NoSQLDatabaseConnection
                duplicated_nosql_database = nosql_database
                duplicated_nosql_database.pk = None
                duplicated_nosql_database.assistant = created_assistant
                duplicated_nosql_database.created_by_user = user
                duplicated_nosql_database.save()
                created_assistant.save()

                nosql_queries = nosql_database.custom_queries.all()
                for nosql_query in nosql_queries:
                    nosql_query: CustomNoSQLQuery
                    duplicated_nosql_query = nosql_query
                    duplicated_nosql_query: CustomNoSQLQuery
                    duplicated_nosql_query.pk = None
                    duplicated_nosql_query.database_connection = duplicated_nosql_database
                    duplicated_nosql_query.save()
                    duplicated_nosql_database.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the NoSQL database.')
            logger.error(f"Error occurred while integrating the NoSQL database: {e}")

        # Step 7: Create a copy of the knowledge base
        try:
            if knowledge_base:
                knowledge_base: DocumentKnowledgeBaseConnection
                duplicated_knowledge_base = knowledge_base
                duplicated_knowledge_base: DocumentKnowledgeBaseConnection
                duplicated_knowledge_base.pk = None
                duplicated_knowledge_base.assistant = created_assistant
                duplicated_knowledge_base.save()
                created_assistant.save()

                kb_documents = knowledge_base.knowledge_base_documents.all()
                for kb_document in kb_documents:
                    kb_document: KnowledgeBaseDocument
                    duplicated_kb_document = kb_document
                    duplicated_kb_document: KnowledgeBaseDocument
                    duplicated_kb_document.pk = None
                    duplicated_kb_document.knowledge_base = duplicated_knowledge_base
                    duplicated_kb_document.save()
                    duplicated_knowledge_base.save()

                    kb_document_chunks = kb_document.document_chunks.all()
                    for kb_document_chunk in kb_document_chunks:
                        kb_document_chunk: KnowledgeBaseDocumentChunk
                        duplicated_kb_document_chunk = kb_document_chunk
                        duplicated_kb_document_chunk: KnowledgeBaseDocumentChunk
                        duplicated_kb_document_chunk.pk = None
                        duplicated_kb_document_chunk.document = duplicated_kb_document
                        duplicated_kb_document_chunk.save()
                        duplicated_kb_document.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the knowledge base.')
            logger.error(f"Error occurred while integrating the knowledge base: {e}")

        # Step 8: Create a copy of the code base
        try:
            if code_base:
                code_base: CodeRepositoryStorageConnection
                duplicated_code_base = code_base
                duplicated_code_base: CodeRepositoryStorageConnection
                duplicated_code_base.pk = None
                duplicated_code_base.assistant = created_assistant
                duplicated_code_base.save()
                created_assistant.save()

                code_repos = code_base.code_base_repositories.all()
                for code_repo in code_repos:
                    code_repo: CodeBaseRepository
                    duplicated_code_repo = code_repo
                    duplicated_code_repo: CodeBaseRepository
                    duplicated_code_repo.pk = None
                    duplicated_code_repo.knowledge_base = duplicated_code_base
                    duplicated_code_repo.save()
                    duplicated_code_base.save()

                    code_repo_chunks = code_repo.repository_chunks.all()
                    for code_repo_chunk in code_repo_chunks:
                        code_repo_chunk: CodeBaseRepositoryChunk
                        duplicated_code_repo_chunk = code_repo_chunk
                        duplicated_code_repo_chunk: CodeBaseRepositoryChunk
                        duplicated_code_repo_chunk.pk = None
                        duplicated_code_repo_chunk.repository = duplicated_code_repo
                        duplicated_code_repo_chunk.save()
                        duplicated_code_repo.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the code base.')
            logger.error(f"Error occurred while integrating the code base: {e}")

        # Step 9: Create a copy of the media storage
        try:
            if media_storage:
                media_storage: DataSourceMediaStorageConnection
                duplicated_media_storage = media_storage
                duplicated_media_storage: DataSourceMediaStorageConnection
                duplicated_media_storage.pk = None
                duplicated_media_storage.assistant = created_assistant
                duplicated_media_storage.save()
                created_assistant.save()

                media_files = media_storage.items.all()
                for media_file in media_files:
                    media_file: DataSourceMediaStorageItem
                    duplicated_media_file = media_file
                    duplicated_media_file: DataSourceMediaStorageItem
                    duplicated_media_file.pk = None
                    duplicated_media_file.storage_base = duplicated_media_storage
                    duplicated_media_file.save()
                    duplicated_media_storage.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the media storage.')
            logger.error(f"Error occurred while integrating the media storage: {e}")

        # Step 10: Create a copy of the ML storage
        try:
            if ml_storage:
                ml_storage: DataSourceMLModelConnection
                duplicated_ml_storage = ml_storage
                duplicated_ml_storage: DataSourceMLModelConnection
                duplicated_ml_storage.pk = None
                duplicated_ml_storage.assistant = created_assistant
                duplicated_ml_storage.save()
                created_assistant.save()

                ml_models = ml_storage.items.all()
                for ml_model in ml_models:
                    ml_model: DataSourceMLModelItem
                    duplicated_ml_model = ml_model
                    duplicated_ml_model: DataSourceMLModelItem
                    duplicated_ml_model.pk = None
                    duplicated_ml_model.ml_model_base = duplicated_ml_storage
                    duplicated_ml_model.save()
                    duplicated_ml_storage.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the ML storage.')
            logger.error(f"Error occurred while integrating the ML storage: {e}")

        # Step 11: Create a copy of the Hadron Node connection
        try:
            if hadron_node:
                hadron_node: HadronNodeAssistantConnection
                duplicated_hadron_node = hadron_node
                duplicated_hadron_node: HadronNodeAssistantConnection
                duplicated_hadron_node.pk = None
                duplicated_hadron_node.assistant = created_assistant
                duplicated_hadron_node.save()
                created_assistant.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the Hadron Node <> Assistant connection.')
            logger.error(f"Error occurred while integrating the Hadron Node <> Assistant connection: {e}")

        # Step 12: Create a copy of the MetaKanban connection
        try:
            if metakanban:
                metakanban: MetaKanbanAssistantConnection
                duplicated_metakanban = metakanban
                duplicated_metakanban: MetaKanbanAssistantConnection
                duplicated_metakanban.pk = None
                duplicated_metakanban.assistant = created_assistant
                duplicated_metakanban.save()
                created_assistant.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the MetaKanban <> Assistant connection.')
            logger.error(f"Error occurred while integrating the MetaKanban <> Assistant connection: {e}")

        # Step 13: Create a copy of the MetaTempo connection
        try:
            if metatempo:
                metatempo: MetaTempoAssistantConnection
                duplicated_metatempo = metatempo
                duplicated_metatempo: MetaTempoAssistantConnection
                duplicated_metatempo.pk = None
                duplicated_metatempo.assistant = created_assistant
                duplicated_metatempo.save()
                created_assistant.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the MetaTempo <> Assistant connection.')
            logger.error(f"Error occurred while integrating the MetaTempo <> Assistant connection: {e}")

        # Step 14: Create a copy of the Orchestration connection
        try:
            if orchestration:
                orchestration: OrchestrationReactantAssistantConnection
                duplicated_orchestration = orchestration
                duplicated_orchestration: OrchestrationReactantAssistantConnection
                duplicated_orchestration.pk = None
                duplicated_orchestration.assistant = created_assistant
                duplicated_orchestration.save()
                created_assistant.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the Orchestration <> Assistant connection.')
            logger.error(f"Error occurred while integrating the Orchestration <> Assistant connection: {e}")

        messages.success(request, 'Assistant has been integrated to the organization successfully.')
        return redirect('integrations:store', category_slug=category.category_slug)


Contents of ../../apps/integrations/views/store_integration_category_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: store_integration_category_views.py
#  Last Modified: 2024-11-05 19:46:44
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-05 19:46:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.datasource_codebase.models import CodeRepositoryStorageConnection
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection
from apps.datasource_ml_models.models import DataSourceMLModelConnection
from apps.datasource_nosql.models import NoSQLDatabaseConnection
from apps.datasource_sql.models import SQLDatabaseConnection
from apps.hadron_prime.models import HadronNodeAssistantConnection
from apps.integrations.models import AssistantIntegration, AssistantIntegrationCategory
from apps.llm_core.models import LLMCore
from apps.metakanban.models import MetaKanbanAssistantConnection
from apps.metatempo.models import MetaTempoAssistantConnection
from apps.orchestrations.models import OrchestrationReactantAssistantConnection
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection
from web_project import TemplateLayout


class IntegrationView_IntegrationCategoryStore(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_PLUG_AND_PLAY_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_PLUG_AND_PLAY_AGENTS):
            messages.error(self.request, "You do not have permission to list plug and play agents.")
            return context
        ##############################

        category = AssistantIntegrationCategory.objects.get(category_slug=self.kwargs['category_slug'])

        user_organizations = Organization.objects.filter(users__in=[self.request.user])
        llm_models = LLMCore.objects.filter(organization__in=user_organizations)
        web_browsers = DataSourceBrowserConnection.objects.filter(assistant__organization__in=user_organizations)
        ssh_file_systems = DataSourceFileSystem.objects.filter(assistant__organization__in=user_organizations)
        sql_databases = SQLDatabaseConnection.objects.filter(assistant__organization__in=user_organizations)
        nosql_databases = NoSQLDatabaseConnection.objects.filter(assistant__organization__in=user_organizations)
        knowledge_bases = DocumentKnowledgeBaseConnection.objects.filter(assistant__organization__in=user_organizations)
        code_bases = CodeRepositoryStorageConnection.objects.filter(assistant__organization__in=user_organizations)
        media_storages = DataSourceMediaStorageConnection.objects.filter(assistant__organization__in=user_organizations)
        ml_storages = DataSourceMLModelConnection.objects.filter(assistant__organization__in=user_organizations)
        video_generators = VideoGeneratorConnection.objects.filter(assistant__organization__in=user_organizations)
        project_items = ProjectItem.objects.filter(organization__in=user_organizations)
        hadron_node_connections = HadronNodeAssistantConnection.objects.filter(assistant__organization__in=user_organizations)
        metakanban_connections = MetaKanbanAssistantConnection.objects.filter(assistant__organization__in=user_organizations)
        metatempo_connections = MetaTempoAssistantConnection.objects.filter(assistant__organization__in=user_organizations)
        orchestration_connections = OrchestrationReactantAssistantConnection.objects.filter(assistant__organization__in=user_organizations)

        integrations = AssistantIntegration.objects.filter(integration_category__category_slug=self.kwargs['category_slug']).order_by("integration_name")
        context['category'] = category
        context['organizations'] = user_organizations
        context['assistants'] = integrations
        context['llm_models'] = llm_models
        context['web_browsers'] = web_browsers
        context['ssh_file_systems'] = ssh_file_systems
        context['sql_databases'] = sql_databases
        context['nosql_databases'] = nosql_databases
        context['knowledge_bases'] = knowledge_bases
        context['code_bases'] = code_bases
        context['media_storages'] = media_storages
        context['ml_storages'] = ml_storages
        context['video_generators'] = video_generators
        context['project_items'] = project_items
        context['hadron_node_connections'] = hadron_node_connections
        context['metakanban_connections'] = metakanban_connections
        context['metatempo_connections'] = metatempo_connections
        context['orchestration_connections'] = orchestration_connections
        return context


Contents of ../../apps/integrations/views/list_integration_categories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_integration_categories_views.py
#  Last Modified: 2024-11-05 19:46:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-05 19:46:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.integrations.models import AssistantIntegrationCategory
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class IntegrationView_IntegrationCategoriesList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_PLUG_AND_PLAY_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_PLUG_AND_PLAY_AGENTS):
            messages.error(self.request, "You do not have permission to list plug and play agents.")
            return context
        ##############################

        categories = AssistantIntegrationCategory.objects.all().order_by("category_name")
        context['categories'] = categories

        total_boiler_plate_agents = 0
        for category in categories:
            total_boiler_plate_agents += category.assistantintegration_set.count()
        context['total_agents'] = total_boiler_plate_agents

        return context


Contents of ../../apps/metatempo/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-28 19:35:07
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 19:35:08
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .board import *
from .connection import *
from .endpoints import *
from .agent import *
from .connect_assistant import *


Contents of ../../apps/metatempo/views/endpoints/get_metatempo_connection_config_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: get_metatempo_connection_config_views.py
#  Last Modified: 2024-10-28 22:26:45
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 22:26:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.metatempo.models import MetaTempoConnection


@method_decorator(csrf_exempt, name='dispatch')
class MetaTempoView_GetConnectionConfig(View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        api_key = request.POST.get('api_key')
        if not api_key:
            return JsonResponse({"success": False, "error": "API key is required."}, status=400)

        if "Bearer" in api_key:
            api_key = api_key.replace("Bearer", "").strip()

        try:
            connection = MetaTempoConnection.objects.get(connection_api_key=api_key)
        except MetaTempoConnection.DoesNotExist:
            return JsonResponse({"success": False, "error": "Connection not found."}, status=404)

        connection_data = {
            "board": connection.board.title,
            "is_tracking_active": connection.is_tracking_active,
            "optional_context_instructions": connection.optional_context_instructions or "",
            "overall_log_intervals": connection.overall_log_intervals,
            "member_log_intervals": connection.member_log_intervals,
            "tracked_weekdays": connection.tracked_weekdays if connection.tracked_weekdays else [],
            "tracking_start_time": connection.tracking_start_time.strftime(
                '%H:%M') if connection.tracking_start_time else None,
            "tracking_end_time": connection.tracking_end_time.strftime(
                '%H:%M') if connection.tracking_end_time else None,
            "connection_api_key": connection.connection_api_key,
            "created_by_user": connection.created_by_user.username if connection.created_by_user else None,
            "created_at": connection.created_at.strftime('%Y-%m-%d %H:%M:%S'),
            "updated_at": connection.updated_at.strftime('%Y-%m-%d %H:%M:%S'),
        }

        return JsonResponse({"success": True, "data": connection_data}, status=200)


Contents of ../../apps/metatempo/views/endpoints/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-28 20:39:01
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:39:02
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .metatempo_screenshot_delivery_views import *
from .get_metatempo_connection_config_views import *


Contents of ../../apps/metatempo/views/endpoints/metatempo_screenshot_delivery_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: metatempo_screenshot_delivery_views.py
#  Last Modified: 2024-10-28 20:39:27
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:39:28
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import json
import logging

from django.contrib.auth.models import User
from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.generative_ai.utils import GPT_DEFAULT_ENCODING_ENGINE, ChatRoles
from apps.core.internal_cost_manager.costs_map import InternalServiceCosts
from apps.core.metatempo.metatempo_execution_handler import MetaTempoExecutionManager
from apps.llm_transaction.models import LLMTransaction
from apps.llm_transaction.utils import LLMTransactionSourcesTypesNames
from apps.metatempo.models import MetaTempoConnection, MetaTempoMemberLog

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class MetaTempoView_ScreenshotDelivery(View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        metatempo_user_auth_key = request.POST.get('metatempo_user_auth_key')
        metatempo_api_key = request.POST.get('metatempo_api_key')
        screenshot_image_png = request.FILES.get('screenshot_image_png')
        snapshot_metadata = request.POST.get('snapshot_metadata')

        if not metatempo_user_auth_key:
            logger.error("[metatempo_screenshot_delivery] metatempo_user_auth_key is required.")
            return JsonResponse({"success": False, "error": "metatempo_user_auth_key is required."}, status=400)

        if not metatempo_api_key:
            logger.error("[metatempo_screenshot_delivery] metatempo_api_key is required.")
            return JsonResponse({"success": False, "error": "metatempo_api_key is required."}, status=400)

        if not screenshot_image_png:
            logger.error("[metatempo_screenshot_delivery] screenshot_image_png is required.")
            return JsonResponse({"success": False, "error": "screenshot_image_png is required."}, status=400)
        if not snapshot_metadata:
            logger.error("[metatempo_screenshot_delivery] snapshot_metadata is required.")
            return JsonResponse({"success": False, "error": "snapshot_metadata is required."}, status=400)

        try:
            context_user = User.objects.filter(profile__metatempo_tracking_auth_key=metatempo_user_auth_key).first()
            if not context_user:
                logger.error("[metatempo_screenshot_delivery] User not found.")
                return JsonResponse({"success": False, "error": "User not found."}, status=404)
        except Exception as e:
            logger.error(f"[metatempo_screenshot_delivery] Error processing user auth key: {str(e)}")
            return JsonResponse({"success": False, "error": str(e)}, status = 500)

        try:
            if "Bearer" in metatempo_api_key:
                metatempo_api_key = metatempo_api_key.replace("Bearer", "").strip()
        except Exception as e:
            logger.error(f"[metatempo_screenshot_delivery] Error processing API key: {str(e)}")
            return JsonResponse({"success": False, "error": str(e)}, status=500)

        try:
            if "Bearer" in metatempo_user_auth_key:
                metatempo_user_auth_key = metatempo_user_auth_key.replace("Bearer", "").strip()
        except Exception as e:
            logger.error(f"[metatempo_screenshot_delivery] Error processing user auth key: {str(e)}")
            return JsonResponse({"success": False, "error": str(e)}, status=500)

        connection: MetaTempoConnection = MetaTempoConnection.objects.filter(
            connection_api_key=metatempo_api_key).first()
        if not connection:
            logger.error("[metatempo_screenshot_delivery] Connection not found.")
            return JsonResponse({"success": False, "error": "Connection not found."}, status=404)
        if connection.connection_api_key != metatempo_api_key:
            logger.error("[metatempo_screenshot_delivery] Invalid API Key.")
            return JsonResponse({"success": False, "error": "Invalid API Key."}, status=401)

        if connection.is_tracking_active is False:
            logger.error("[metatempo_screenshot_delivery] Tracking is not active for this board.")
            return JsonResponse({"success": False, "error": "Tracking is not active for this board."}, status=403)

        try:
            snapshot_metadata = json.loads(snapshot_metadata)
            if 'timestamp' not in snapshot_metadata:
                logger.error("[metatempo_screenshot_delivery] timestamp is required in snapshot metadata.")
                return JsonResponse({"success": False, "error": "timestamp is required in snapshot metadata."}, status=400)
            if 'identifier_uuid' not in snapshot_metadata:
                logger.error("[metatempo_screenshot_delivery] identifier_uuid is required in snapshot metadata.")
                return JsonResponse({"success": False, "error": "identifier_uuid is required in snapshot metadata."}, status=400)
        except Exception as e:
            logger.error(f"[metatempo_screenshot_delivery] Error processing snapshot metadata: {str(e)}")
            snapshot_metadata = {}

        identifier_uuid = snapshot_metadata.get('identifier_uuid')
        try:
            exists = MetaTempoMemberLog.objects.filter(identifier_uuid=identifier_uuid)
            if exists:
                logger.error("[metatempo_screenshot_delivery] This record has already been saved.")
                return JsonResponse({"success": True, "error": "This record has already been saved."}, status=200)
        except Exception as e:
            logger.error(f"[metatempo_screenshot_delivery] Error processing identifier_uuid: {str(e)}")
            return JsonResponse({"success": False, "error": str(e)}, status=500)

        try:
            xc = MetaTempoExecutionManager(metatempo_connection_id=connection.id)
            result, error = xc.interpret_and_save_log_snapshot(snapshot_metadata=snapshot_metadata,
                                                               log_screenshot_data=screenshot_image_png.read(),
                                                               context_user=context_user)

            if error:
                logger.error(f"[metatempo_screenshot_delivery] Error processing screenshot: {error}")
                return JsonResponse({"success": False, "error": error}, status=500)
        except Exception as e:
            logger.error(f"[metatempo_screenshot_delivery] Exception occurred: {str(e)}")
            return JsonResponse({"success": False, "error": str(e)}, status=500)

        try:
            tx = LLMTransaction(
                organization=connection.board.project.organization, model=connection.board.llm_model,
                responsible_user=connection.board.created_by_user, responsible_assistant=None,
                encoding_engine=GPT_DEFAULT_ENCODING_ENGINE, llm_cost=InternalServiceCosts.MetaTempo.COST,
                transaction_type=ChatRoles.SYSTEM,
                transaction_source=LLMTransactionSourcesTypesNames.METATEMPO, is_tool_cost=True
            )
            tx.save()
            logger.info(f"[metatempo_screenshot_delivery] Created LLMTransaction for MetaTempo Screenshot Log.")
        except Exception as e:
            logger.error(
                f"[metatempo_screenshot_delivery] Error creating LLMTransaction for Screenshot Log. Error: {e}")
            pass

        return JsonResponse({"success": True, "error": None}, status=200)


Contents of ../../apps/metatempo/views/connection/list_metatempo_connections_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_metatempo_connections_views.py
#  Last Modified: 2024-10-28 20:29:23
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:29:24
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metatempo.models import MetaTempoConnection
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaTempoView_ConnectionList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_METATEMPO_CONNECTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_METATEMPO_CONNECTION):
            messages.error(self.request, "You do not have permission to list MetaTempo Connections.")
            return context
        ##############################

        user = self.request.user
        org_projects_connections = {}

        organizations = Organization.objects.filter(users__in=[user])
        for organization in organizations:
            projects = ProjectItem.objects.filter(organization=organization)
            project_connections = {}
            for project in projects:
                connections = MetaTempoConnection.objects.filter(board__project=project)
                project_connections[project] = connections
            org_projects_connections[organization] = project_connections

        context['org_projects_connections'] = org_projects_connections
        return context


Contents of ../../apps/metatempo/views/connection/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-28 20:31:45
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:31:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .create_metatempo_connection_views import *
from .list_metatempo_connections_views import *
from .confirm_delete_metatempo_connection_views import *
from .update_metatempo_connection_views import *
from .metatempo_regenerate_api_key_views import *


Contents of ../../apps/metatempo/views/connection/create_metatempo_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_metatempo_connection_views.py
#  Last Modified: 2024-10-28 20:29:06
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:29:07
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import secrets

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard
from apps.metatempo.models import MetaTempoConnection
from apps.metatempo.utils import METATEMPO_MEMBER_LOG_INTERVALS, METATEMPO_OVERALL_LOG_INTERVALS, \
    META_TEMPO_CONNECTION_API_KEY_DEFAULT_LENGTH
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaTempoView_ConnectionCreate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        user_projects = ProjectItem.objects.filter(organization__in=user_orgs)
        context['boards'] = MetaKanbanBoard.objects.filter(project__in=user_projects)
        context['METATEMPO_OVERALL_LOG_INTERVALS'] = METATEMPO_OVERALL_LOG_INTERVALS
        context['METATEMPO_MEMBER_LOG_INTERVALS'] = METATEMPO_MEMBER_LOG_INTERVALS
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_METATEMPO_CONNECTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_METATEMPO_CONNECTION):
            messages.error(self.request, "You do not have permission to create a MetaTempo Connection.")
            return redirect('metatempo:connection_list')
        ##############################

        board_id = request.POST.get("board")
        is_tracking_active = request.POST.get("is_tracking_active") == "True"
        overall_log_intervals = request.POST.get("overall_log_intervals")
        member_log_intervals = request.POST.get("member_log_intervals")
        tracked_weekdays = request.POST.getlist("tracked_weekdays")
        tracking_start_time = request.POST.get("tracking_start_time")
        tracking_end_time = request.POST.get("tracking_end_time")
        connection_api_key = str(secrets.token_urlsafe(META_TEMPO_CONNECTION_API_KEY_DEFAULT_LENGTH))
        optional_context_instructions = request.POST.get("optional_context_instructions")

        board = MetaKanbanBoard.objects.get(id=board_id)

        try:
            MetaTempoConnection.objects.create(
                board=board,
                is_tracking_active=is_tracking_active,
                overall_log_intervals=overall_log_intervals,
                member_log_intervals=member_log_intervals,
                tracked_weekdays=tracked_weekdays,
                tracking_start_time=tracking_start_time,
                tracking_end_time=tracking_end_time,
                connection_api_key=connection_api_key,
                created_by_user=request.user,
                optional_context_instructions=optional_context_instructions
            )
        except Exception as e:
            messages.error(request, f"MetaTempo Connection creation failed. Error: {e}")
            return redirect("metatempo:connection_list")

        messages.success(request, "MetaTempo Connection created successfully.")
        return redirect("metatempo:connection_list")


Contents of ../../apps/metatempo/views/connection/confirm_delete_metatempo_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: confirm_delete_metatempo_connection_views.py
#  Last Modified: 2024-10-28 20:29:36
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:29:36
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metatempo.models import MetaTempoConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaTempoView_ConnectionConfirmDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        connection_id = kwargs['connection_id']
        connection = get_object_or_404(MetaTempoConnection, id=connection_id)
        context['connection'] = connection
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_METATEMPO_CONNECTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_METATEMPO_CONNECTION):
            messages.error(self.request, "You do not have permission to delete a MetaTempo Connection.")
            return redirect('metatempo:connection_list')
        ##############################

        connection_id = kwargs['connection_id']
        connection = get_object_or_404(MetaTempoConnection, id=connection_id)

        try:
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection: " + str(e))
            return redirect("metatempo:connection_list")

        messages.success(request, "MetaTempo Connection deleted successfully.")
        return redirect("metatempo:connection_list")


Contents of ../../apps/metatempo/views/connection/metatempo_regenerate_api_key_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: metakanban_regenerate_api_key_views.py
#  Last Modified: 2024-10-28 20:32:10
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:32:11
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import secrets

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metatempo.models import MetaTempoConnection
from apps.metatempo.utils import META_TEMPO_CONNECTION_API_KEY_DEFAULT_LENGTH
from apps.user_permissions.utils import PermissionNames


class MetaTempoView_ConnectionRegenerateAPIKey(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_METATEMPO_CONNECTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_METATEMPO_CONNECTION):
            messages.error(self.request, "You do not have permission to update a MetaTempo Connection.")
            return JsonResponse({'error': 'You do not have permission to update a MetaTempo Connection.'}, status=403)
        ##############################

        connection_id = kwargs.get('connection_id')
        if not connection_id:
            messages.error(request, "Connection ID not provided.")
            return JsonResponse({'error': 'Connection ID not provided.'}, status=400)
        try:
            connection = MetaTempoConnection.objects.get(id=connection_id)
            new_api_key = secrets.token_urlsafe(META_TEMPO_CONNECTION_API_KEY_DEFAULT_LENGTH)
            connection.connection_api_key = new_api_key
            connection.save()
        except MetaTempoConnection.DoesNotExist:
            messages.error(request, "Connection not found.")
            return JsonResponse({'error': 'Connection not found.'}, status=404)
        except Exception as e:
            messages.error(request, "Failed to regenerate API key.")
            return JsonResponse({'error': 'Failed to regenerate API key.'}, status=500)

        messages.success(request, "API key regenerated successfully.")
        return JsonResponse({'new_token': new_api_key}, status=200)


Contents of ../../apps/metatempo/views/connection/update_metatempo_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_metatempo_connection_views.py
#  Last Modified: 2024-10-28 20:29:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:29:16
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard
from apps.metatempo.models import MetaTempoConnection
from apps.metatempo.utils import METATEMPO_OVERALL_LOG_INTERVALS, METATEMPO_MEMBER_LOG_INTERVALS
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView


class MetaTempoView_ConnectionUpdate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        connection_id = kwargs['connection_id']
        connection = get_object_or_404(MetaTempoConnection, id=connection_id)

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        user_projects = ProjectItem.objects.filter(organization__in=user_orgs)

        context.update({
            'connection': connection,
            'boards': MetaKanbanBoard.objects.filter(project__in=user_projects),
            'METATEMPO_OVERALL_LOG_INTERVALS': METATEMPO_OVERALL_LOG_INTERVALS,
            'METATEMPO_MEMBER_LOG_INTERVALS': METATEMPO_MEMBER_LOG_INTERVALS,
        })
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_METATEMPO_CONNECTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_METATEMPO_CONNECTION):
            messages.error(self.request, "You do not have permission to update a MetaTempo Connection.")
            return redirect('metatempo:connection_list')
        ##############################

        connection_id = kwargs['connection_id']
        connection = get_object_or_404(MetaTempoConnection, id=connection_id)

        board_id = request.POST.get("board")
        is_tracking_active = request.POST.get("is_tracking_active") == "True"
        overall_log_intervals = request.POST.get("overall_log_intervals")
        member_log_intervals = request.POST.get("member_log_intervals")
        tracked_weekdays = request.POST.getlist("tracked_weekdays")
        tracking_start_time = request.POST.get("tracking_start_time")
        tracking_end_time = request.POST.get("tracking_end_time")
        optional_context_instructions = request.POST.get("optional_context_instructions")

        try:
            connection.board = MetaKanbanBoard.objects.get(id=board_id)
            connection.is_tracking_active = is_tracking_active
            connection.overall_log_intervals = overall_log_intervals
            connection.member_log_intervals = member_log_intervals
            connection.tracked_weekdays = tracked_weekdays
            connection.tracking_start_time = tracking_start_time
            connection.tracking_end_time = tracking_end_time
            connection.optional_context_instructions = optional_context_instructions
            connection.save()
        except Exception as e:
            messages.error(request, f"Failed to update MetaTempo Connection: {e}")
            return redirect("metatempo:connection_list")

        messages.success(request, "MetaTempo Connection updated successfully.")
        return redirect("metatempo:connection_list")


Contents of ../../apps/metatempo/views/board/metatempo_manual_analysis_trigger_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: metatempo_manual_analysis_trigger_views.py
#  Last Modified: 2024-10-28 20:31:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:31:16
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.generative_ai.utils import ChatRoles, GPT_DEFAULT_ENCODING_ENGINE
from apps.core.internal_cost_manager.costs_map import InternalServiceCosts
from apps.core.metatempo.metatempo_execution_handler import MetaTempoExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_transaction.models import LLMTransaction
from apps.llm_transaction.utils import LLMTransactionSourcesTypesNames
from apps.metatempo.models import MetaTempoConnection
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class MetaTempoView_TriggerManualAnalysis(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('connection_id')

        ##############################
        # PERMISSION CHECK FOR - USE_META_TEMPO_AI
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.USE_META_TEMPO_AI):
            messages.error(self.request, "You do not have permission to trigger manual analysis for a "
                                         "MetaTempo Connection.")
            return redirect('metatempo:main_board', connection_id=connection_id)
        ##############################

        try:
            connection = MetaTempoConnection.objects.get(id=connection_id)
            xc = MetaTempoExecutionManager(metatempo_connection_id=connection_id)
            result, error = xc.interpret_overall_logs()

            if error:
                logger.error(f"[interpret_overall_logs] Error processing overall analysis: {error}")
                return redirect('metatempo:main_board', connection_id=connection_id)
        except Exception as e:
            logger.error(f"[interpret_overall_logs] Exception occurred while creating the analysis: {str(e)}")
            return redirect('metatempo:main_board', connection_id=connection_id)

        try:
            tx = LLMTransaction(
                organization=connection.board.project.organization, model=connection.board.llm_model,
                responsible_user=connection.board.created_by_user, responsible_assistant=None,
                encoding_engine=GPT_DEFAULT_ENCODING_ENGINE, llm_cost=InternalServiceCosts.MetaTempo.COST,
                transaction_type=ChatRoles.SYSTEM,
                transaction_source=LLMTransactionSourcesTypesNames.METATEMPO, is_tool_cost=True
            )
            tx.save()
            logger.info(f"[interpret_overall_logs] Created LLMTransaction for MetaTempo [MANUAL] Overall Analysis Log.")
        except Exception as e:
            logger.error(
                f"[interpret_overall_logs] Error creating LLMTransaction for MetaTempo [MANUAL] Overall Analysis Log. Error: {e}")
            pass

        messages.success(request, f"Manual analysis has been successfully completed for the selected "
                                  f"MetaTempo connection.")
        return redirect('metatempo:main_board', connection_id=connection_id)


Contents of ../../apps/metatempo/views/board/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-28 20:31:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:31:31
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .metatempo_main_board_views import *
from .metatempo_purge_logs_views import *
from .metatempo_manual_analysis_trigger_views import *


Contents of ../../apps/metatempo/views/board/metatempo_purge_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: metatempo_purge_logs_views.py
#  Last Modified: 2024-10-28 20:30:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:30:32
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metatempo.models import MetaTempoMemberLog, MetaTempoMemberLogDaily, MetaTempoProjectOverallLog
from apps.user_permissions.utils import PermissionNames


class MetaTempoView_PurgeLogs(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get('connection_id')

        ##############################
        # PERMISSION CHECK FOR - DELETE_METATEMPO_CONNECTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_METATEMPO_CONNECTION):
            messages.error(self.request, "You do not have permission to delete MetaTempo Connection logs.")
            return redirect('metatempo:main_board', connection_id=connection_id)
        ##############################

        try:
            individual_logs_deleted, _ = MetaTempoMemberLog.objects.filter(
                metatempo_connection_id=connection_id).delete()
            daily_logs_deleted, _ = MetaTempoMemberLogDaily.objects.filter(
                metatempo_connection_id=connection_id).delete()
            overall_logs_deleted, _ = MetaTempoProjectOverallLog.objects.filter(
                metatempo_connection_id=connection_id).delete()
        except Exception as e:
            messages.error(request, f"Failed to purge logs for the selected MetaTempo connection. Error: {str(e)}")
            return redirect('metatempo:main_board', connection_id=connection_id)

        messages.success(request, f"All logs for the selected MetaTempo connection have been purged successfully.")
        return redirect('metatempo:main_board', connection_id=connection_id)


Contents of ../../apps/metatempo/views/board/metatempo_main_board_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: metatempo_main_board_views.py
#  Last Modified: 2024-10-28 20:30:23
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:30:23
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metatempo.models import MetaTempoConnection, MetaTempoMemberLog, MetaTempoMemberLogDaily, \
    MetaTempoProjectOverallLog
from apps.organization.models import Organization
from apps.projects.models import ProjectItem, ProjectTeamItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaTempoView_MainBoard(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_METATEMPO_CONNECTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_METATEMPO_CONNECTION):
            messages.error(self.request, "You do not have permission to list MetaTempo Connections.")
            return context
        ##############################

        connection_id = self.kwargs.get('connection_id')
        connection = MetaTempoConnection.objects.get(id=connection_id)

        org_users = Organization.objects.filter(users__in=[self.request.user])
        org_projects = ProjectItem.objects.filter(organization__in=org_users)
        org_users = []
        for project in org_projects:
            project: ProjectItem
            teams = project.project_teams.all()
            for team in teams:
                team: ProjectTeamItem
                team_users = team.team_members.all()
                org_users.extend(team_users)
        org_users = list(set(org_users))

        member_logs = MetaTempoMemberLog.objects.filter(metatempo_connection=connection).order_by('-timestamp')
        daily_logs = MetaTempoMemberLogDaily.objects.filter(metatempo_connection=connection).order_by('-datestamp')
        overall_logs = MetaTempoProjectOverallLog.objects.filter(metatempo_connection=connection).order_by('-datestamp')

        context.update({
            "connection": connection,
            "member_logs": member_logs,
            "daily_logs": daily_logs,
            "overall_logs": overall_logs,
            "users": org_users,
            "user_auth_key": self.request.user.profile.metatempo_tracking_auth_key,
            "connection_api_key": connection.connection_api_key,
        })
        return context


Contents of ../../apps/metatempo/views/agent/agent_communication_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: agent_communication_views.py
#  Last Modified: 2024-10-28 20:46:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:46:18
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.generative_ai.utils import GPT_DEFAULT_ENCODING_ENGINE, ChatRoles
from apps.core.internal_cost_manager.costs_map import InternalServiceCosts
from apps.core.metatempo.metatempo_execution_handler import MetaTempoExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_transaction.models import LLMTransaction
from apps.llm_transaction.utils import LLMTransactionSourcesTypesNames
from apps.metakanban.models import MetaKanbanBoard
from apps.metatempo.models import MetaTempoConnection
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MetaTempoView_AgentCommunication(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        organization_projects = ProjectItem.objects.filter(organization__in=user_orgs)
        organization_boards = MetaKanbanBoard.objects.filter(project__in=organization_projects)
        metatempo_connections = MetaTempoConnection.objects.filter(board__in=organization_boards)
        context['metatempo_connections'] = metatempo_connections
        return context

    def post(self, request, *args, **kwargs):
        connection_id = request.POST.get('connection_id')

        ##############################
        # PERMISSION CHECK FOR - USE_META_TEMPO_AI
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.USE_META_TEMPO_AI):
            messages.error(self.request, "You do not have permission to use the AI agent for MetaTempo.")
            return redirect('metatempo:agent_communication')
        ##############################

        user_query = request.POST.get('user_query')
        xc = MetaTempoExecutionManager(metatempo_connection_id=connection_id)
        response_text, error = xc.answer_logs_question(user_query=user_query)
        if error:
            messages.error(request, "Error executing MetaTempo query.")
            return redirect('metakanban:agent_communication')

        try:
            connection = MetaTempoConnection.objects.get(id=connection_id)
            tx = LLMTransaction(
                organization=connection.board.project.organization, model=connection.board.llm_model,
                responsible_user=connection.board.created_by_user, responsible_assistant=None,
                encoding_engine=GPT_DEFAULT_ENCODING_ENGINE, llm_cost=InternalServiceCosts.MetaTempo.COST,
                transaction_type=ChatRoles.SYSTEM,
                transaction_source=LLMTransactionSourcesTypesNames.METATEMPO, is_tool_cost=True
            )
            tx.save()
            logger.info(f"[metatempo_agent_communication] Created LLMTransaction for MetaTempo Agent AI Analysis Log.")
        except Exception as e:
            logger.error(
                f"[metatempo_agent_communication] Error creating LLMTransaction for MetaTempo Agent AI Analysis Log. Error: {e}")
            pass

        context = self.get_context_data()
        context.update({"llm_output": response_text})
        messages.success(request, f"AI agent has been successfully triggered for the selected MetaTempo connection.")
        return self.render_to_response(context)


Contents of ../../apps/metatempo/views/agent/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-28 20:45:38
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 20:45:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .agent_communication_views import *


Contents of ../../apps/metatempo/views/connect_assistant/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-13 03:20:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 03:20:26
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .delete_assistant_connection_views import *
from .connect_assistant_to_metatempo_views import *


Contents of ../../apps/metatempo/views/connect_assistant/connect_assistant_to_metatempo_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: connect_assistant_to_metatempo_views.py
#  Last Modified: 2024-11-13 03:20:40
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 03:20:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metatempo.models import MetaTempoConnection, MetaTempoAssistantConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MetaTempoView_ConnectAssistantToMetaTempo(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user]).all()
        assistants = Assistant.objects.filter(organization__in=user_orgs).all()
        metatempo_instances = MetaTempoConnection.objects.filter(board__llm_model__organization__in=user_orgs).all()
        context["assistants"] = assistants
        context["metatempo_instances"] = metatempo_instances
        context["existing_connections"] = MetaTempoAssistantConnection.objects.filter(assistant__organization__in=user_orgs).all()
        return context

    def post(self, request, *args, **kwargs):
        assistant_id = self.request.POST.get("assistant_id")
        instance_id = self.request.POST.get("instance_id")

        ##############################
        # PERMISSION CHECK FOR - CONNECT_ASSISTANTS_TO_METATEMPO
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CONNECT_ASSISTANTS_TO_METATEMPO):
            messages.error(self.request, "You do not have permission to connect an assistant to a MetaTempo tracker.")
            return self.render_to_response(self.get_context_data())
        ##############################

        assistant = Assistant.objects.get(id=assistant_id)
        metatempo_instance = MetaTempoConnection.objects.get(id=instance_id)

        try:
            MetaTempoAssistantConnection.objects.create(
                assistant=assistant,
                metatempo_instance=metatempo_instance,
                created_by_user=self.request.user
            )
        except Exception as e:
            messages.error(self.request, f"Error while connecting assistant to MetaTempo tracker: {e}")
            logger.error(f"Error while connecting assistant to MetaTempo tracker: {e}")

        messages.success(self.request, "Assistant connected to MetaTempo tracker successfully.")
        return self.render_to_response(self.get_context_data())


Contents of ../../apps/metatempo/views/connect_assistant/delete_assistant_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_assistant_connection_views.py
#  Last Modified: 2024-11-13 03:20:54
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 03:20:54
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metatempo.models import MetaTempoAssistantConnection
from apps.user_permissions.utils import PermissionNames


class MetaTempoView_AssistantConnectionDelete(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get("pk")

        ##############################
        # PERMISSION CHECK FOR - DISCONNECT_ASSISTANTS_FROM_METATEMPO
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DISCONNECT_ASSISTANTS_FROM_METATEMPO):
            messages.error(self.request, "You do not have permission to disconnect an assistant from a MetaTempo tracker.")
            return redirect("metatempo:connect_assistant")
        ##############################

        try:
            connection = MetaTempoAssistantConnection.objects.get(id=connection_id)
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection: " + str(e))
            return redirect("metatempo:connect_assistant")

        messages.success(request, "Connection deleted successfully.")
        return redirect("metatempo:connect_assistant")


Contents of ../../apps/llm_core/views/delete_llm_core_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_llm_core_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_core.models import LLMCore
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class LLMView_Delete(DeleteView, LoginRequiredMixin):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user
        context['user'] = user
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_LLM_CORES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_LLM_CORES):
            messages.error(self.request, "You do not have permission to delete LLM Cores.")
            return redirect('llm_core:list')
        ##############################

        llm_core = get_object_or_404(LLMCore, id=kwargs['pk'])

        try:
            llm_core.delete()
        except Exception as e:
            logger.error(f"An error occurred while deleting LLM Core {llm_core.nickname}. Error: {str(e)}")
            messages.error(request, f"An error occurred while deleting LLM Core {llm_core.nickname}. Error: {str(e)}")
            return redirect('llm_core:list')

        logger.info(f"LLM Core {llm_core.nickname} was deleted by User: {self.request.user.id}.")
        return redirect('llm_core:list')

    def get_queryset(self):
        user = self.request.user
        return LLMCore.objects.filter(organization__in=user.organizations.all())


Contents of ../../apps/llm_core/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .list_llm_cores_views import *
from .create_llm_core_views import *
from .delete_llm_core_views import *
from .update_llm_core_views import *


Contents of ../../apps/llm_core/views/update_llm_core_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_llm_core_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.finetuning.models import FineTunedModelConnection
from apps.llm_core.forms import LLMCoreForm
from apps.llm_core.models import LLMCore
from apps.llm_core.utils import LARGE_LANGUAGE_MODEL_PROVIDERS, GPT_MODEL_NAMES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class LLMView_Update(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        llm_core = LLMCore.objects.get(id=kwargs['pk'])
        context_user = self.request.user
        context['llm_core'] = llm_core
        context['organizations'] = context_user.organizations.all()
        context['provider_choices'] = LARGE_LANGUAGE_MODEL_PROVIDERS
        context['model_name_choices'] = GPT_MODEL_NAMES
        tuned_llms = FineTunedModelConnection.objects.filter(organization__in=context['organizations']).all()
        for model in tuned_llms:
            if model.model_name not in [m[0] for m in context['model_name_choices']]:
                context['model_name_choices'].append((model.model_name, model.nickname))
        for model in context['model_name_choices']:
            if model[0] not in [m[0] for m in GPT_MODEL_NAMES] and model[0] not in [m[0] for m in tuned_llms]:
                context['model_name_choices'].remove(model)
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_LLM_CORES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_LLM_CORES):
            messages.error(self.request, "You do not have permission to update LLM Cores.")
            return redirect('llm_core:list')
        ##############################

        llm_core = LLMCore.objects.get(id=kwargs['pk'])
        prev_org = llm_core.organization
        form = LLMCoreForm(request.POST, request.FILES, instance=llm_core)

        try:
            if form.is_valid():
                prev_org.llm_cores.remove(llm_core)
                prev_org.save()
                form.save()
                org = Organization.objects.get(id=request.POST['organization'])
                org.llm_cores.add(llm_core)
                org.save()
                logger.info(f"LLM Core updated: {llm_core.id}")
                return redirect('llm_core:list')
            else:
                context = self.get_context_data(**kwargs)
                context['form'] = form
                error_msgs = form.errors
                context['error_messages'] = error_msgs
                logger.error(f"Error updating LLM Core: {error_msgs}")
                return self.render_to_response(context)
        except Exception as e:
            logger.error(f"Error updating LLM Core: {e}")
            messages.error(request, f"Error updating LLM Core: {e}")
            return redirect('llm_core:list')


Contents of ../../apps/llm_core/views/list_llm_cores_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_llm_cores_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class LLMView_List(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_LLM_CORES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_LLM_CORES):
            messages.error(self.request, "You do not have permission to list LLM Cores.")
            return context
        ##############################

        user = self.request.user
        orgs = user.organizations.all()
        llms = {}
        for org in orgs:
            llms[org] = org.llm_cores.all()
        context['organizations'] = orgs
        context['org_llm_cores'] = llms
        logger.info(f"LLM Cores were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/llm_core/views/create_llm_core_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_llm_core_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.finetuning.models import FineTunedModelConnection
from apps.llm_core.forms import LLMCoreForm
from apps.llm_core.models import LLMCore
from apps.llm_core.utils import LARGE_LANGUAGE_MODEL_PROVIDERS, GPT_MODEL_NAMES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class LLMView_Create(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user
        context['user'] = user
        context['organizations'] = user.organizations.all()
        context['provider_choices'] = LARGE_LANGUAGE_MODEL_PROVIDERS
        context['model_name_choices'] = GPT_MODEL_NAMES
        tuned_llms = FineTunedModelConnection.objects.filter(organization__in=context['organizations']).all()
        for model in tuned_llms:
            if model.model_name not in [m[0] for m in context['model_name_choices']]:
                context['model_name_choices'].append((model.model_name, model.nickname))
        for model in context['model_name_choices']:
            if model[0] not in [m[0] for m in GPT_MODEL_NAMES] and model[0] not in [m[0] for m in tuned_llms]:
                context['model_name_choices'].remove(model)
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_LLM_CORES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_LLM_CORES):
            messages.error(self.request, "You do not have permission to add LLM Cores.")
            return redirect('llm_core:list')
        ##############################

        form = LLMCoreForm(request.POST, request.FILES)
        user = request.user
        form.instance.created_by_user = user
        form.instance.last_updated_by_user = user

        try:
            if form.is_valid():
                form.save()
                org = Organization.objects.get(id=request.POST['organization'])
                llm_core = LLMCore.objects.filter(created_by_user=user).latest('created_at')
                org.llm_cores.add(llm_core)
                org.save()
                logger.info(f"LLM Core created: {llm_core.id}")
                return redirect('llm_core:list')
            else:
                error_msgs = form.errors
                context = self.get_context_data(**kwargs)
                context['form'] = form
                context['error_messages'] = error_msgs
                logger.error(f"Error creating LLM Core: {error_msgs}")
                return self.render_to_response(context)
        except Exception as e:
            logger.error(f"Error creating LLM Core: {e}")
            messages.error(request, f"Error creating LLM Core: {e}")
            return redirect('llm_core:create')


Contents of ../../apps/metakanban/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-23 17:36:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-23 17:36:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .task import *
from .board import *
from .column import *
from .label import *
from .agent import *
from .log import *
from .endpoints import *
from .meeting import *
from .connect_assistant import *


Contents of ../../apps/metakanban/views/endpoints/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-28 03:30:28
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 03:30:28
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .meeting_recording_audio_ai_delivery_views import *


Contents of ../../apps/metakanban/views/endpoints/meeting_recording_audio_ai_delivery_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: meeting_recording_audio_ai_delivery_views.py
#  Last Modified: 2024-10-28 03:30:56
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 03:30:57
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.core.generative_ai.utils import GPT_DEFAULT_ENCODING_ENGINE, ChatRoles
from apps.core.internal_cost_manager.costs_map import InternalServiceCosts
from apps.core.transcriber.transcriber_executor import TranscriberExecutionManager
from apps.llm_transaction.models import LLMTransaction
from apps.llm_transaction.utils import LLMTransactionSourcesTypesNames
from apps.metakanban.models import MetaKanbanMeetingTranscription, MetaKanbanBoard

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name='dispatch')
class MetaKanbanView_MeetingRecordingAudioAIDelivery(View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        metakanban_board_api_key = request.POST.get('metakanban_api_key')
        meeting_recording_audio_wav = request.FILES.get('meeting_recording_audio_wav')

        if not metakanban_board_api_key:
            logger.error("[metakanban_meeting_transcription] metakanban_api_key is required.")
            return JsonResponse({"success": False, "error": "metakanban_api_key is required."}, status=400)
        if not meeting_recording_audio_wav:
            return JsonResponse({"success": False, "error": "meeting_recording_audio_wav is required."},
                                status=400)

        try:
            if "Bearer" in metakanban_board_api_key:
                metakanban_board_api_key = metakanban_board_api_key.replace("Bearer", "").strip()
        except Exception as e:
            return JsonResponse({"success": False, "error": str(e)}, status=500)

        board: MetaKanbanBoard = MetaKanbanBoard.objects.filter(connection_api_key=metakanban_board_api_key).first()
        if not board:
            return JsonResponse({"success": False, "error": "Board not found."}, status=404)
        if board.connection_api_key != metakanban_board_api_key:
            return JsonResponse({"success": False, "error": "Invalid API Key."}, status=401)

        try:
            xc = TranscriberExecutionManager()
            transcription_text, error = xc.transcribe_audio(audio_data=meeting_recording_audio_wav.read())
            if error:
                return JsonResponse({"success": False, "error": error}, status=500)
        except Exception as e:
            return JsonResponse({"success": False, "error": str(e)}, status=500)

        # Save transcription_text to MetaKanbanMeetingTranscription
        MetaKanbanMeetingTranscription.objects.create(
            board_id=board.id,
            meeting_transcription_text=transcription_text,
            is_processed_with_ai=False
        )

        try:
            tx = LLMTransaction(
                organization=board.project.organization, model=board.llm_model,
                responsible_user=board.created_by_user, responsible_assistant=None,
                encoding_engine=GPT_DEFAULT_ENCODING_ENGINE, llm_cost=InternalServiceCosts.MeetingTranscription.COST,
                transaction_type=ChatRoles.SYSTEM,
                transaction_source=LLMTransactionSourcesTypesNames.MEETING_TRANSCRIPTION, is_tool_cost=True
            )
            tx.save()
            logger.info(f"[metakanban_meeting_transcription] Created LLMTransaction for MetaKanban Meeting Transcription.")
        except Exception as e:
            logger.error(
                f"[metakanban_meeting_transcription] Error creating LLMTransaction for MetaKanban Meeting Transcription. Error: {e}")
            pass

        return JsonResponse({"success": True, "error": None}, status=200)


Contents of ../../apps/metakanban/views/board/detail_board_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: detail_board_views.py
#  Last Modified: 2024-10-26 23:43:38
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:43:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import (MetaKanbanBoard, MetaKanbanStatusColumn, MetaKanbanTask,
                                    MetaKanbanTaskLabel)
from apps.metakanban.utils import META_KANBAN_TASK_PRIORITIES
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaKanbanView_BoardDetail(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_METAKANBAN_BOARD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_METAKANBAN_BOARD):
            messages.error(self.request, "You do not have permission to list kanban boards.")
            return context
        ##############################

        board_id = kwargs.get("board_id")
        board = MetaKanbanBoard.objects.get(id=board_id)

        context["board"] = MetaKanbanBoard.objects.get(id=board_id)
        context["columns"] = MetaKanbanStatusColumn.objects.filter(board_id=board_id).order_by("position_id")
        context["tasks"] = MetaKanbanTask.objects.filter(status_column__board_id=board_id)
        context["labels"] = MetaKanbanTaskLabel.objects.filter(board_id=board_id)
        context["priorities"] = META_KANBAN_TASK_PRIORITIES

        projects = ProjectItem.objects.filter(id=board.project.id).all()
        project_team_members = []
        for project in projects:
            teams = project.project_teams.all()
            for team in teams:
                project_team_members.extend(team.team_members.all())
        project_team_members = list(set(project_team_members))
        context["users"] = project_team_members
        return context


Contents of ../../apps/metakanban/views/board/confirm_delete_board_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: confirm_delete_board_views.py
#  Last Modified: 2024-10-26 23:44:10
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:44:11
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaKanbanView_BoardConfirmDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        board_id = self.kwargs.get("board_id")
        context['board'] = get_object_or_404(MetaKanbanBoard, id=board_id)
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_METAKANBAN_BOARD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_METAKANBAN_BOARD):
            messages.error(self.request, "You do not have permission to delete a kanban board.")
            return redirect('metakanban:board_list')
        ##############################

        board_id = self.kwargs.get("board_id")
        board = get_object_or_404(MetaKanbanBoard, id=board_id)

        try:
            board_title = board.title
            board.delete()
        except Exception as e:
            messages.error(request, f'Error deleting kanban board: {e}')
            return redirect('metakanban:board_list')

        messages.success(request, f'The kanban board "{board_title}" was deleted successfully.')
        return redirect("metakanban:board_list")


Contents of ../../apps/metakanban/views/board/update_board_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_board_views.py
#  Last Modified: 2024-10-26 23:43:22
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:43:23
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_core.models import LLMCore
from apps.metakanban.models import MetaKanbanBoard
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MetaKanbanView_BoardUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        board_id = self.kwargs.get("board_id")
        board = get_object_or_404(MetaKanbanBoard, id=board_id)
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['projects'] = ProjectItem.objects.filter(organization__in=user_orgs)
        context['llm_models'] = LLMCore.objects.filter(organization__in=user_orgs)
        context['board'] = board
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_METAKANBAN_BOARD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_METAKANBAN_BOARD):
            messages.error(self.request, "You do not have permission to update a kanban board.")
            return redirect('metakanban:board_list')
        ##############################

        board_id = self.kwargs.get("board_id")
        board = get_object_or_404(MetaKanbanBoard, id=board_id)

        project_id = request.POST.get("project")
        llm_model_id = request.POST.get("llm_model")
        title = request.POST.get("title")
        description = request.POST.get("description")
        if not project_id or not llm_model_id or not title:
            messages.error(request, "Please fill out all required fields.")
            return self.render_to_response(self.get_context_data())

        try:
            board.project_id = project_id
            board.llm_model_id = llm_model_id
            board.title = title
            board.description = description
            board.save()
        except Exception as e:
            messages.error(request, f"Error updating kanban board: {e}")
            logger.error(f"Error updating kanban board: {e}")
            return redirect('metakanban:board_list')

        logger.info(f"Kanban board updated by User: {self.request.user.id}.")
        messages.success(request, "Kanban board updated successfully.")
        return redirect("metakanban:board_list")


Contents of ../../apps/metakanban/views/board/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-26 22:09:52
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 22:09:53
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .create_board_views import *
from .detail_board_views import *
from .list_boards_views import *
from .update_board_views import *
from .confirm_delete_board_views import *


Contents of ../../apps/metakanban/views/board/list_boards_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_boards_views.py
#  Last Modified: 2024-10-26 23:43:29
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:43:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaKanbanView_BoardList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_METAKANBAN_BOARD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_METAKANBAN_BOARD):
            messages.error(self.request, "You do not have permission to list kanban boards.")
            return context
        ##############################

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        org_projects_boards = {}
        for org in user_orgs:
            projects = ProjectItem.objects.filter(organization=org)
            org_projects_boards[org] = {}
            for project in projects:
                boards = MetaKanbanBoard.objects.filter(project=project)
                org_projects_boards[org][project] = boards

        context['org_projects_boards'] = org_projects_boards
        return context


Contents of ../../apps/metakanban/views/board/create_board_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_board_views.py
#  Last Modified: 2024-10-26 23:43:15
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:43:16
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging
import secrets

from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView
from django.contrib import messages

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_core.models import LLMCore
from apps.metakanban.models import MetaKanbanBoard
from apps.metakanban.utils import META_KANBAN_BOARD_API_KEY_DEFAULT_LENGTH
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MetaKanbanView_BoardCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['projects'] = ProjectItem.objects.filter(organization__in=user_orgs)
        context['llm_models'] = LLMCore.objects.filter(organization__in=user_orgs)
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_METAKANBAN_BOARD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_METAKANBAN_BOARD):
            messages.error(self.request, "You do not have permission to add a kanban board.")
            return redirect('metakanban:board_list')
        ##############################

        project_id = request.POST.get("project")
        llm_model_id = request.POST.get("llm_model")
        title = request.POST.get("title")
        description = request.POST.get("description")
        if not project_id or not llm_model_id or not title:
            messages.error(request, "Please fill out all required fields.")
            return self.render_to_response(self.get_context_data())

        connection_api_key = secrets.token_urlsafe(META_KANBAN_BOARD_API_KEY_DEFAULT_LENGTH)

        try:
            board = MetaKanbanBoard.objects.create(
                project_id=project_id, llm_model_id=llm_model_id, title=title,
                description=description, created_by_user=request.user,
                connection_api_key=connection_api_key
            )
        except Exception as e:
            logger.error(f"Error creating kanban board: {e}")
            messages.error(request, "Error creating kanban board.")
            return self.render_to_response(self.get_context_data())

        messages.success(request, "Kanban board created successfully.")
        return redirect("metakanban:board_list")


Contents of ../../apps/metakanban/views/label/create_task_label.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_task_label.py
#  Last Modified: 2024-10-27 00:33:41
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 00:33:42
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard, MetaKanbanTaskLabel, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_LabelCreate(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        board_id = kwargs.get("board_id")

        ##############################
        # PERMISSION CHECK FOR - ADD_METAKANBAN_TASK_LABEL
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_METAKANBAN_TASK_LABEL):
            messages.error(self.request, "You do not have permission to add a kanban task label.")
            return redirect('metakanban:board_detail', board_id=board_id)
        ##############################

        board = get_object_or_404(MetaKanbanBoard, id=board_id)
        label_name = request.POST.get("label_name")
        label_color = request.POST.get("label_color")

        if label_name and label_color:
            MetaKanbanTaskLabel.objects.create(
                board=board, label_name=label_name, label_color=label_color, created_by_user=request.user
            )
            messages.success(request, "Label created successfully.")
        else:
            messages.error(request, "Both label name and color are required.")

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Label.CREATE_LABEL,
                action_details="Label '" + label_name + "' with the color '" + label_color + "' has been created.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Label change log could not be created. Error: " + str(e))

        return redirect("metakanban:label_list", board_id=board_id)


Contents of ../../apps/metakanban/views/label/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-27 00:32:55
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 00:32:55
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .list_task_labels import *
from .create_task_label import *
from .delete_task_labels import *
from .update_task_label import *


Contents of ../../apps/metakanban/views/label/list_task_labels.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_task_labels.py
#  Last Modified: 2024-10-27 00:33:54
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 00:33:54
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard, MetaKanbanTaskLabel
from apps.metakanban.utils import META_KANBAN_TASK_LABEL_COLOR_CHOICES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaKanbanView_LabelList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_METAKANBAN_TASK_LABEL
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_METAKANBAN_TASK_LABEL):
            messages.error(self.request, "You do not have permission to list kanban task labels.")
            return context
        ##############################

        board_id = self.kwargs.get("board_id")
        context['board'] = get_object_or_404(MetaKanbanBoard, id=board_id)
        context['labels'] = MetaKanbanTaskLabel.objects.filter(board_id=board_id).order_by('-created_at')
        context['color_choices'] = META_KANBAN_TASK_LABEL_COLOR_CHOICES
        return context


Contents of ../../apps/metakanban/views/label/update_task_label.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_task_label.py
#  Last Modified: 2024-10-27 00:33:49
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 00:33:49
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanTaskLabel, MetaKanbanChangeLog, MetaKanbanBoard
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_LabelUpdate(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        board_id = kwargs.get("board_id")
        board = get_object_or_404(MetaKanbanBoard, id=board_id)

        ##############################
        # PERMISSION CHECK FOR - UPDATE_METAKANBAN_TASK_LABEL
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_METAKANBAN_TASK_LABEL):
            messages.error(self.request, "You do not have permission to update a kanban task label.")
            return redirect('metakanban:board_detail', board_id=board_id)
        ##############################

        label_id = kwargs.get("label_id")
        label = get_object_or_404(MetaKanbanTaskLabel, id=label_id, board_id=board_id)

        label.label_name = request.POST.get("label_name", label.label_name)
        label.label_color = request.POST.get("label_color", label.label_color)
        label.save()

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Label.UPDATE_LABEL,
                action_details="Label '" + label.label_name + "' has been updated to '" + label.label_name + "' and color has been updated to '" + label.label_color + "'.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Label change log could not be created. Error: " + str(e))

        messages.success(request, "Label updated successfully.")
        return redirect("metakanban:label_list", board_id=board_id)


Contents of ../../apps/metakanban/views/label/delete_task_labels.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_task_labels.py
#  Last Modified: 2024-10-27 00:34:03
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 00:34:04
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanTaskLabel, MetaKanbanChangeLog, MetaKanbanBoard
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_LabelDelete(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        board_id = kwargs.get("board_id")
        board = get_object_or_404(MetaKanbanBoard, id=board_id)

        ##############################
        # PERMISSION CHECK FOR - DELETE_METAKANBAN_TASK_LABEL
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_METAKANBAN_TASK_LABEL):
            messages.error(self.request, "You do not have permission to delete a kanban task label.")
            return redirect('metakanban:board_detail', board_id=board_id)
        ##############################

        try:
            label_id = kwargs.get("label_id")
            label = get_object_or_404(MetaKanbanTaskLabel, id=label_id)
            label_name = label.label_name
            label.delete()
        except Exception as e:
            messages.error(request, "Label could not be deleted. Error: " + str(e))
            return redirect("metakanban:label_list", board_id=board_id)

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Label.DELETE_LABEL,
                action_details="Label '" + label_name + "' has been deleted.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Label change log could not be created. Error: " + str(e))

        messages.success(request, f'Label "{label_name}" deleted successfully.')
        return redirect("metakanban:label_list", board_id=board_id)


Contents of ../../apps/metakanban/views/column/confirm_delete_board_column_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: confirm_delete_board_column.py
#  Last Modified: 2024-10-26 23:44:53
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:45:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.db import transaction
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanStatusColumn, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_ColumnConfirmDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        column_id = request.POST.get("column_id")
        column = get_object_or_404(MetaKanbanStatusColumn, id=column_id)
        board_id = column.board.id
        board = column.board
        column_name = column.column_name

        ##############################
        # PERMISSION CHECK FOR - DELETE_METAKANBAN_COLUMN
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_METAKANBAN_COLUMN):
            messages.error(self.request, "You do not have permission to delete a kanban column.")
            return redirect('metakanban:board_detail', board_id=board_id)
        ##############################

        with transaction.atomic():
            column.delete()
            self.reorder_columns(board_id)

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Column.DELETE_COLUMN,
                action_details="Column '" + column_name + "' has been deleted.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Column change log could not be created. Error: " + str(e))

        messages.success(request, f'Column "{column_name}" deleted successfully.')
        return redirect("metakanban:board_detail", board_id=board_id)

    def reorder_columns(self, board_id):
        columns = MetaKanbanStatusColumn.objects.filter(board_id=board_id).order_by("position_id")
        for index, column in enumerate(columns):
            if column.position_id != index:
                column.position_id = index
                column.save()


Contents of ../../apps/metakanban/views/column/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-26 22:10:02
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 22:10:03
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .create_board_column_views import *
from .update_board_column_views import *
from .confirm_delete_board_column_views import *
from .move_column_views import *


Contents of ../../apps/metakanban/views/column/update_board_column_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_board_column.py
#  Last Modified: 2024-10-26 23:44:46
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:46:02
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanStatusColumn, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_ColumnUpdate(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        column_id = request.POST.get("column_id")
        column = get_object_or_404(MetaKanbanStatusColumn, id=column_id)
        board = column.board

        ##############################
        # PERMISSION CHECK FOR - UPDATE_METAKANBAN_COLUMN
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_METAKANBAN_COLUMN):
            messages.error(self.request, "You do not have permission to update a kanban column.")
            return redirect('metakanban:board_detail', board_id=column.board.id)
        ##############################

        new_column_name = request.POST.get("column_name")
        if new_column_name:
            column.column_name = new_column_name
            column.save()
            messages.success(request, f'Column "{new_column_name}" updated successfully.')
        else:
            messages.error(request, "Column name cannot be empty.")

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Column.UPDATE_COLUMN,
                action_details="Column name updated from '" + column.column_name + "' to '" + new_column_name + "'.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Column change log could not be created. Error: " + str(e))

        return redirect("metakanban:board_detail", board_id=column.board.id)


Contents of ../../apps/metakanban/views/column/move_column_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: move_column_views.py
#  Last Modified: 2024-10-27 02:28:13
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 02:28:14
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views import View
from django.shortcuts import get_object_or_404, redirect
from django.contrib import messages
from django.db import transaction
import logging

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanStatusColumn, MetaKanbanChangeLog, MetaKanbanBoard
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class MetaKanbanView_ColumnMove(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        board_id = request.POST.get("board_id")
        board = get_object_or_404(MetaKanbanBoard, id=board_id)
        column_id = request.POST.get("column_id")
        column = get_object_or_404(MetaKanbanStatusColumn, id=column_id)
        direction = request.POST.get("direction")

        ##############################
        # PERMISSION CHECK FOR - MOVE_METAKANBAN_COLUMN
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.MOVE_METAKANBAN_COLUMN):
            messages.error(self.request, "You do not have permission to move a kanban column.")
            return redirect('metakanban:board_detail', board_id=board_id)
        ##############################

        try:
            old_position_id = column.position_id
            if direction == 'up' and old_position_id > 0:
                new_position_id = old_position_id - 1
            elif direction == 'down':
                new_position_id = old_position_id + 1
            else:
                messages.info(request, "Column is already at the specified position.")
                return redirect("metakanban:board_detail", board_id=board_id)

            with transaction.atomic():
                adjacent_column = MetaKanbanStatusColumn.objects.get(board_id=board_id, position_id=new_position_id)
                adjacent_column.position_id = old_position_id
                adjacent_column.save()
                column.position_id = new_position_id
                column.save()

            self.reorder_columns(board_id)
            messages.success(request, f'Column "{column.column_name}" moved {direction}.')

        except Exception as e:
            logger.error(f"Column could not be moved. Error: {str(e)}")
            messages.error(request, f"Column could not be moved. Error: {str(e)}")

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Column.MOVE_COLUMN,
                action_details="The column with the name " + column.column_name + " has been moved " + direction,
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Column change log could not be created. Error: " + str(e))

        return redirect("metakanban:board_detail", board_id=board_id)

    def reorder_columns(self, board_id):
        columns = MetaKanbanStatusColumn.objects.filter(board_id=board_id).order_by("position_id")
        for index, column in enumerate(columns):
            if column.position_id != index:
                column.position_id = index
                column.save()


Contents of ../../apps/metakanban/views/column/create_board_column_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_board_column.py
#  Last Modified: 2024-10-26 23:44:38
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:45:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.db import models, transaction
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard, MetaKanbanStatusColumn, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_ColumnCreate(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        board_id = request.POST.get("board_id")
        board = get_object_or_404(MetaKanbanBoard, id=board_id)

        ##############################
        # PERMISSION CHECK FOR - ADD_METAKANBAN_COLUMN
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_METAKANBAN_COLUMN):
            messages.error(self.request, "You do not have permission to add a kanban column.")
            return redirect('metakanban:board_detail', board_id=board_id)
        ##############################

        column_name = request.POST.get("column_name")
        position_id = request.POST.get("position_id")
        if column_name and position_id is not None:
            position_id = int(position_id)
            with transaction.atomic():
                MetaKanbanStatusColumn.objects.filter(
                    board=board, position_id__gte=position_id
                ).update(position_id=models.F("position_id") + 1)
                MetaKanbanStatusColumn.objects.create(
                    board=board, column_name=column_name, position_id=position_id, created_by_user=request.user
                )

            self.reorder_columns(board_id)
            messages.success(request, f'Column "{column_name}" created successfully at position {position_id}.')
        else:
            messages.error(request, "Column name and position are required to create a new column.")

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Column.CREATE_COLUMN,
                action_details="A new column created for the board, with the name: " + column_name,
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Column change log could not be created. Error: " + str(e))

        return redirect("metakanban:board_detail", board_id=board_id)

    def reorder_columns(self, board_id):
        columns = MetaKanbanStatusColumn.objects.filter(board_id=board_id).order_by("position_id")
        for index, column in enumerate(columns):
            if column.position_id != index:
                column.position_id = index
                column.save()


Contents of ../../apps/metakanban/views/agent/agent_communication_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: agent_communication_views.py
#  Last Modified: 2024-10-27 18:54:42
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 18:54:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, render
from django.views.generic import TemplateView

from apps.core.metakanban.metakanban_execution_handler import MetaKanbanExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaKanbanView_AgentCommunication(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        organization_projects = ProjectItem.objects.filter(organization__in=user_orgs)
        organization_boards = MetaKanbanBoard.objects.filter(project__in=organization_projects)
        context['organization_boards'] = organization_boards
        return context

    def post(self, request, *args, **kwargs):
        board_id = request.POST.get('board_id')

        ##############################
        # PERMISSION CHECK FOR - USE_METAKANBAN_AI
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.USE_METAKANBAN_AI):
            messages.error(self.request, "You do not have permission to use MetaKanban AI.")
            return redirect('metakanban:agent_communication')
        ##############################

        user_query = request.POST.get('user_query')

        try:
            xc = MetaKanbanExecutionManager(board_id=board_id)
            success, llm_output = xc.consult_ai(user_query=user_query)
            if not success:
                messages.error(request, "Error executing MetaKanban query.")
                return redirect('metakanban:agent_communication')
        except Exception as e:
            messages.error(request, f"Error executing MetaKanban query: {e}")
            return redirect('metakanban:agent_communication')

        context = self.get_context_data()
        context.update({
            "llm_output": llm_output,
        })
        messages.success(request, "MetaKanban query executed successfully.")
        return render(request, 'metakanban/agent/agent_communication.html', context)


Contents of ../../apps/metakanban/views/agent/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-27 18:54:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 18:54:48
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .agent_communication_views import *


Contents of ../../apps/metakanban/views/meeting/meeting_transcription_ai_implement_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: meeting_transcriptions_ai_implement_views.py
#  Last Modified: 2024-10-28 04:13:00
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 04:13:00
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.metakanban.metakanban_execution_handler import MetaKanbanExecutionManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanMeetingTranscription
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class MetaKanbanView_MeetingTranscriptionAIImplement(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        transcription_id = kwargs.get('transcription_id')
        transcription = get_object_or_404(MetaKanbanMeetingTranscription, pk=transcription_id)
        board_id = transcription.board_id

        ##############################
        # PERMISSION CHECK FOR - IMPLEMENT_MEETING_TRANSCRIPTION_WITH_AI
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.IMPLEMENT_MEETING_TRANSCRIPTION_WITH_AI):
            messages.error(self.request, "You do not have permission to implement meeting transcription with AI.")
            return redirect('metakanban:meeting_transcription_list', board_id=board_id)
        ##############################

        try:
            xc = MetaKanbanExecutionManager(board_id=board_id)
            success, llm_output = xc.consult_ai(user_query=f"""
                --------------------------------
                **MEETING RAW TRANSCRIPT:**
                - Meeting Transcription Timestamp: {transcription.created_at}
                --------------------------------

                '''
                {transcription.meeting_transcription_text}
                '''

                --------------------------------

                **IMPORTANT NOTE:**

                - After you run the commands for updating the Kanban board, share the key takeaways in the meeting
                by checking the transcription text. **DO NOT SHARE** anything other than comma separated takeaways
                in your final response.

                    ________________________________________________________________

                    **Example Final Response with Comma Separated Values:**

                    '''
                    The task must be finalized by EOW, team needs budget, project is currently on track
                    '''

                    ________________________________________________________________

                --------------------------------
            """)
            if not success:
                logger.error("Error executing (meeting transcription) MetaKanban query.")
                messages.error(request, "Error executing (meeting transcription) MetaKanban query.")
                return redirect('metakanban:meeting_transcription_list', board_id=board_id)

            try:
                transcription.ai_implemented = True
                transcription.save()
            except Exception as e:
                logger.error(f"Error saving AI implementation status: {str(e)}")
                messages.error(request, "Error saving AI implementation status.")
                return redirect('metaKanban:meeting_transcription_list', board_id=board_id)

            try:
                key_takeaways_list = llm_output.split(',')
                key_takeaways_list = [key_takeaway.replace("`", "")
                                      .replace("'", "")
                                      .replace('"', "").strip() for key_takeaway in key_takeaways_list]
                if not key_takeaways_list:
                    raise Exception("No key takeaways found.")
                transcription.meeting_transcription_key_takeaways = key_takeaways_list
                transcription.save()
            except Exception as e:
                logger.error(f"Error saving key takeaways: {str(e)}")
                messages.error(request, "Error saving key takeaways.")
                pass

            messages.success(request, "MetaKanban query executed successfully.")
            logger.info(f"MetaKanban AI implemented for meeting transcription: {transcription_id}")
            return redirect('metakanban:meeting_transcription_list', board_id=board_id)

        except Exception as e:
            logger.error(f"Error executing (meeting transcription) MetaKanban query: {str(e)}")
            messages.error(request, "Error executing (meeting transcription) MetaKanban query: " + str(e))
            return redirect('metakanban:meeting_transcription_list', board_id=board_id)


Contents of ../../apps/metakanban/views/meeting/meeting_transcriptions_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: meeting_transcriptions_list_views.py
#  Last Modified: 2024-10-28 04:11:54
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 04:11:55
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.http import Http404
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanMeetingTranscription, MetaKanbanBoard
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaKanbanView_MeetingTranscriptionList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        board_id = self.kwargs['board_id']
        board = get_object_or_404(MetaKanbanBoard, pk=board_id)

        ##############################
        # PERMISSION CHECK - USE_METAKANBAN_MEETING_TRANSCRIPTION
        if UserPermissionManager.is_authorized(user=self.request.user,
                                               operation=PermissionNames.USE_METAKANBAN_MEETING_TRANSCRIPTION):
            context["board_api_key"] = board.connection_api_key
        ##############################

        # Retrieve transcriptions and apply pagination
        transcriptions = MetaKanbanMeetingTranscription.objects.filter(board_id=board_id).order_by('-created_at')
        paginator = Paginator(transcriptions, 10)

        page_number = self.request.GET.get('page', 1)
        try:
            page_obj = paginator.get_page(page_number)
        except:
            raise Http404("Page not found.")

        context['page_obj'] = page_obj
        context['board'] = board
        return context


Contents of ../../apps/metakanban/views/meeting/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-28 04:11:46
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 04:11:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .meeting_transcriptions_list_views import *
from .meeting_transcription_ai_implement_views import *
from .meeting_transcription_delete_views import *
from .meeting_regenerate_board_api_key_views import *


Contents of ../../apps/metakanban/views/meeting/meeting_transcription_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: meeting_transcription_delete_views.py
#  Last Modified: 2024-10-28 04:13:15
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 04:13:15
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanMeetingTranscription
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_MeetingTranscriptionDelete(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        transcription_id = kwargs.get('transcription_id')
        transcription = get_object_or_404(MetaKanbanMeetingTranscription, pk=transcription_id)
        board_id = transcription.board_id

        ##############################
        # PERMISSION CHECK FOR - DELETE_MEETING_TRANSCRIPTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_MEETING_TRANSCRIPTION):
            messages.error(self.request, "You do not have permission to delete meeting transcription.")
            return redirect('metakanban:meeting_transcription_list', board_id=board_id)
        ##############################

        try:
            transcription.delete()
        except Exception as e:
            messages.error(request, "Meeting transcription could not be deleted.")
            return redirect("metakanban:meeting_transcription_list", board_id=board_id)

        messages.success(request, "Meeting transcription deleted successfully.")
        return redirect("metakanban:meeting_transcription_list", board_id=board_id)


Contents of ../../apps/metakanban/views/meeting/meeting_regenerate_board_api_key_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: meeting_regenerate_board_api_key_views.py
#  Last Modified: 2024-10-28 17:00:19
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-28 17:00:19
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import json
import secrets

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.views import View

from apps.metakanban.models import MetaKanbanBoard
from apps.metakanban.utils import META_KANBAN_BOARD_API_KEY_DEFAULT_LENGTH


class MetaKanbanView_MeetingRegenerateAPIKey(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        data = json.loads(request.body)
        try:
            board_id_text = data.get('board_id')
            board_id = int(board_id_text)
        except Exception as e:
            messages.error(request, "Invalid board ID.")
            return JsonResponse({'error': 'Invalid board ID.'})
        try:
            board = MetaKanbanBoard.objects.get(id=board_id)
            new_api_key = secrets.token_urlsafe(META_KANBAN_BOARD_API_KEY_DEFAULT_LENGTH)
            board.connection_api_key = new_api_key
            board.save()
        except Exception as e:
            messages.error(request, "Failed to regenerate API key.")
            return JsonResponse({'error': 'Failed to regenerate API key.'})

        messages.success(request, "API key regenerated successfully.")
        return JsonResponse({'new_token': new_api_key})


Contents of ../../apps/metakanban/views/task/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-26 22:10:12
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 22:10:12
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .move_board_task_views import *
from .delete_board_task_views import *
from .create_board_task_views import *
from .task_detail_and_update_views import *
from .assign_board_task_views import *


Contents of ../../apps/metakanban/views/task/assign_board_task_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: assign_board_task_views.py
#  Last Modified: 2024-10-27 00:07:04
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 00:07:04
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanTask, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_TaskAssign(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        task_id = request.POST.get("task_id")
        task = get_object_or_404(MetaKanbanTask, id=task_id)
        board = task.board

        ##############################
        # PERMISSION CHECK FOR - ASSIGN_METAKANBAN_TASK
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ASSIGN_METAKANBAN_TASK):
            messages.error(self.request, "You do not have permission to assign users to a kanban task.")
            return redirect('metakanban:board_detail', board_id=task.board.id)
        ##############################

        assignee_ids = request.POST.getlist("assignees")
        task.assignees.set(assignee_ids)
        task.save()

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Task.ASSIGN_TASK,
                action_details="Users assigned to task '" + task.title + "' as follows: " + ", ".join([assignee.username for assignee in task.assignees.all()]),
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Task change log could not be created. Error: " + str(e))

        messages.success(request, f"Users assigned to task '{task.title}' successfully.")
        return redirect("metakanban:board_detail", board_id=task.board.id)


Contents of ../../apps/metakanban/views/task/task_detail_and_update_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: task_detail_and_update_views.py
#  Last Modified: 2024-10-26 23:56:20
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:56:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.utils.dateparse import parse_datetime
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanTask, MetaKanbanTaskLabel, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_TaskDetailAndUpdate(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        task_id = request.POST.get("task_id")
        task = get_object_or_404(MetaKanbanTask, id=task_id)
        board = task.board

        ##############################
        # PERMISSION CHECK FOR - UPDATE_METAKANBAN_TASK
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_METAKANBAN_TASK):
            messages.error(self.request, "You do not have permission to update a kanban task.")
            return redirect('metakanban:board_detail', board_id=task.board.id)
        ##############################

        task.description = request.POST.get("description", task.description)
        label_ids = request.POST.getlist("labels")
        task.labels.set(MetaKanbanTaskLabel.objects.filter(id__in=label_ids))
        assigned_user_ids = request.POST.getlist("assignees")
        task.assignees.set(assigned_user_ids)
        task.priority = request.POST.get("priority", task.priority)
        task.due_date = parse_datetime(request.POST.get("due_date")) if request.POST.get("due_date") else task.due_date
        task.task_url = request.POST.get("task_url", task.task_url)

        if "task_file" in request.FILES:
            task.task_file = request.FILES["task_file"]
        if "task_image" in request.FILES:
            task.task_image = request.FILES["task_image"]
        task.save()

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Task.UPDATE_TASK,
                action_details="Task '" + task.title + "' information has been updated.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Task change log could not be created. Error: " + str(e))

        messages.success(request, f'Task "{task.title}" updated successfully.')
        return redirect("metakanban:board_detail", board_id=task.board.id)


Contents of ../../apps/metakanban/views/task/move_board_task_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: move_task.py
#  Last Modified: 2024-10-26 23:50:27
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:50:28
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanTask, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_TaskMove(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        task_id = request.POST.get("task_id")
        task = get_object_or_404(MetaKanbanTask, id=task_id)
        board = task.board

        ##############################
        # PERMISSION CHECK FOR - MOVE_METAKANBAN_TASK
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.MOVE_METAKANBAN_TASK):
            messages.error(self.request, "You do not have permission to move a kanban task.")
            return redirect('metakanban:board_detail', board_id=task.board.id)
        ##############################

        new_status_column_id = request.POST.get("column_id")
        if new_status_column_id:
            task.status_column_id = new_status_column_id
            task.save()
            messages.success(request, f'Task "{task.title}" moved to the new column successfully.')
        else:
            messages.error(request, "Invalid status column.")

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Task.MOVE_TASK,
                action_details="Task '" + task.title + "' has encountered a status change and switched columns.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Task change log could not be created. Error: " + str(e))

        return redirect("metakanban:board_detail", board_id=task.board.id)


Contents of ../../apps/metakanban/views/task/create_board_task_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_board_task.py
#  Last Modified: 2024-10-26 23:46:24
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:46:25
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard, MetaKanbanTask, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_TaskCreate(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        board_id = request.POST.get("board_id")
        board = get_object_or_404(MetaKanbanBoard, id=board_id)

        ##############################
        # PERMISSION CHECK FOR - ADD_METAKANBAN_TASK
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_METAKANBAN_TASK):
            messages.error(self.request, "You do not have permission to add a kanban task.")
            return redirect('metakanban:board_detail', board_id=board_id)
        ##############################

        title = request.POST.get("title")
        status_column_id = request.POST.get("column_id")

        if title and status_column_id:
            task = MetaKanbanTask.objects.create(
                board=board,
                title=title,
                status_column_id=status_column_id,
                created_by_user=request.user,
            )
            messages.success(request, f'Task "{task.title}" created successfully.')
        else:
            messages.error(request, "Title and Status Column are required to create a task.")

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Task.CREATE_TASK,
                action_details="Task with the title '" + title + "' has been created.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Task change log could not be created. Error: " + str(e))

        return redirect("metakanban:board_detail", board_id=board.id)


Contents of ../../apps/metakanban/views/task/delete_board_task_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_board_task.py
#  Last Modified: 2024-10-26 23:46:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-26 23:46:31
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanTask, MetaKanbanChangeLog
from apps.metakanban.utils import MetaKanbanChangeLogActionTypes
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_TaskDelete(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        task_id = request.POST.get("task_id")
        task = get_object_or_404(MetaKanbanTask, id=task_id)
        board = task.board

        ##############################
        # PERMISSION CHECK FOR - DELETE_METAKANBAN_TASK
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_METAKANBAN_TASK):
            messages.error(self.request, "You do not have permission to delete a kanban task.")
            return redirect('metakanban:board_detail', board_id=task.board.id)
        ##############################

        task_title = task.title
        task.delete()

        try:
            # Add the change log for the change in the board.
            MetaKanbanChangeLog.objects.create(
                board=board,
                action_type=MetaKanbanChangeLogActionTypes.Task.DELETE_TASK,
                action_details="Task '" + task_title + "' has been deleted.",
                change_by_user=request.user
            )
        except Exception as e:
            messages.error(request, "Task change log could not be created. Error: " + str(e))

        messages.success(request, f'Task "{task_title}" deleted successfully.')
        return redirect("metakanban:board_detail", board_id=task.board.id)


Contents of ../../apps/metakanban/views/log/list_metakanban_board_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_metakanban_board_logs_views.py
#  Last Modified: 2024-10-27 21:57:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 21:57:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanChangeLog, MetaKanbanBoard
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaKanbanView_BoardLogList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_METAKANBAN_BOARD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_METAKANBAN_BOARD):
            messages.error(self.request, "You do not have permission to list kanban boards.")
            return context
        ##############################

        board_id = self.kwargs.get('board_id')
        board = MetaKanbanBoard.objects.get(id=board_id)

        logs_list = MetaKanbanChangeLog.objects.filter(board_id=board_id).order_by('-timestamp').all()
        paginator = Paginator(logs_list, 10)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)

        context['board'] = board
        context['page_obj'] = page_obj
        return context


Contents of ../../apps/metakanban/views/log/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-27 21:57:55
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-27 21:57:55
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .list_metakanban_board_logs_views import *


Contents of ../../apps/metakanban/views/connect_assistant/connect_assistant_to_metakanban_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: connect_assistant_to_metakanban_views.py
#  Last Modified: 2024-11-13 02:30:08
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 02:30:08
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard, MetaKanbanAssistantConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class MetaKanbanView_ConnectAssistantToMetaKanban(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user]).all()
        assistants = Assistant.objects.filter(organization__in=user_orgs).all()
        metakanban_boards = MetaKanbanBoard.objects.filter(llm_model__organization__in=user_orgs).all()
        context["assistants"] = assistants
        context["metakanban_boards"] = metakanban_boards
        context["existing_connections"] = MetaKanbanAssistantConnection.objects.filter(assistant__organization__in=user_orgs).all()
        return context

    def post(self, request, *args, **kwargs):
        assistant_id = self.request.POST.get("assistant_id")
        board_id = self.request.POST.get("board_id")

        ##############################
        # PERMISSION CHECK FOR - CONNECT_ASSISTANTS_TO_METAKANBAN
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CONNECT_ASSISTANTS_TO_METAKANBAN):
            messages.error(self.request, "You do not have permission to connect an assistant to a board.")
            return self.render_to_response(self.get_context_data())
        ##############################

        assistant = Assistant.objects.get(id=assistant_id)
        board = MetaKanbanBoard.objects.get(id=board_id)

        try:
            MetaKanbanAssistantConnection.objects.create(
                assistant=assistant,
                metakanban_board=board,
                created_by_user=self.request.user
            )
        except Exception as e:
            messages.error(self.request, f"Error while connecting assistant to board: {e}")
            logger.error(f"Error while connecting assistant to board: {e}")

        messages.success(self.request, "Assistant connected to board successfully.")
        return self.render_to_response(self.get_context_data())


Contents of ../../apps/metakanban/views/connect_assistant/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-13 02:29:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 02:29:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .connect_assistant_to_metakanban_views import *
from .delete_assistant_connection_views import *


Contents of ../../apps/metakanban/views/connect_assistant/delete_assistant_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_assistant_connection_views.py
#  Last Modified: 2024-11-13 02:57:40
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-13 02:57:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanAssistantConnection
from apps.user_permissions.utils import PermissionNames


class MetaKanbanView_AssistantConnectionDelete(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        connection_id = kwargs.get("pk")

        ##############################
        # PERMISSION CHECK FOR - DISCONNECT_ASSISTANTS_FROM_METAKANBAN
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DISCONNECT_ASSISTANTS_FROM_METAKANBAN):
            messages.error(self.request, "You do not have permission to disconnect an assistant from a board.")
            return redirect("metakanban:connect_assistant")
        ##############################

        try:
            connection = MetaKanbanAssistantConnection.objects.get(id=connection_id)
            connection.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the connection: " + str(e))
            return redirect("metakanban:connect_assistant")

        messages.success(request, "Connection deleted successfully.")
        return redirect("metakanban:connect_assistant")


Contents of ../../apps/ml_model_store/views/integrate_ml_models_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: integrate_ml_models_views.py
#  Last Modified: 2024-11-08 14:48:15
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-08 14:48:16
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames


class MLModelStoreView_IntegrateMLModel(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - INTEGRATE_ML_MODEL_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.INTEGRATE_ML_MODEL_FILES):
            messages.error(self.request, "You do not have permission to integrate ML Model files.")
            return redirect('ml_model_store:list')
        ##############################

        # implement the onnx to pth converter
        # implement the integration view
        # Create and update the boilerplate models JSON
        # Page HTML adjustments (search, buttons, quality, ui/ux, etc)
        return None


Contents of ../../apps/ml_model_store/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-08 14:36:41
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-08 14:36:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .store_ml_models_list_views import *
from .integrate_ml_models_views import *


Contents of ../../apps/ml_model_store/views/store_ml_models_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: store_ml_models_list_views.py
#  Last Modified: 2024-11-08 14:44:27
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-08 14:45:54
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#  Project: Bimod.io™
#  File: store_ml_models_list_views.py
#  Last Modified: 2024-11-08 14:38:25
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-08 14:38:26
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from collections import defaultdict

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_ml_models.models import DataSourceMLModelConnection
from apps.ml_model_store.models import MLModelIntegration
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MLModelStoreView_StoreMLModelsList(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ML_MODEL_INTEGRATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ML_MODEL_INTEGRATIONS):
            messages.error(self.request, "You do not have permission to list ML Model Integrations.")
            return context
        ##############################

        all_ml_integrations = MLModelIntegration.objects.all()
        category_groups = defaultdict(list)
        for ml_integration in all_ml_integrations:
            category_groups[ml_integration.get_model_category_display()].append(ml_integration)

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        ml_store_connections = DataSourceMLModelConnection.objects.filter(assistant__organization__in=user_orgs)

        context['category_groups'] = dict(category_groups)
        context['ml_store_connections'] = ml_store_connections
        return context


Contents of ../../apps/smart_contracts/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-19 22:24:24
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:24:25
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .wallet import *
from .contract import *


Contents of ../../apps/smart_contracts/views/contract/list_smart_contracts_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_smart_contracts_views.py
#  Last Modified: 2024-10-19 22:33:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:33:17
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.organization.models import Organization
from apps.smart_contracts.models import BlockchainSmartContract
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class SmartContractView_ContractList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['contracts_by_org'] = self.get_smart_contracts_by_organization()
        return context

    def get_smart_contracts_by_organization(self):
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        wallet_connections_by_org = {}
        for org in user_orgs:
            wallet_connections = BlockchainSmartContract.objects.filter(wallet__organization=org)
            wallet_connections_by_org[org] = wallet_connections
        return wallet_connections_by_org


Contents of ../../apps/smart_contracts/views/contract/generate_smart_contract_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: generate_smart_contract_views.py
#  Last Modified: 2024-10-20 23:20:28
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-20 23:20:29
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.smart_contracts.smart_contracts_executor import SmartContractsExecutionManager
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.smart_contracts.models import BlockchainSmartContract
from web_project import TemplateLayout
from apps.smart_contracts.utils import GenerateSmartContractViewActionTypes, DeploymentStatusesNames


logger = logging.getLogger(__name__)


class SmartContractView_ContractGenerate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        contract_id = kwargs.get('pk')
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        contract = BlockchainSmartContract.objects.get(id=contract_id)
        llm_models = LLMCore.objects.filter(organization__in=user_orgs)
        context['contract'] = contract
        context['llm_models'] = llm_models
        return context

    def post(self, request, *args, **kwargs):
        contract_id = kwargs.get('pk')
        action_type = request.POST.get('action_type')
        contract_object: BlockchainSmartContract = BlockchainSmartContract.objects.get(id=contract_id)

        if action_type == GenerateSmartContractViewActionTypes.GENERATE_CONTRACT:
            original_prompt = request.POST.get('creation_prompt')
            previous_mistakes_prompt = request.POST.get('previous_mistakes_prompt', '')

            if original_prompt != contract_object.creation_prompt:
                contract_object.creation_prompt = original_prompt
                logger.info(f"Updated original_prompt for contract: {contract_object}")
                contract_object.save()

            llm_id = request.POST.get('llm_id')
            llm_core_model = LLMCore.objects.get(id=llm_id)
            try:
                xc = SmartContractsExecutionManager(smart_contract_object=contract_object, llm_model=llm_core_model)
            except Exception as e:
                messages.error(request, f"Error occurred while initializing SmartContractsExecutionManager: {e}")
                return redirect('smart_contracts:contract_generate', pk=kwargs.get('pk'))

            response, error = xc.generate_contract_and_save_content(previous_mistakes_prompt=previous_mistakes_prompt)
            if error is not None or response is False:
                contract_object.deployment_status = DeploymentStatusesNames.FAILED
                contract_object.save()
                messages.error(request, f"Error occurred while generating the contract: {error}")
                return redirect('smart_contracts:contract_generate', pk=kwargs.get('pk'))

            messages.success(request, f"Contract generated successfully.")
            return redirect('smart_contracts:contract_generate', pk=kwargs.get('pk'))

        elif action_type == GenerateSmartContractViewActionTypes.SIGN_AND_DEPLOY_CONTRACT:
            response, error = SmartContractsExecutionManager.deploy_contract(contract_obj=contract_object)
            if error is not None or response is False:
                contract_object.deployment_status = DeploymentStatusesNames.FAILED
                contract_object.save()
                messages.error(request, f"Error occurred while signing and deploying the contract: {error}")
                return redirect('smart_contracts:contract_generate', pk=kwargs.get('pk'))

            messages.success(request, f"Contract signed and deployed successfully.")
            return redirect('smart_contracts:contract_generate', pk=kwargs.get('pk'))

        else:
            messages.error(request, f"Invalid action type: {action_type}")
            return redirect('smart_contracts:contract_generate', pk=kwargs.get('pk'))




Contents of ../../apps/smart_contracts/views/contract/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-19 22:32:46
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:32:46
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .create_smart_contract_views import *
from .list_smart_contracts_views import *
from .soft_delete_smart_contracts_views import *
from .generate_smart_contract_views import *
from .update_deploy_status_contract_views import *


Contents of ../../apps/smart_contracts/views/contract/update_deploy_status_contract_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_deploy_status_contract_views.py
#  Last Modified: 2024-10-21 02:00:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-21 02:00:17
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.smart_contracts.smart_contracts_executor import SmartContractsExecutionManager
from apps.smart_contracts.models import BlockchainSmartContract
from apps.smart_contracts.utils import DeploymentStatusesNames

logger = logging.getLogger(__name__)


class SmartContractView_ContractUpdateDeployStatus(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        contract_id = kwargs.get('pk')
        contract_object: BlockchainSmartContract = BlockchainSmartContract.objects.get(id=contract_id)

        # NOT STAGED YET
        if contract_object.tx_hash is None:
            logger.info(f"This contract is not yet staged for deployment. Please proceed with the deployment "
                        f"process to check the updates.")
            messages.error(request, f"This contract is not yet staged for deployment. Please proceed with "
                                    f"the deployment process to check the updates.")
            return redirect('smart_contracts:contract_list')

        # ALREADY DEPLOYED
        if contract_object.deployment_status == DeploymentStatusesNames.DEPLOYED:
            logger.info(f"This contract is already deployed. Please check the transaction receipt details of "
                        f"the contract.")
            messages.error(request, f"This contract is already deployed. Please check the transaction receipt "
                                    f"details of your contract.")
            return redirect('smart_contracts:contract_list')

        # CHECKING PERMISSION GRANTED: DEPLOYMENT ONGOING
        status, error = SmartContractsExecutionManager.check_deployment_status(contract_obj=contract_object)

        if error is not None:
            messages.warning(request, f"No updates found for the contract deployment status (yet).")
            return redirect('smart_contracts:contract_list')
        return redirect('smart_contracts:contract_list')

        if status is True:
            logger.info(f"The smart contract has been deployed successfully. Please check the transaction "
                        f"receipt for details.")
            messages.success(request, f"Your contract has been deployed successfully. Please check the "
                                      f"transaction receipt for details.")
            return redirect('smart_contracts:contract_list')

        messages.error(request, f"An error occurred while checking the deployment status of your contract. "
                                f"Please try again later.")
        return redirect('smart_contracts:contract_list')


Contents of ../../apps/smart_contracts/views/contract/soft_delete_smart_contracts_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_smart_contracts_views.py
#  Last Modified: 2024-10-19 22:33:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:33:27
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.smart_contracts.models import BlockchainSmartContract
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SmartContractView_ContractSoftDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        contract_id = self.kwargs.get('pk')
        context['contract'] = get_object_or_404(BlockchainSmartContract, id=contract_id)
        return context

    def post(self, request, *args, **kwargs):
        contract_id = self.kwargs.get('pk')
        contract = get_object_or_404(BlockchainSmartContract, id=contract_id)

        try:
            contract.delete()
        except Exception as e:
            logger.error(f"An error occurred while soft-deleting the smart contract: {str(e)}")
            messages.error(request, f"An error occurred while soft-deleting the smart contract: {str(e)}")
            return redirect('smart_contracts:contract_detail', pk=contract_id)
        
        logger.info(f"Smart contract {contract_id} soft-deleted.")
        messages.success(request, f'Smart contract "{contract}" has been successfully deleted.')
        return redirect('smart_contracts:contract_list')


Contents of ../../apps/smart_contracts/views/contract/create_smart_contract_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_smart_contract_views.py
#  Last Modified: 2024-10-19 22:33:09
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:33:09
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.organization.models import Organization
from apps.smart_contracts.models import BlockchainWalletConnection, BlockchainSmartContract
from apps.smart_contracts.utils import SMART_CONTRACT_CATEGORIES, SMART_CONTRACT_TEMPLATE_CHOICES
from config.settings import SMART_CONTRACT_CREATION
from web_project import TemplateLayout
from apps.smart_contracts.utils import DeploymentStatusesNames

logger = logging.getLogger(__name__)


class SmartContractView_ContractCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['wallet_connections'] = BlockchainWalletConnection.objects.filter(
            organization__in=context['organizations'])
        context['contract_categories'] = SMART_CONTRACT_CATEGORIES
        context['contract_templates'] = SMART_CONTRACT_TEMPLATE_CHOICES
        context['SMART_CONTRACT_CREATION'] = round(float(SMART_CONTRACT_CREATION), 2)
        return context

    def post(self, request, *args, **kwargs):
        wallet_id = request.POST.get('wallet')
        category = request.POST.get('category')
        nickname = request.POST.get('nickname')
        description = request.POST.get('description')
        contract_template = request.POST.get('contract_template')
        refinement_iterations = request.POST.get('refinement_iterations')
        offchain_contract_seed = request.POST.get('offchain_contract_seed')

        maximum_gas_limit = request.POST.get('maximum_gas_limit')
        gas_price_gwei = request.POST.get('gas_price_gwei')

        if not all([wallet_id, category, contract_template]):
            logger.error('All fields are required.')
            messages.error(request, 'All fields are required.')
            return redirect('smart_contracts:contract_create')

        try:
            wallet = BlockchainWalletConnection.objects.get(id=wallet_id)
            created_by_user = request.user
            smart_contract = BlockchainSmartContract.objects.create(
                wallet=wallet, category=category, contract_template=contract_template,
                nickname=nickname, description=description,
                refinement_iterations_before_evaluation=refinement_iterations,
                created_by_user=created_by_user, deployment_status=DeploymentStatusesNames.NOT_GENERATED,
                deployed_at=None,
                maximum_gas_limit=maximum_gas_limit, gas_price_gwei=gas_price_gwei,
                offchain_contract_seed=offchain_contract_seed)
        except Exception as e:
            logger.error(f'An error occurred while creating the smart contract: {str(e)}')
            messages.error(request, f'An error occurred while creating the smart contract: {str(e)}')
            return redirect('smart_contracts:contract_create')

        logger.info(f'Smart contract created successfully. Smart Contract ID: {smart_contract.id}')
        messages.success(request, 'Smart contract created successfully.')
        return redirect('smart_contracts:contract_list')


Contents of ../../apps/smart_contracts/views/wallet/update_wallet_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_wallet_connection_views.py
#  Last Modified: 2024-10-19 22:33:59
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:33:59
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib.auth.mixins import LoginRequiredMixin

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.smart_contracts.utils import DEFAULT_WEI_UNIT
from apps.user_permissions.utils import PermissionNames
from config import settings
from web_project import TemplateLayout
from django.shortcuts import get_object_or_404, redirect
from django.contrib import messages
from django.urls import reverse
from django.utils import timezone
from web3 import Web3
from apps.smart_contracts.models import BlockchainWalletConnection
from apps.organization.models import Organization
from django.views.generic import TemplateView

logger = logging.getLogger(__name__)


class SmartContractView_WalletConnectionUpdate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        wallet_connection_id = self.kwargs.get('pk')
        wallet_connection = get_object_or_404(BlockchainWalletConnection, pk=wallet_connection_id)
        context['wallet_connection'] = wallet_connection
        context['organizations'] = Organization.objects.filter(
            users__in=[self.request.user]
        )
        context['blockchain_types'] = BlockchainWalletConnection._meta.get_field('blockchain_type').choices
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_BLOCKCHAIN_WALLET_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_BLOCKCHAIN_WALLET_CONNECTIONS):
            messages.error(self.request, "You do not have permission to update Blockchain Wallet Connections.")
            return redirect('smart_contracts:wallet_connection_list')
        ##############################

        wallet_connection_id = self.kwargs.get('pk')
        wallet_connection = get_object_or_404(BlockchainWalletConnection, pk=wallet_connection_id)

        organization_id = request.POST.get('organization')
        nickname = request.POST.get('nickname')
        blockchain_type = request.POST.get('blockchain_type')
        wallet_address = request.POST.get('wallet_address')
        wallet_private_key = request.POST.get('wallet_private_key')
        description = request.POST.get('description')

        if not all([organization_id, nickname, blockchain_type, wallet_address, wallet_private_key]):
            messages.error(request, 'All fields are required.')
            return redirect(reverse('smart_contracts:wallet_connection_update', kwargs={'pk': wallet_connection_id}))

        organization = get_object_or_404(Organization, id=organization_id)

        try:
            wallet_connection.organization = organization
            wallet_connection.nickname = nickname
            wallet_connection.blockchain_type = blockchain_type
            wallet_connection.wallet_address = wallet_address
            wallet_connection.wallet_private_key = wallet_private_key
            wallet_connection.description = description
            wallet_connection.updated_at = timezone.now()
            wallet_connection.save()

            connection_response = self.attempt_wallet_connection(wallet_address=wallet_address)
            if not connection_response:
                logger.error('Error while connecting to wallet.')
                messages.error(request, 'Error while connecting to wallet, please check your credentials.')
                return redirect('smart_contracts:wallet_connection_create')

            if self.sync_wallet_balance(wallet_connection):
                logger.info('Wallet connection updated and balance synced successfully.')
                messages.success(request, 'Wallet connection updated and balance synced successfully.')
            else:
                logger.warning('Wallet connection updated, but balance sync failed.')
                messages.warning(request, 'Wallet connection updated, but balance sync failed.')
        except Exception as e:
            logger.error(f'An error occurred while updating the wallet connection: {str(e)}')
            messages.error(request, f'An error occurred while updating the wallet connection: {str(e)}')
            return redirect(reverse('smart_contracts:wallet_connection_update', kwargs={'pk': wallet_connection_id}))

        return redirect(reverse('smart_contracts:wallet_connection_list'))

    def attempt_wallet_connection(self, wallet_address: str):
        infura_url = settings.INFURA_URL
        web3 = Web3(Web3.HTTPProvider(infura_url))
        if not web3.is_connected():
            logger.error('Web3 connection failed.')
            return False
        try:
            wei_balance = web3.eth.get_balance(wallet_address)
            eth_balance = Web3.from_wei(wei_balance, DEFAULT_WEI_UNIT)
            logger.info('Successfully connected to wallet.')
            return True
        except Exception as e:
            logger.error('Error while connecting to wallet: ' + str(e))
            return False

    def sync_wallet_balance(self, wallet_connection):
        infura_url = settings.INFURA_URL
        web3 = Web3(Web3.HTTPProvider(infura_url))
        if not web3.is_connected():
            logger.error('Web3 connection failed.')
            return False

        try:
            wei_balance = web3.eth.get_balance(wallet_connection.wallet_address)
            eth_balance = Web3.from_wei(wei_balance, DEFAULT_WEI_UNIT)
            wallet_connection.wallet_balance = eth_balance
            wallet_connection.balance_last_synced_at = timezone.now()
            wallet_connection.save()
            logger.info('Wallet balance synced successfully.')
            return True
        except Exception as e:
            logger.error('Error while syncing wallet balance: ' + str(e))
            return False


Contents of ../../apps/smart_contracts/views/wallet/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-19 22:32:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:32:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .create_wallet_connection_views import *
from .delete_wallet_connection_views import *
from .list_wallet_connections_views import *
from .update_wallet_connection_views import *
from .sync_wallet_public_data_views import *


Contents of ../../apps/smart_contracts/views/wallet/sync_wallet_public_data_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: sync_wallet_public_data_views.py
#  Last Modified: 2024-10-20 23:02:57
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-20 23:02:58
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.utils import timezone
from django.views import View
from web3 import Web3

from apps.smart_contracts.models import BlockchainWalletConnection
from apps.smart_contracts.utils import DEFAULT_WEI_UNIT
from config import settings

logger = logging.getLogger(__name__)


class SmartContractView_SyncWalletPublicData(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        wallet_id = kwargs.get('pk')
        wallet = BlockchainWalletConnection.objects.get(id=wallet_id)
        self.sync_wallet_public_data(wallet)
        return redirect('smart_contracts:wallet_connection_list')

    def sync_wallet_public_data(self, wallet):
        success = self.sync_wallet_balance(wallet_connection=wallet)
        if success:
            logger.info(f'Wallet public data synced successfully. Wallet_id: {wallet.id}')
        else:
            logger.error(f'Error while syncing wallet public data. Wallet_id: {wallet.id}')

    def sync_wallet_balance(self, wallet_connection):
        infura_url = settings.INFURA_URL
        web3 = Web3(Web3.HTTPProvider(infura_url))
        if not web3.is_connected():
            logger.error('Web3 connection failed.')
            return False
        try:
            wei_balance = web3.eth.get_balance(wallet_connection.wallet_address)
            eth_balance = Web3.from_wei(wei_balance, DEFAULT_WEI_UNIT)
            wallet_connection.wallet_balance = eth_balance
            wallet_connection.balance_last_synced_at = timezone.now()
            wallet_connection.save()
            return True
        except Exception as e:
            logger.error('Error while syncing wallet balance: ' + str(e))
            return False


Contents of ../../apps/smart_contracts/views/wallet/delete_wallet_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_wallet_connection_views.py
#  Last Modified: 2024-10-19 22:33:50
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:33:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.smart_contracts.models import BlockchainWalletConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SmartContractView_WalletConnectionDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        wallet_connection_id = self.kwargs.get('pk')
        wallet_connection = get_object_or_404(BlockchainWalletConnection, pk=wallet_connection_id)
        context['wallet_connection'] = wallet_connection
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_BLOCKCHAIN_WALLET_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BLOCKCHAIN_WALLET_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete Blockchain Wallet Connections.")
            return redirect('smart_contracts:wallet_connection_list')
        ##############################

        wallet_connection_id = self.kwargs.get('pk')
        wallet_connection = get_object_or_404(BlockchainWalletConnection, pk=wallet_connection_id)

        try:
            wallet_connection.delete()
        except Exception as e:
            logger.error(f"An error occurred while deleting the wallet connection: {str(e)}")
            messages.error(request, f"An error occurred while deleting the wallet connection: {str(e)}")
            return redirect('smart_contracts:wallet_connection_detail', pk=wallet_connection_id)

        logger.info(f'Wallet connection deleted. Wallet_connection_id: {wallet_connection_id}')
        messages.success(request, 'Wallet connection deleted successfully.')
        return redirect('smart_contracts:wallet_connection_list')


Contents of ../../apps/smart_contracts/views/wallet/list_wallet_connections_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_wallet_connections_views.py
#  Last Modified: 2024-10-19 22:34:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:34:16
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView
from apps.smart_contracts.models import BlockchainWalletConnection
from apps.organization.models import Organization


class SmartContractView_WalletConnectionList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_BLOCKCHAIN_WALLET_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_BLOCKCHAIN_WALLET_CONNECTIONS):
            messages.error(self.request, "You do not have permission to list Blockchain Wallet Connections.")
            return context
        ##############################

        context['wallet_connections_by_org'] = self.get_wallet_connections_grouped_by_org()
        return context

    def get_wallet_connections_grouped_by_org(self):
        organizations = Organization.objects.filter(users__in=[self.request.user])
        wallet_connections_by_org = {}

        for org in organizations:
            wallet_connections = BlockchainWalletConnection.objects.filter(organization=org)
            wallet_connections_by_org[org] = wallet_connections

        return wallet_connections_by_org


Contents of ../../apps/smart_contracts/views/wallet/create_wallet_connection_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_wallet_connection_views.py
#  Last Modified: 2024-10-19 22:33:43
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:33:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

from django.contrib import messages
from django.shortcuts import redirect
from django.urls import reverse
from django.views.generic import TemplateView
from django.utils import timezone
from django.conf import settings
from web3 import Web3

from apps.smart_contracts.models import BlockchainWalletConnection
from apps.organization.models import Organization
from apps.smart_contracts.utils import BLOCKCHAIN_TYPE, DEFAULT_WEI_UNIT

logger = logging.getLogger(__name__)


class SmartContractView_WalletConnectionCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(
            users__in=[self.request.user]
        )
        context['blockchain_types'] = BLOCKCHAIN_TYPE
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_BLOCKCHAIN_WALLET_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_BLOCKCHAIN_WALLET_CONNECTIONS):
            messages.error(self.request, "You do not have permission to create Blockchain Wallet Connections.")
            return redirect('smart_contracts:wallet_connection_list')
        ##############################

        organization_id = request.POST.get('organization')
        nickname = request.POST.get('nickname')
        description = request.POST.get('description')
        blockchain_type = request.POST.get('blockchain_type')
        wallet_address = request.POST.get('wallet_address')
        wallet_private_key = request.POST.get('wallet_private_key')

        if not all([organization_id, nickname, blockchain_type, wallet_address, wallet_private_key]):
            logger.error('All fields are required.')
            messages.error(request, 'All fields are required.')
            return redirect(reverse('smart_contracts:wallet_connection_create'))

        try:
            organization = Organization.objects.get(id=organization_id)
            created_by_user = request.user

            connection_response = self.attempt_wallet_connection(wallet_address=wallet_address)
            if not connection_response:
                logger.error('Error while connecting to wallet.')
                messages.error(request, 'Error while connecting to wallet, please check your credentials.')
                return redirect('smart_contracts:wallet_connection_create')

            wallet_connection = BlockchainWalletConnection.objects.create(
                organization=organization, blockchain_type=blockchain_type, nickname=nickname,
                description=description, wallet_address=wallet_address, wallet_private_key=wallet_private_key,
                created_by_user=created_by_user)

            if self.sync_wallet_balance(wallet_connection):
                logger.info('Wallet connection created and balance synced successfully.')
                messages.success(request, 'Wallet connection created and balance synced successfully.')
            else:
                logger.warning('Wallet connection created, but balance sync failed.')
                messages.warning(request, 'Wallet connection created, but balance sync failed.')

        except Exception as e:
            logger.error(f'An error occurred while creating the wallet connection: {str(e)}')
            messages.error(request, f'An error occurred while creating the wallet connection: {str(e)}')
            return redirect(reverse('smart_contracts:wallet_connection_create'))

        return redirect(reverse('smart_contracts:wallet_connection_list'))

    def attempt_wallet_connection(self, wallet_address: str):
        infura_url = settings.INFURA_URL
        web3 = Web3(Web3.HTTPProvider(infura_url))
        if not web3.is_connected():
            logger.error('Web3 connection failed.')
            return False
        try:
            wei_balance = web3.eth.get_balance(wallet_address)
            eth_balance = Web3.from_wei(wei_balance, DEFAULT_WEI_UNIT)
            return True
        except Exception as e:
            logger.error('Error while connecting to wallet: ' + str(e))
            return False

    def sync_wallet_balance(self, wallet_connection):
        infura_url = settings.INFURA_URL
        web3 = Web3(Web3.HTTPProvider(infura_url))
        if not web3.is_connected():
            logger.error('Web3 connection failed.')
            return False
        try:
            wei_balance = web3.eth.get_balance(wallet_connection.wallet_address)
            eth_balance = Web3.from_wei(wei_balance, DEFAULT_WEI_UNIT)
            wallet_connection.wallet_balance = eth_balance
            wallet_connection.balance_last_synced_at = timezone.now()
            wallet_connection.save()
            return True
        except Exception as e:
            logger.error('Error while syncing wallet balance: ' + str(e))
            return False


Contents of ../../apps/mm_apis/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .store import *
from .api import *


Contents of ../../apps/mm_apis/views/api/delete_api_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_api_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_apis.models import CustomAPI
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CustomAPIView_Delete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        custom_api_id = self.kwargs.get('pk')
        custom_api = CustomAPI.objects.get(id=custom_api_id)
        context['custom_api'] = custom_api
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_APIS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_APIS):
            messages.error(self.request, "You do not have permission to delete custom APIs.")
            return redirect('mm_apis:list')
        ##############################

        custom_api_id = self.kwargs.get('pk')
        custom_api = CustomAPI.objects.get(id=custom_api_id)

        try:
            custom_api.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the custom API: " + str(e))
            return redirect("mm_apis:list")

        logger.info(f"Custom API was deleted by User: {self.request.user.id}.")
        messages.success(request, "Custom API deleted successfully.")
        return redirect('mm_apis:list')


Contents of ../../apps/mm_apis/views/api/connections_apis_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: connections_apis_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.mm_apis.models import CustomAPI, CustomAPIReference
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomAPIView_Connections(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user
        conn_orgs = Organization.objects.filter(users__in=[user])
        users_of_conn_orgs = [user for org in conn_orgs for user in org.users.all()]
        apis = CustomAPI.objects.filter(created_by_user__in=users_of_conn_orgs)
        ext_api_refs = CustomAPIReference.objects.filter(assistant__organization__in=conn_orgs).exclude(
            custom_api__created_by_user__in=users_of_conn_orgs)
        agents = Assistant.objects.filter(organization__in=conn_orgs).select_related('organization')
        agent_api_map = {
            assistant.id: CustomAPIReference.objects.filter(
                assistant=assistant, custom_api__created_by_user__in=users_of_conn_orgs) for assistant in agents }

        ext_api_refs_map = {
            assistant.id: set(
                ref for ref in ext_api_refs if ref.assistant.id == assistant.id)
            for assistant in agents
        }
        context.update({
            'connected_organizations': conn_orgs, 'apis': apis, 'assistants': agents,
            'assistant_api_map': agent_api_map, 'external_api_references_map': ext_api_refs_map
        })
        logger.info(f"User: {self.request.user.id} is connecting APIs.")
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_APIS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_APIS):
            messages.error(self.request, "You do not have permission to update custom APIs.")
            return redirect('mm_apis:list')
        ##############################

        agent_id = request.POST.get('assistant_id')
        api_id = request.POST.get('api_id')
        action = request.POST.get('action')

        if not agent_id or not action:
            logger.error(f"Invalid input. Please try again.")
            messages.error(request, "Invalid input. Please try again.")
            return redirect('mm_apis:connect')
        try:
            agent = Assistant.objects.get(id=agent_id)
            if action == 'add' and api_id:
                custom_api = CustomAPI.objects.get(id=api_id)
                CustomAPIReference.objects.create(assistant=agent, custom_api=custom_api, created_by_user=request.user)
                logger.info(f"API '{custom_api.name}' assigned to assistant '{agent.name}'.")
                messages.success(request, f"API '{custom_api.name}' assigned to assistant '{agent.name}'.")
            elif action == 'remove':
                ref_id = request.POST.get('reference_id')
                if ref_id:
                    reff = CustomAPIReference.objects.get(id=ref_id)
                    reff.delete()
                    logger.info(f"API reference removed from assistant '{agent.name}'.")
                    messages.success(request, f"API reference removed from assistant '{agent.name}'.")
        except Assistant.DoesNotExist:
            logger.error(f"Assistant not found.")
            messages.error(request, "Assistant not found.")
        except CustomAPI.DoesNotExist:
            logger.error(f"Custom API not found.")
            messages.error(request, "Custom API not found.")
        except CustomAPIReference.DoesNotExist:
            logger.error(f"Custom API Reference not found.")
            messages.error(request, "Custom API Reference not found.")
        return redirect('mm_apis:connect')


Contents of ../../apps/mm_apis/views/api/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .create_api_views import *
from .list_apis_views import *
from .delete_api_views import *
from .connections_apis_views import *


Contents of ../../apps/mm_apis/views/api/create_api_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_api_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.mm_apis.forms import CustomAPIForm
from apps.mm_apis.utils import CATEGORIES_OF_CUSTOM_APIS, CUSTOM_API_AUTHENTICATION_TYPES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomAPIView_Create(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = CustomAPIForm()
        context['CUSTOM_API_CATEGORIES'] = CATEGORIES_OF_CUSTOM_APIS
        context['CUSTOM_API_AUTHENTICATION_TYPES'] = CUSTOM_API_AUTHENTICATION_TYPES
        return context

    def post(self, request, *args, **kwargs):
        form = CustomAPIForm(request.POST, request.FILES)

        ##############################
        # PERMISSION CHECK FOR - ADD_APIS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_APIS):
            messages.error(self.request, "You do not have permission to add custom APIs.")
            return redirect('mm_apis:list')
        ##############################

        if form.is_valid():
            custom_api = form.save(commit=False)
            custom_api.created_by_user = request.user
            endpoints = {}
            endpoint_keys = [key for key in request.POST.keys() if key.startswith('endpoints[')]
            endpoint_indices = set(key.split('[')[1].split(']')[0] for key in endpoint_keys)
            for i in endpoint_indices:
                name = request.POST.get(f'endpoints[{i}][name]')
                if name:
                    endpoint_data = {
                        'description': request.POST.get(f'endpoints[{i}][description]', ''),
                        'path': request.POST.get(f'endpoints[{i}][path]', ''),
                        'method': request.POST.get(f'endpoints[{i}][method]', ''),
                        'header_params': request.POST.getlist(f'endpoints[{i}][header_params][]'),
                        'path_params': request.POST.getlist(f'endpoints[{i}][path_params][]'),
                        'query_params': request.POST.getlist(f'endpoints[{i}][query_params][]'),
                        'body_params': request.POST.getlist(f'endpoints[{i}][body_params][]')
                    }
                    endpoints[name] = endpoint_data
            custom_api.endpoints = endpoints
            if request.FILES.get('api_picture'):
                custom_api.api_picture = request.FILES.get('api_picture')
            custom_api.categories = request.POST.getlist('categories')
            custom_api.save()
            logger.info(f"Custom API was created by User: {self.request.user.id}.")
            return redirect('mm_apis:list')
        return render(request, self.template_name, {'form': form, 'assistants': Assistant.objects.filter(
            organization__users__in=[request.user])})


Contents of ../../apps/mm_apis/views/api/list_apis_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_apis_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.core.paginator import Paginator
from django.db.models import Q
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_apis.models import CustomAPI
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomAPIView_List(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_APIS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_APIS):
            messages.error(self.request, "You do not have permission to list custom APIs.")
            return context
        ##############################

        context_user = self.request.user
        conn_orgs = Organization.objects.filter(users__in=[context_user])
        users_of_conn_orgs = User.objects.filter(
            profile__user__in=[user for org in conn_orgs for user in org.users.all()])
        apis_list = CustomAPI.objects.filter(created_by_user__in=users_of_conn_orgs)
        search_query = self.request.GET.get('search', '')
        if search_query:
            apis_list = apis_list.filter(Q(name__icontains=search_query) | Q(description__icontains=search_query))

        paginator = Paginator(apis_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['apis'] = page_obj.object_list
        context['total_apis'] = CustomAPI.objects.count()
        context['public_apis'] = CustomAPI.objects.filter(is_public=True).count()
        context['private_apis'] = CustomAPI.objects.filter(is_public=False).count()
        context['search_query'] = search_query
        logger.info(f"User: {self.request.user.id} is listing custom APIs.")
        return context


Contents of ../../apps/mm_apis/views/store/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .api_store_views import *


Contents of ../../apps/mm_apis/views/store/api_store_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: api_store_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.mm_apis.models import CustomAPI, CustomAPIReference
from apps.mm_apis.utils import CATEGORIES_OF_CUSTOM_APIS
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomAPIView_Store(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        search_query = self.request.GET.get('search', '')
        selected_categories = self.request.GET.getlist('categories')
        apis_list = CustomAPI.objects.filter(is_public=True)
        if search_query:
            apis_list = apis_list.filter(Q(name__icontains=search_query) | Q(description__icontains=search_query))
        if selected_categories:
            apis_list = apis_list.filter(*[Q(categories__icontains=category) for category in selected_categories])

        api_assistant_map = {
            api.id: Assistant.objects.exclude(customapireference__custom_api=api) for api in apis_list
        }

        paginator = Paginator(apis_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['apis'] = page_obj.object_list
        context['total_apis'] = CustomAPI.objects.count()
        context['public_apis'] = CustomAPI.objects.filter(is_public=True).count()
        context['private_apis'] = CustomAPI.objects.filter(is_public=False).count()
        context['search_query'] = search_query
        context['selected_categories'] = selected_categories
        context['CUSTOM_API_CATEGORIES'] = CATEGORIES_OF_CUSTOM_APIS
        context['api_assistant_map'] = api_assistant_map
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_APIS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_APIS):
            messages.error(self.request, "You do not have permission to update custom APIs.")
            return redirect('mm_apis:store')
        ##############################

        action = request.POST.get('action')
        agent_id = request.POST.get('assistant_id')
        if action and action == "add" and agent_id:
            api_id = request.POST.get('api_id')
            if api_id:
                custom_api = CustomAPI.objects.get(id=api_id)
                agent = Assistant.objects.get(id=agent_id)
                CustomAPIReference.objects.create(assistant=agent, custom_api=custom_api, created_by_user=request.user)
                logger.info(f"API '{custom_api.name}' assigned to assistant '{agent.name}'.")
                messages.success(request, f"API '{custom_api.name}' assigned to assistant '{agent.name}'.")
        else:
            logger.error(f"Invalid input. Please try again.")
            messages.error(request, "Invalid input. Please try again.")
        return redirect('mm_apis:store')


Contents of ../../apps/semantor/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-09 15:04:54
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-09 15:04:55
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .semantor_integration_main_page_views import *


Contents of ../../apps/semantor/views/semantor_integration_main_page_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: semantor_integration_main_page_views.py
#  Last Modified: 2024-11-10 00:31:28
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-10 00:31:28
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.semantor.models import SemantorConfiguration
from web_project import TemplateLayout


class SemantorView_Configure(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        config, created = SemantorConfiguration.objects.get_or_create(user=self.request.user)
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['config'] = config
        return context

    def post(self, request, *args, **kwargs):
        try:
            config = SemantorConfiguration.objects.filter(user=request.user).first()
            if config:
                config.is_local_network_active = request.POST.get('is_local_network_active') == 'on'
                config.is_global_network_active = request.POST.get('is_global_network_active') == 'on'
                config.maximum_assistant_search_items = int(
                    request.POST.get('maximum_assistant_search_items', config.maximum_assistant_search_items))
                config.maximum_integration_search_items = int(
                    request.POST.get('maximum_integration_search_items', config.maximum_integration_search_items))
                config.save()
                messages.success(request, "Configuration updated successfully.")
        except Exception as e:
            messages.error(request, f"An error occurred while updating the configuration: {str(e)}")
            return redirect("semantor:configuration")

        return redirect("semantor:configuration")

####################################################################################################


Contents of ../../apps/export_assistants/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .export_assistants import *
from .endpoints import *


Contents of ../../apps/export_assistants/views/endpoints/endpoint_export_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: endpoint_export_assistant_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import json
import logging

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from apps.export_assistants.models import ExportAssistantAPI, RequestLog
from apps.export_assistants.utils import ExportAPIStatusCodes
from apps.multimodal_chat.models import MultimodalChat, MultimodalChatMessage
from apps.multimodal_chat.utils import generate_chat_name, SourcesForMultimodalChatsNames
from config.settings import BASE_URL

logger = logging.getLogger(__name__)


@method_decorator(csrf_exempt, name="dispatch")
class ExportAssistantAPIHealthCheckView(View):
    def post(self, request, *args, **kwargs):
        endpoint = (BASE_URL + request.path).replace("health", "app")
        api_key = request.headers.get('Authorization')
        try:
            export_assistant = ExportAssistantAPI.objects.get(endpoint=endpoint)
        except ExportAssistantAPI.DoesNotExist:
            logger.error(f"Invalid Assistant endpoint: {endpoint}")
            return JsonResponse({
                "message": "Invalid Assistant endpoint", "data": {}, "status": ExportAPIStatusCodes.NOT_FOUND
            }, status=ExportAPIStatusCodes.NOT_FOUND)

        if not export_assistant.is_online:
            logger.error(f"The Assistant endpoint is currently offline: {endpoint}")
            return JsonResponse({
                "message": "The Assistant endpoint is currently offline. Please try again later.", "data": {},
                "status": ExportAPIStatusCodes.SERVICE_OFFLINE
            }, status=ExportAPIStatusCodes.SERVICE_OFFLINE)

        if (not export_assistant.is_public) and export_assistant.custom_api_key != api_key:
            logger.error(f"Invalid Assistant API key provided for endpoint: {endpoint}")
            return JsonResponse({
                "message": "The Assistant API key provided is invalid, please provide a valid API key.", "data": {},
                "status": ExportAPIStatusCodes.UNAUTHORIZED
            }, status=ExportAPIStatusCodes.UNAUTHORIZED)

        return JsonResponse({
                "message": "The Assistant endpoint is online and healthy.", "data": {},
                "status": ExportAPIStatusCodes.OK
            }, status=ExportAPIStatusCodes.OK
        )


@method_decorator(csrf_exempt, name='dispatch')
class ExportAssistantAPIView(View):
    def post(self, request, *args, **kwargs):
        endpoint = BASE_URL + request.path
        api_key = request.headers.get('Authorization')
        try:
            export_assistant = ExportAssistantAPI.objects.get(endpoint=endpoint)
        except ExportAssistantAPI.DoesNotExist:
            logger.error(f"Invalid Assistant endpoint: {endpoint}")
            return JsonResponse({
                "message": "Invalid Assistant endpoint", "data": {}, "status": ExportAPIStatusCodes.NOT_FOUND
            }, status=ExportAPIStatusCodes.NOT_FOUND)

        if not export_assistant.is_online:
            logger.error(f"The Assistant endpoint is currently offline: {endpoint}")
            return JsonResponse({
                "message": "The Assistant endpoint is currently offline. Please try again later.", "data": {},
                "status": ExportAPIStatusCodes.SERVICE_OFFLINE
            }, status=ExportAPIStatusCodes.SERVICE_OFFLINE)

        if (not export_assistant.is_public) and export_assistant.custom_api_key != api_key:
            logger.error(f"Invalid Assistant API key provided for endpoint: {endpoint}")
            return JsonResponse({
                "message": "The Assistant API key provided is invalid, please provide a valid API key.", "data": {},
                "status": ExportAPIStatusCodes.UNAUTHORIZED
            }, status=ExportAPIStatusCodes.UNAUTHORIZED)

        RequestLog.objects.create(export_assistant=export_assistant)
        if export_assistant.requests_in_last_hour() > export_assistant.request_limit_per_hour:
            logger.error(f"The Assistant API request limit has been reached for endpoint: {endpoint}")
            return JsonResponse({
                "error": "The Assistant API request limit has been reached. Please try again later.",
                "data": {
                    "request_limit_per_hour": export_assistant.request_limit_per_hour,
                    "requests_in_last_hour": export_assistant.requests_in_last_hour()
                },
            }, status=ExportAPIStatusCodes.TOO_MANY_REQUESTS)

        body = json.loads(request.body)
        try:
            chat_history = body.get('chat_history')
            if len(chat_history) == 0:
                logger.error(f"Invalid chat history provided for endpoint, no chat history error: {endpoint}")
                raise ValueError("Chat history is empty.")
            if "role" not in chat_history[0]:
                logger.error(f"Invalid chat history provided for endpoint, not existent role field error: {endpoint}")
                raise ValueError("Each of the chat history elements must contain 'role' key, which can either"
                                 "be 'system', 'assistant' or 'user'.")
            if chat_history[0]["role"] not in ["system", "assistant", "user"]:
                logger.error(f"Invalid chat history provided for endpoint, invalid role error: {endpoint}")
                raise ValueError("The 'role' key in the first element of the chat history must be either 'system',"
                                 "'assistant' or 'user'.")
            if "content" not in chat_history[0]:
                logger.error(f"Invalid chat history provided for endpoint, no content in chat history element: {endpoint}")
                raise ValueError("Each of the chat history elements must contain 'content' key.")
            if not isinstance(chat_history[0]["content"], str):
                logger.error(f"Invalid chat history provided for endpoint, content field error: {endpoint}")
                raise ValueError("The 'content' key in the first element of the chat history must be a string.")
        except Exception as e:
            logger.error(f"Invalid chat history provided for endpoint, {e}: {endpoint}")
            return JsonResponse({
                "message": "Internal server error: " + str(e), "data": {},
                "status": ExportAPIStatusCodes.INTERNAL_SERVER_ERROR
            }, status=ExportAPIStatusCodes.INTERNAL_SERVER_ERROR)

        api_chat = MultimodalChat.objects.create(
            organization=export_assistant.assistant.organization, assistant=export_assistant.assistant,
            user=export_assistant.created_by_user, chat_name=generate_chat_name(),
            created_by_user=export_assistant.created_by_user, chat_source=SourcesForMultimodalChatsNames.API)

        user_msg = None
        try:
            for msg in chat_history:
                role = msg["role"]
                content = msg["content"]
                f_uris = []
                img_uris = []
                if "file_uris" in msg and msg["file_uris"] != "":
                    f_uris = msg.get("file_uris", "").split(",") if msg.get("file_uris") else []
                if "image_uris" in msg and msg["image_uris"] != "":
                    img_uris = msg.get("image_uris", "").split(",") if msg.get("image_uris") else []

                f_uris = [uri.strip() for uri in f_uris if uri.strip()] if f_uris else []
                img_uris = [uri.strip() for uri in img_uris if uri.strip()]

                api_chat.chat_messages.create(
                    multimodal_chat=api_chat, sender_type=role.upper(), message_text_content=content,
                    message_file_contents=f_uris, message_image_contents=img_uris
                )
                user_msg = api_chat.chat_messages.filter(sender_type=role.upper()).last()

        except Exception as e:
            logger.error(f"Invalid chat history provided for endpoint, {e}: {endpoint}")
            return JsonResponse({
                "message": "Internal server error: " + str(e),
                "data": {}, "status": ExportAPIStatusCodes.INTERNAL_SERVER_ERROR
            }, status=ExportAPIStatusCodes.INTERNAL_SERVER_ERROR)

        try:
            from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
            llm_client = GenerativeAIDecodeController.get(assistant=export_assistant.assistant,
                                                          multimodal_chat=api_chat)
            llm_response_text, f_uris, img_uris = llm_client.respond(latest_message=user_msg, with_media=True)
            MultimodalChatMessage.objects.create(
                multimodal_chat=api_chat, sender_type='ASSISTANT', message_text_content=llm_response_text
            )
        except Exception as e:
            logger.error(f"Internal server error: {str(e)}")
            return JsonResponse({
                "message": "Internal server error: " + str(e), "data": {},
                "status": ExportAPIStatusCodes.INTERNAL_SERVER_ERROR
            }, status=ExportAPIStatusCodes.INTERNAL_SERVER_ERROR)

        resp_data = {"message": "Success", "data": {
            "metadata": {"organization": {"organization_name": export_assistant.assistant.organization.name, },
                         "assistant": {"assistant_name": export_assistant.assistant.name,
                                       "assistant_description": export_assistant.assistant.description, },
                         "chat": {"chat_name": api_chat.chat_name, }},
            "message": {"assistant_name": export_assistant.assistant.name, "content": llm_response_text,
                        "role": "assistant", "media": {"files": f_uris, "images": img_uris}
                        }}}
        logger.info(f"Export Assistant API response: {resp_data}")
        return JsonResponse(resp_data, status=ExportAPIStatusCodes.OK)


Contents of ../../apps/export_assistants/views/endpoints/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .endpoint_export_assistant_views import *


Contents of ../../apps/export_assistants/views/export_assistants/update_export_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_export_assistants_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.export_assistants.models import ExportAssistantAPI
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ExportAssistantView_Update(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        exp_agent = get_object_or_404(ExportAssistantAPI, pk=self.kwargs['pk'])
        context['export_assistant'] = exp_agent
        context['assistants'] = Assistant.objects.filter(
            organization__users__in=[self.request.user]).all()
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_EXPORT_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_EXPORT_ASSIST):
            messages.error(self.request, "You do not have permission to update Export Assistant APIs.")
            return redirect('export_assistants:list')
        ##############################

        exp_agent = get_object_or_404(ExportAssistantAPI, pk=self.kwargs['pk'])

        try:
            exp_agent.assistant_id = request.POST.get('assistant')
            exp_agent.request_limit_per_hour = request.POST.get('request_limit_per_hour')
            exp_agent.is_public = request.POST.get('is_public') == 'on'
            if exp_agent.assistant_id and exp_agent.request_limit_per_hour:
                exp_agent.save()
                logger.info(f"Export Assistant was updated by User: {request.user.id}.")
                messages.success(request, "Export Assistant updated successfully.")
                return redirect('export_assistants:list')
            else:
                logger.error(f"Error updating Export Assistant by User: {request.user.id}.")
                messages.error(request, "There was an error updating the Export Assistant.")
        except Exception as e:
            logger.error(f"Error updating Export Assistant: {e}")
            messages.error(request, "Error updating Export Assistant.")
            return redirect('export_assistants:list')

        context = self.get_context_data()
        context.update({'export_assistant': exp_agent,
                        'assistants': Assistant.objects.filter(organization__users__in=[self.request.user]).all()})
        return render(request, self.template_name, context)


Contents of ../../apps/export_assistants/views/export_assistants/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_export_assistants_views import *
from .create_export_assistant_views import *
from .delete_export_assistants_views import *
from .update_export_assistants_views import *
from .toggle_service_export_assistants_views import *


Contents of ../../apps/export_assistants/views/export_assistants/create_export_assistant_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_export_assistant_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.user_permissions.utils import PermissionNames
from config.settings import MAX_ASSISTANT_EXPORTS_ORGANIZATION
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExportAssistantView_Create(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_context = self.request.user
        agents = Assistant.objects.filter(organization__users=user_context)
        context["user"] = user_context
        context["assistants"] = agents
        return context

    def post(self, request, *args, **kwargs):
        from apps.export_assistants.models import ExportAssistantAPI
        from apps.export_assistants.management.commands.start_exported_assistants import start_endpoint_for_assistant

        ##############################
        # PERMISSION CHECK FOR - ADD_EXPORT_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_EXPORT_ASSISTANT):
            messages.error(self.request, "You do not have permission to add Export Assistant APIs.")
            return redirect('export_assistants:list')
        ##############################

        agent_id = request.POST.get('assistant')
        agent = get_object_or_404(Assistant, pk=agent_id)
        is_public = request.POST.get('is_public') == 'on'
        limit_req_per_hour = request.POST.get('request_limit_per_hour')

        if ExportAssistantAPI.objects.filter(
            created_by_user=request.user).count() > MAX_ASSISTANT_EXPORTS_ORGANIZATION:
            messages.error(request, f"Maximum number of Export Assistant APIs reached for the organization.")
            return self.render_to_response(self.get_context_data())

        if not agent_id or not limit_req_per_hour:
            messages.error(request, "Assistant ID and Request Limit Per Hour are required.")
            return self.render_to_response(self.get_context_data())

        try:
            new_export_assistant = ExportAssistantAPI.objects.create(
                assistant_id=agent_id, is_public=is_public, request_limit_per_hour=limit_req_per_hour,
                created_by_user=request.user
            )

            org = agent.organization
            org.exported_assistants.add(new_export_assistant)
            org.save()
            start_endpoint_for_assistant(assistant=new_export_assistant)
            logger.info(f"Export Assistant API was created by User: {request.user.id}.")
            messages.success(request, "Export Assistant API created successfully!")
            return redirect("export_assistants:list")
        except Exception as e:
            logger.error(f"Error creating Export Assistant API: {str(e)}")
            messages.error(request, f"Error creating Export Assistant API: {str(e)}")
            return self.render_to_response(self.get_context_data())


Contents of ../../apps/export_assistants/views/export_assistants/delete_export_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_export_assistants_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_assistants.models import ExportAssistantAPI
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ExportAssistantView_Delete(LoginRequiredMixin, DeleteView):
    model = ExportAssistantAPI
    success_url = 'export_assistants:list'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - UPDATE_EXPORT_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_EXPORT_ASSISTANT):
            messages.error(self.request, "You do not have permission to delete Export Assistant APIs.")
            return redirect('export_assistants:list')
        ##############################

        exp_agent = get_object_or_404(ExportAssistantAPI, id=self.kwargs['pk'])
        exp_agent.delete()
        success_message = "Export Assistant deleted successfully."
        org = exp_agent.assistant.organization
        org.exported_assistants.remove(exp_agent)
        org.save()
        logger.info(f"Export Assistant was deleted by User: {request.user.id}.")
        messages.success(request, success_message)
        return redirect(self.success_url)


Contents of ../../apps/export_assistants/views/export_assistants/list_export_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_export_assistants_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_assistants.models import ExportAssistantAPI
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from config import settings
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ExportAssistantView_List(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_EXPORT_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_EXPORT_ASSISTANT):
            messages.error(self.request, "You do not have permission to list Export Assistant APIs.")
            return context
        ##############################

        user_context = self.request.user
        max_exp_agents = settings.MAX_ASSISTANT_EXPORTS_ORGANIZATION

        try:
            org_data = []
            orgs = Organization.objects.filter(users=user_context)
            for org in orgs:
                n_exp_agents = org.exported_assistants.count()
                agents_pct = round((n_exp_agents / max_exp_agents) * 100, 2)
                exp_agents = org.exported_assistants.all()
                for agent in exp_agents:
                    agent.usage_percentage = 100
                org_data.append({'organization': org, 'export_assistants_count': n_exp_agents,
                                 'assistants_percentage': agents_pct, 'export_assistants': exp_agents,
                                 'limit': max_exp_agents})
            exp_agents = ExportAssistantAPI.objects.filter(created_by_user=user_context)
            context["user"] = user_context
            context["organization_data"] = org_data
            context["export_assistants"] = exp_agents
        except Exception as e:
            messages.error(self.request, f"An error occurred: {str(e)}")
            return context

        logger.info(f"Export Assistant APIs were listed for User: {user_context.id}.")
        return context


Contents of ../../apps/export_assistants/views/export_assistants/toggle_service_export_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: toggle_service_export_assistants_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import importlib
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_assistants.models import ExportAssistantAPI
from apps.user_permissions.utils import PermissionNames
from config import settings
from config.settings import EXPORT_API_BASE_URL

logger = logging.getLogger(__name__)


class ExportAssistantView_ToggleService(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        from apps.export_assistants.management.commands.start_exported_assistants import start_endpoint_for_assistant

        exp_agent = get_object_or_404(ExportAssistantAPI, pk=self.kwargs['pk'])
        endpoint = EXPORT_API_BASE_URL + exp_agent.endpoint.split(EXPORT_API_BASE_URL)[1]
        context_user = request.user

        ##############################
        # PERMISSION CHECK FOR - UPDATE_EXPORT_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_EXPORT_ASSIST):
            messages.error(self.request, "You do not have permission to update Export Assistant APIs.")
            return redirect('export_assistants:list')
        ##############################

        try:
            api_urls = getattr(importlib.import_module(settings.ROOT_URLCONF), 'urlpatterns')
            exp_agent.is_online = not exp_agent.is_online
            exp_agent.save()
            if exp_agent.is_online:
                if not any(endpoint in str(url) for url in api_urls):
                    start_endpoint_for_assistant(exp_agent)
        except Exception as e:
            logger.error(f"Error toggling Export Assistant: {e}")
            messages.error(request, "Error toggling Export Assistant.")
            return redirect('export_assistants:list')

        logger.info(f"Export Assistant was toggled by User: {context_user.id}.")
        return redirect('export_assistants:list')

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)


Contents of ../../apps/bmd_academy/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-03 17:20:20
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-03 17:20:20
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .academy_courses_list_views import *
from .academy_courses_detail_views import *


Contents of ../../apps/bmd_academy/views/academy_courses_list_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: academy_courses_list_views.py
#  Last Modified: 2024-11-03 20:04:41
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-03 20:04:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.views.generic import TemplateView

from apps.bmd_academy.models import AcademyCourse
from web_project import TemplateLayout, TemplateHelper

logger = logging.getLogger(__name__)


class AcademyView_CourseList(TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
        })
        context['courses'] = AcademyCourse.objects.order_by("created_at").all()

        try:
            amount_videos_by_course = {}
            for course in context['courses']:
                sections = course.sections.all()
                amount_videos = 0
                for section in sections:
                    amount_videos += section.videos.count()
                amount_videos_by_course[course.id] = amount_videos
            context['amount_videos_by_course'] = amount_videos_by_course
        except Exception as e:
            logger.error(f"[AcademyView_CourseList] Error fetching the Academy Courses: {e}")
            return context

        return context


Contents of ../../apps/bmd_academy/views/academy_courses_detail_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: academy_courses_detail_views.py
#  Last Modified: 2024-11-03 20:04:52
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-03 20:04:52
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.db.models import Prefetch
from django.views.generic import TemplateView

from apps.bmd_academy.models import AcademyCourse, AcademyCourseSection, AcademyCourseVideo
from web_project import TemplateLayout, TemplateHelper

logger = logging.getLogger(__name__)


class AcademyView_CourseDetail(TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context.update({
            "layout": "blank", "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
        })

        try:
            course = AcademyCourse.objects.prefetch_related(
                Prefetch(
                    'sections',
                    queryset=AcademyCourseSection.objects.order_by('created_at').prefetch_related(
                        Prefetch(
                            'videos',
                            queryset=AcademyCourseVideo.objects.order_by('created_at'))
                    )
                )
            ).get(course_slug=self.kwargs['slug'])
            context['course'] = course
        except Exception as e:
            logger.error(f"[AcademyView_CourseDetail] Error fetching the Academy Course: {e}")
            return context

        return context


Contents of ../../apps/user_settings/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .settings import *
from .deletions import *
from .automated_backups import *


Contents of ../../apps/user_settings/views/settings/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .user_settings_views import *


Contents of ../../apps/user_settings/views/settings/user_settings_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: user_settings_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class SettingsView_UserSettings(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        logger.info(f"User Settings page was accessed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/user_settings/views/automated_backups/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .toggle_automated_backups_views import *


Contents of ../../apps/user_settings/views/automated_backups/toggle_automated_backups_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: toggle_automated_backups_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View


logger = logging.getLogger(__name__)


class SettingsView_ToggleAutoBackups(LoginRequiredMixin, View):

    def post(self, request, *args, **kwargs):
        try:
            user = request.user
            user.profile.automated_data_backups = not user.profile.automated_data_backups
            user.profile.save()
        except Exception as e:
            logger.error(f"An error occurred while trying to toggle automated backups: {str(e)}")
            messages.error(request, f"An error occurred while trying to toggle automated backups: {str(e)}")
            return redirect('user_settings:settings')
        logger.info(f"Automated backups have been {'enabled' if user.profile.automated_data_backups else 'disabled'} "
                    f"by User: {user.id}.")
        messages.success(request,
                         f"Automated backups have been {'enabled' if user.profile.automated_data_backups else 'disabled'}.")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_video_generator_connections_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_video_generator_connections_views.py
#  Last Modified: 2024-10-17 12:46:02
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 12:46:27
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllVideoGeneratorConnections(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_connections = VideoGeneratorConnection.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL VIDEO GENERATOR CONNECTIONS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL VIDEO GENERATOR CONNECTIONS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_VIDEO_GENERATOR_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_VIDEO_GENERATOR_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete video generator connections.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for video_generator_connection in user_connections:
                video_generator_connection.delete()
            logger.info(f"All video generator connections associated with User: {user.id} have been deleted.")
            messages.success(request, "All video generator connections associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting video generator connections: {e}")
            messages.error(request, f"Error deleting video generator connections: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_organizations_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_organizations_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllOrganizations(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs: Organization = Organization.objects.filter(users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL ORGANIZATIONS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL ORGANIZATIONS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_ORGANIZATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ORGANIZATIONS):
            messages.error(self.request, "You do not have permission to delete organizations.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for org in user_orgs:
                org.delete()
            messages.success(request, "All organizations associated with your account have been deleted.")
            logger.info(f"All organizations associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting organizations: {e}")
            logger.error(f"Error deleting organizations: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_binexus_processes_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_binexus_processes_views.py
#  Last Modified: 2024-10-22 20:32:30
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 20:32:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.binexus.models import BinexusProcess
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllBinexusProcesses(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        binexus_processes = BinexusProcess.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL BINEXUS PROCESSES':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL BINEXUS PROCESSES'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_BINEXUS_PROCESSES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BINEXUS_PROCESSES):
            messages.error(self.request, "You do not have permission to delete binexus processes.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for binexus_process in binexus_processes:
                binexus_process.delete()
            logger.info(f"All Binexus processes associated with User: {user.id} have been deleted.")
            messages.success(request, "All Binexus processes associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting binexus processes: {e}")
            messages.error(request, f"Error deleting binexus processes: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_harmoniq_agents_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_harmoniq_agents_views.py
#  Last Modified: 2024-10-17 12:44:21
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 12:44:22
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.harmoniq.models import Harmoniq
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllHarmoniqAgents(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_agents = Harmoniq.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL HARMONIQ AGENTS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL HARMONIQ AGENTS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HARMONIQ_AGENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HARMONIQ_AGENTS):
            messages.error(self.request, "You do not have permission to delete harmoniq agents.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for agent in user_agents:
                agent.delete()
            logger.info(f"All harmoniq agents associated with User: {user.id} have been deleted.")
            messages.success(request, "All harmoniq agents associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting harmonqi agents: {e}")
            messages.error(request, f"Error deleting harmoniq agents: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_brainstorming_sessions_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_brainstorming_sessions_views.py
#  Last Modified: 2024-10-17 12:41:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 12:41:18
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.brainstorms.models import BrainstormingSession
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllBrainstormingSessions(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_brainstorming_sessions = BrainstormingSession.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL BRAINSTORMING SESSIONS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL BRAINSTORMING SESSIONS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_BRAINSTORMING_SESSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BRAINSTORMING_SESSIONS):
            messages.error(self.request, "You do not have permission to delete brainstorming sessions.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for brainstorming_session in user_brainstorming_sessions:
                brainstorming_session.delete()
            logger.info(f"All brainstorming sessions associated with User: {user.id} have been deleted.")
            messages.success(request, "All brainstorming sessions associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting brainstorming sessions: {e}")
            messages.error(request, f"Error deleting brainstorming sessions: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_knowledge_bases_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_knowledge_bases_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllVectorStoreManagers(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_vector_stores = DocumentKnowledgeBaseConnection.objects.filter(
            assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL KNOWLEDGE BASES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL KNOWLEDGE BASES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_KNOWLEDGE_BASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_KNOWLEDGE_BASES):
            messages.error(self.request, "You do not have permission to delete knowledge bases.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for vector_store in user_vector_stores:
                vector_store.delete()
            logger.info(f"All knowledge bases associated with User: {user.id} have been deleted.")
            messages.success(request, "All knowledge bases associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting knowledge bases: {e}")
            messages.error(request, f"Error deleting knowledge bases: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_nosql_databases_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_nosql_databases_views.py
#  Last Modified: 2024-10-17 12:31:51
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 12:32:28
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.models import NoSQLDatabaseConnection
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllNoSQLDBs(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_nosql_databases = NoSQLDatabaseConnection.objects.filter(assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL NOSQL DATABASES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL NOSQL DATABASES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_NOSQL_DATABASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_NOSQL_DATABASES):
            messages.error(self.request, "You do not have permission to delete NoSQL databases.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for nosql_database in user_nosql_databases:
                nosql_database.delete()
            messages.success(request, "All NoSQL databases associated with your account have been deleted.")
            logger.info(f"All NoSQL databases associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting NoSQL databases: {e}")
            logger.error(f"Error deleting NoSQL databases: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_custom_scripts_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_custom_scripts_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scripts.models import CustomScript
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllScripts(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_scripts = CustomScript.objects.filter(created_by_user=user).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL SCRIPTS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL SCRIPTS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SCRIPTS):
            messages.error(self.request, "You do not have permission to delete custom Scripts.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for script in user_scripts:
                script.delete()
            messages.success(request, "All scripts associated with your account have been deleted.")
            logger.info(f"All scripts associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting scripts: {e}")
            logger.error(f"Error deleting scripts: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_scheduled_jobs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_scheduled_jobs_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.models import ScheduledJob
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllScheduledJobs(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_scheduled_jobs = ScheduledJob.objects.filter(assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL SCHEDULED JOBS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL SCHEDULED JOBS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to delete scheduled jobs.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for scheduled_job in user_scheduled_jobs:
                scheduled_job.delete()
            messages.success(request, "All scheduled jobs associated with your account have been deleted.")
            logger.info(f"All scheduled jobs associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting scheduled jobs: {e}")
            logger.error(f"Error deleting scheduled jobs: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_custom_functions_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_custom_functions_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_functions.models import CustomFunction
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllFunctions(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_functions = CustomFunction.objects.filter(created_by_user=user).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL FUNCTIONS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL FUNCTIONS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_FUNCTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_FUNCTIONS):
            messages.error(self.request, "You do not have permission to delete custom functions.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for function in user_functions:
                function.delete()
            messages.success(request, "All functions associated with your account have been deleted.")
            logger.info(f"All functions associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting functions: {e}")
            logger.error(f"Error deleting functions: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_sql_databases_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_sql_databases_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_sql.models import SQLDatabaseConnection
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllSQLDBs(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_sql_databases = SQLDatabaseConnection.objects.filter(assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL SQL DATABASES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL SQL DATABASES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_SQL_DATABASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SQL_DATABASES):
            messages.error(self.request, "You do not have permission to delete SQL databases.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for sql_database in user_sql_databases:
                sql_database.delete()
            messages.success(request, "All SQL databases associated with your account have been deleted.")
            logger.info(f"All SQL databases associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting SQL databases: {e}")
            logger.error(f"Error deleting SQL databases: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_custom_nosql_queries_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_custom_nosql_queries_views.py
#  Last Modified: 2024-10-17 12:34:14
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 12:34:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_nosql.models import CustomNoSQLQuery
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllNoSQLQueries(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_custom_nosql_queries = CustomNoSQLQuery.objects.filter(
            database_connection__assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL CUSTOM NOSQL QUERIES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL CUSTOM NOSQL QUERIES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_CUSTOM_NOSQL_QUERIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CUSTOM_NOSQL_QUERIES):
            messages.error(self.request, "You do not have permission to delete custom NoSQL queries.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for custom_nosql_query in user_custom_nosql_queries:
                custom_nosql_query.delete()
            messages.success(request, "All custom NoSQL queries associated with your account have been deleted.")
            logger.info(f"All custom NoSQL queries associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting custom NoSQL queries: {e}")
            logger.error(f"Error deleting custom NoSQL queries: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_projects_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_projects_views.py
#  Last Modified: 2024-10-30 19:17:41
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 19:17:42
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllProjects(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user]).all()
        user_projects = ProjectItem.objects.filter(organization__in=user_orgs).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL PROJECTS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL PROJECTS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_PROJECTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_PROJECTS):
            messages.error(self.request, "You do not have permission to delete projects.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for project in user_projects:
                project.delete()
            messages.success(request, "All projects associated with your account have been deleted.")
            logger.info(f"All projects associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting projects: {e}")
            logger.error(f"Error deleting projects: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_assistants_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllAssistants(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_agents = Assistant.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL ASSISTANTS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL ASSISTANTS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_ASSISTANTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ASSISTANTS):
            messages.error(self.request, "You do not have permission to delete assistants.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for agent in user_agents:
                agent.delete()
            logger.info(f"All assistants associated with User: {user.id} have been deleted.")
            messages.success(request, "All assistants associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting assistants: {e}")
            messages.error(request, f"Error deleting assistants: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_hadron_topics_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_hadron_topics_views.py
#  Last Modified: 2024-10-18 21:54:39
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 21:55:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronTopic
from apps.organization.models import Organization
import logging

from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllHadronTopics(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user])
        hadron_topics = HadronTopic.objects.filter(system__organization__in=user_orgs)
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL HADRON TOPICS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL HADRON TOPICS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_TOPICS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_TOPICS):
            messages.error(self.request, "You do not have permission to delete hadron topics.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for hadron_topic in hadron_topics:
                hadron_topic.delete()
            logger.info(f"All hadron topics associated with User: {user.id} have been deleted.")
            messages.success(request, "All hadron topics associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron topics: {e}")
            messages.error(request, f"Error deleting hadron topics: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_hadron_sase_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_hadron_sase_logs_views.py
#  Last Modified: 2024-10-18 21:55:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 21:55:37
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronStateErrorActionStateErrorLog
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllHadronNodeSEASELogs(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user])
        hadron_node_sease_logs = HadronStateErrorActionStateErrorLog.objects.filter(
            node__system__organization__in=user_orgs)
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL HADRON NODE SEASE LOGS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL HADRON NODE SEASE LOGS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_NODE_SASE_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_NODE_SASE_LOGS):
            messages.error(self.request, "You do not have permission to delete hadron node SEASE logs.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for hadron_sease_log in hadron_node_sease_logs:
                hadron_sease_log.delete()
            logger.info(f"All hadron node SEASE logs associated with User: {user.id} have been deleted.")
            messages.success(request, "All hadron node SEASE logs associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron node SEASE logs: {e}")
            messages.error(request, f"Error deleting hadron node SEASE logs: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .delete_all_organizations_views import *
from .delete_all_llm_models_views import *
from .delete_all_assistants_views import *
from .delete_all_lean_assistants_views import *
from .delete_all_expert_networks_views import *
from .delete_all_chats_views import *
from .delete_all_lean_chats_views import *
from .delete_all_starred_messages_views import *
from .delete_all_memories_views import *
from .delete_all_message_templates_views import *
from .delete_all_export_assistants_views import *
from .delete_all_orchestrations_views import *
from .delete_all_file_systems_views import *
from .delete_all_web_browsers_views import *
from .delete_all_sql_databases_views import *
from .delete_all_custom_sql_queries_views import *
from .delete_all_knowledge_bases_views import *
from .delete_all_knowledge_base_documents_views import *
from .delete_all_code_storages_views import *
from .delete_all_code_repositories_views import *
from .delete_all_ml_storages_views import *
from .delete_all_ml_models_views import *
from .delete_all_media_storages_views import *
from .delete_all_media_files_views import *
from .delete_all_custom_functions_views import *
from .delete_all_custom_apis_views import *
from .delete_all_custom_scripts_views import *
from .delete_all_scheduled_jobs_views import *
from .delete_all_triggered_jobs_views import *
from .delete_all_brainstorming_sessions_views import *
from .delete_all_custom_nosql_queries_views import *
from .delete_all_data_backups_views import *
from .delete_all_drafting_documents_views import *
from .delete_all_drafting_folders_views import *
from .delete_all_harmoniq_agents_views import *
from .delete_all_nosql_databases_views import *
from .delete_all_video_generator_connections_views import *
from .delete_all_hadron_execution_logs_views import *
from .delete_all_hadron_nodes_views import *
from .delete_all_hadron_sase_logs_views import *
from .delete_all_hadron_systems_views import *
from .delete_all_hadron_topic_messages_logs_views import *
from .delete_all_hadron_topics_views import *
from .delete_soft_all_smart_contracts_views import *
from .delete_all_wallet_connections_views import *
from .delete_all_binexus_processes_views import *
from .delete_all_binexus_elite_agents_views import *
from .delete_all_metakanban_boards_views import *
from .delete_all_metatempo_connections_views import *
from .delete_all_projects_views import *
from .delete_all_teams_views import *
from .delete_all_ellma_scripts_views import *
from .delete_all_sheetos_documents_views import *
from .delete_all_sheetos_folders_views import *


Contents of ../../apps/user_settings/views/deletions/delete_all_hadron_topic_messages_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_hadron_topic_messages_views.py
#  Last Modified: 2024-10-18 21:55:16
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 21:55:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronTopicMessage
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllHadronTopicMessagesLogs(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user])
        hadron_topic_messages = HadronTopicMessage.objects.filter(topic__system__organization__in=user_orgs)
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL HADRON TOPIC MESSAGES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL HADRON TOPIC MESSAGES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_TOPIC_MESSAGE_HISTORY_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_TOPIC_MESSAGE_HISTORY_LOGS):
            messages.error(self.request, "You do not have permission to delete hadron topic message history logs.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for hadron_topic_message in hadron_topic_messages:
                hadron_topic_message.delete()
            logger.info(f"All hadron topic message history logs associated with User: {user.id} have been deleted.")
            messages.success(request, "All hadron topic message history logs associated with your account "
                                      "have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron topic message history logs: {e}")
            messages.error(request, f"Error deleting hadron topic message history logs: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_media_files_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_media_files_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_media_storages.models import DataSourceMediaStorageItem
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllMediaItems(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_multimedia_files = DataSourceMediaStorageItem.objects.filter(
            storage_base__assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL MULTIMEDIA FILES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL MULTIMEDIA FILES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_STORAGE_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_STORAGE_FILES):
            messages.error(self.request, "You do not have permission to delete multimedia files.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for multimedia_file in user_multimedia_files:
                multimedia_file.delete()
            messages.success(request, "All multimedia files associated with your account have been deleted.")
            logger.info(f"All multimedia files associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting multimedia files: {e}")
            logger.error(f"Error deleting multimedia files: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_drafting_documents_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_drafting_documents_views.py
#  Last Modified: 2024-10-17 12:39:00
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 12:39:01
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllDraftingDocuments(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_drafting_documents = DraftingDocument.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL DRAFTING DOCUMENTS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL DRAFTING DOCUMENTS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_DRAFTING_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_DRAFTING_DOCUMENTS):
            messages.error(self.request, "You do not have permission to delete drafting documents.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for drafting_document in user_drafting_documents:
                drafting_document.delete()
            logger.info(f"All drafting documents associated with User: {user.id} have been deleted.")
            messages.success(request, "All drafting documents associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting drafting documents: {e}")
            messages.error(request, f"Error deleting drafting documents: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_llm_models_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_llm_models_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_core.models import LLMCore
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllLLMModels(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_llm_models = LLMCore.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL LLM MODELS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL LLM MODELS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_LLM_CORES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_LLM_CORES):
            messages.error(self.request, "You do not have permission to delete LLM models.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for llm_model in user_llm_models:
                llm_model.delete()
            logger.info(f"All LLM models associated with User: {user.id} have been deleted.")
            messages.success(request, "All LLM models associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting LLM models: {e}")
            messages.error(request, f"Error deleting LLM models: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_web_browsers_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_web_browsers_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllBrowsers(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_web_browsers = DataSourceBrowserConnection.objects.filter(assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL WEB BROWSERS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL WEB BROWSERS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_WEB_BROWSERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_WEB_BROWSERS):
            messages.error(self.request, "You do not have permission to delete web browsers.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for web_browser in user_web_browsers:
                web_browser.delete()
            messages.success(request, "All web browsers associated with your account have been deleted.")
            logger.info(f"All web browsers associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting web browsers: {e}")
            logger.error(f"Error deleting web browsers: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_orchestrations_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_orchestrations_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.orchestrations.models import Maestro
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllOrchestrations(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_orchestrations = Maestro.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL ORCHESTRATIONS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL ORCHESTRATIONS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_ORCHESTRATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ORCHESTRATIONS):
            messages.error(self.request, "You do not have permission to delete orchestrations.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for orchestration in user_orchestrations:
                orchestration.delete()
            messages.success(request, "All orchestrations associated with your account have been deleted.")
            logger.info(f"All orchestrations associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting orchestrations: {e}")
            logger.error(f"Error deleting orchestrations: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_binexus_elite_agents_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_binexus_elite_agents_views.py
#  Last Modified: 2024-10-22 20:32:43
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-22 20:32:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.binexus.models import BinexusEliteAgent
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllBinexusEliteAgents(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        elite_agents = BinexusEliteAgent.objects.filter(binexus_process__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL BINEXUS ELITE AGENTS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL BINEXUS ELITE AGENTS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_BINEXUS_ELITES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BINEXUS_ELITES):
            messages.error(self.request, "You do not have permission to delete binexus elite agents.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for elite_agent in elite_agents:
                elite_agent.delete()
            logger.info(f"All Binexus Elite Agents associated with User: {user.id} have been deleted.")
            messages.success(request, "All Binexus Elite Agents associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting binexus elite agents: {e}")
            messages.error(request, f"Error deleting binexus elite agents: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_metakanban_boards_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_metakanban_boards_views.py
#  Last Modified: 2024-10-30 19:17:56
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 19:17:57
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metakanban.models import MetaKanbanBoard
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllMetaKanbanBoards(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user]).all()
        metakanban_boards = MetaKanbanBoard.objects.filter(project__organization__in=user_orgs).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL METAKANBAN BOARDS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL METAKANBAN BOARDS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_METAKANBAN_BOARD
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_METAKANBAN_BOARD):
            messages.error(self.request, "You do not have permission to delete MetaKanban boards.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for board in metakanban_boards:
                board.delete()
            messages.success(request, "All MetaKanban boards associated with your account have been deleted.")
            logger.info(f"All MetaKanban boards associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting MetaKanban boards: {e}")
            logger.error(f"Error deleting MetaKanban boards: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_ml_storages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_ml_storages_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_ml_models.models import DataSourceMLModelConnection
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllMLManagers(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_ml_managers = DataSourceMLModelConnection.objects.filter(
            assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL ML MODEL STORAGES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL ML MODEL STORAGES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_ML_MODEL_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ML_MODEL_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete ML model storages.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for ml_model_storage in user_ml_managers:
                ml_model_storage.delete()
            messages.success(request, "All ML model storages associated with your account have been deleted.")
            logger.info(f"All ML model storages associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting ML model storages: {e}")
            logger.error(f"Error deleting ML model storages: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_drafting_folders_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_drafting_folders_views.py
#  Last Modified: 2024-10-17 12:36:01
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 12:36:02
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.drafting.models import DraftingFolder
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllDraftingFolders(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_drafting_folders = DraftingFolder.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL DRAFTING FOLDERS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL DRAFTING FOLDERS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_DRAFTING_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_DRAFTING_FOLDERS):
            messages.error(self.request, "You do not have permission to delete drafting folders.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for drafting_folder in user_drafting_folders:
                drafting_folder.delete()
            logger.info(f"All drafting folders associated with User: {user.id} have been deleted.")
            messages.success(request, "All drafting folders associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting drafting folders: {e}")
            messages.error(request, f"Error deleting drafting folders: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_hadron_execution_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_hadron_execution_logs_views.py
#  Last Modified: 2024-10-18 21:54:59
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 21:55:35
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNodeExecutionLog
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllHadronNodeExecutionLogs(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user])
        hadron_node_exec_logs = HadronNodeExecutionLog.objects.filter(node__system__organization__in=user_orgs)
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL HADRON NODE EXECUTION LOGS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL HADRON NODE EXECUTION LOGS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_NODE_EXECUTION_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_NODE_EXECUTION_LOGS):
            messages.error(self.request, "You do not have permission to delete hadron node execution nodes.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for hadron_node_exec_log in hadron_node_exec_logs:
                hadron_node_exec_log.delete()
            logger.info(f"All hadron node execution logs associated with User: {user.id} have been deleted.")
            messages.success(request, "All hadron node execution logs associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron node execution logs: {e}")
            messages.error(request, f"Error deleting hadron node execution logs: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_memories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_memories_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.memories.models import AssistantMemory
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllStandardMemories(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_std_memories = AssistantMemory.objects.filter(user=user).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL MEMORIES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL MEMORIES'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_ASSISTANT_MEMORIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ASSISTANT_MEMORIES):
            messages.error(self.request, "You do not have permission to delete assistant memories.")
            logger.error(f"User: {user.id} does not have permission to delete assistant memories.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for std_memory in user_std_memories:
                std_memory.delete()
            messages.success(request, "All memories associated with your account have been deleted.")
            logger.info(f"All memories associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting memories: {e}")
            logger.error(f"Error deleting memories: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_soft_all_smart_contracts_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_soft_all_smart_contracts_views.py
#  Last Modified: 2024-10-19 22:57:42
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:57:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.smart_contracts.models import BlockchainSmartContract
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteSoftAllSmartContracts(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):

        user = request.user
        smart_contracts = BlockchainSmartContract.objects.filter(assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM SOFT DELETING ALL BLOCKCHAIN SMART CONTRACTS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM SOFT DELETING ALL BLOCKCHAIN SMART CONTRACTS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - SOFT_DELETE_SMART_CONTRACTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.SOFT_DELETE_SMART_CONTRACTS):
            messages.error(self.request, "You do not have permission to soft delete smart contracts.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for contract in smart_contracts:
                contract.delete()
            messages.success(request, "All blockchain smart contracts associated with your account have "
                                      "been deleted.")
            logger.info(f"All blockchain smart contracts associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting blockchain smart contracts: {e}")
            logger.error(f"Error deleting blockchain smart contracts: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_expert_networks_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_expert_networks_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import ExpertNetwork
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllExpertNets(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        expert_networks = ExpertNetwork.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL EXPERT NETWORKS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL EXPERT NETWORKS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_EXPERT_NETWORKS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_EXPERT_NETWORKS):
            messages.error(self.request, "You do not have permission to delete expert networks.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for network in expert_networks:
                network.delete()
            logger.info(f"All expert networks associated with User: {user.id} have been deleted.")
            messages.success(request, "All expert networks associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting expert networks: {e}")
            messages.error(request, f"Error deleting expert networks: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_file_systems_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_file_systems_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllFileSystems(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_file_systems = DataSourceFileSystem.objects.filter(assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL FILE SYSTEMS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL FILE SYSTEMS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_FILE_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_FILE_SYSTEMS):
            messages.error(self.request, "You do not have permission to delete file systems.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for file_system in user_file_systems:
                file_system.delete()
            logger.info(f"All file systems associated with User: {user.id} have been deleted.")
            messages.success(request, "All file systems associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting file systems: {e}")
            messages.error(request, f"Error deleting file systems: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_wallet_connections_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_wallet_connections_views.py
#  Last Modified: 2024-10-19 22:57:24
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-19 22:57:24
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.smart_contracts.models import BlockchainWalletConnection
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllWalletConnections(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):

        user = request.user
        wallet_connections = BlockchainWalletConnection.objects.filter(assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL BLOCKCHAIN WALLET CONNECTIONS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL BLOCKCHAIN WALLET CONNECTIONS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_BLOCKCHAIN_WALLET_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_BLOCKCHAIN_WALLET_CONNECTIONS):
            messages.error(self.request, "You do not have permission to delete blockchain wallet connections.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for wallet_connection in wallet_connections:
                wallet_connection.delete()
            messages.success(request, "All blockchain wallet connections associated with your account have "
                                      "been deleted.")
            logger.info(f"All blockchain wallet connections associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting blockchain wallet connections: {e}")
            logger.error(f"Error deleting blockchain wallet connections: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_media_storages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_media_storages_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllMediaManagers(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_media_managers = DataSourceMediaStorageConnection.objects.filter(
            assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL MEDIA STORAGES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL MEDIA STORAGES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_MEDIA_STORAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_MEDIA_STORAGES):
            messages.error(self.request, "You do not have permission to delete media storages.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for media_manager in user_media_managers:
                media_manager.delete()
            messages.success(request, "All media storages associated with your account have been deleted.")
            logger.info(f"All media storages associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting media storages: {e}")
            logger.error(f"Error deleting media storages: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_lean_chats_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_lean_chats_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalLeanChat
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllLeanModChats(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_chats = MultimodalLeanChat.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL LEANMOD CHATS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL LEANMOD CHATS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - REMOVE_LEAN_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_LEAN_CHATS):
            messages.error(self.request, "You do not have permission to delete LeanMod chats.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for chat in user_chats:
                chat.delete()
            logger.info(f"All LeanMod™ chat messages associated with User: {user.id} have been deleted.")
            messages.success(request, "All LeanMod™ chat messages associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting LeanMod™ chat messages: {e}")
            messages.error(request, f"Error deleting LeanMod™ chat messages: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_export_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_export_assistants_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.export_assistants.models import ExportAssistantAPI
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllExportAssistants(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_exp_agents = ExportAssistantAPI.objects.filter(assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL EXPORTED ASSISTANTS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL EXPORTED ASSISTANTS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_EXPORT_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_EXPORT_ASSISTANT):
            messages.error(self.request, "You do not have permission to delete exported assistants.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for exp_agent in user_exp_agents:
                exp_agent.delete()
            logger.info(f"All exported assistants associated with User: {user.id} have been deleted.")
            messages.success(request, "All exported assistants associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting exported assistants: {e}")
            messages.error(request, f"Error deleting exported assistants: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_chats_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_chats_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalChat
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllChats(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_chats = MultimodalChat.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL CHATS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL CHATS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - REMOVE_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_CHATS):
            messages.error(self.request, "You do not have permission to delete chats.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for chat in user_chats:
                chat.delete()
            logger.info(f"All chat messages associated with User: {user.id} have been deleted.")
            messages.success(request, "All chat messages associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting chat messages: {e}")
            messages.error(request, f"Error deleting chat messages: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_custom_sql_queries_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_custom_sql_queries_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_sql.models import CustomSQLQuery
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllSQLQueries(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_custom_sql_queries = CustomSQLQuery.objects.filter(
            database_connection__assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL CUSTOM SQL QUERIES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL CUSTOM SQL QUERIES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_CUSTOM_SQL_QUERIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CUSTOM_SQL_QUERIES):
            messages.error(self.request, "You do not have permission to delete custom SQL queries.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for custom_sql_query in user_custom_sql_queries:
                custom_sql_query.delete()
            messages.success(request, "All custom SQL queries associated with your account have been deleted.")
            logger.info(f"All custom SQL queries associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting custom SQL queries: {e}")
            logger.error(f"Error deleting custom SQL queries: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_code_repositories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_code_repositories_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_codebase.models import CodeBaseRepository
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllCodeRepos(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_repositories = CodeBaseRepository.objects.filter(
            knowledge_base__assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL REPOSITORIES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL REPOSITORIES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_CODE_REPOSITORY
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CODE_REPOSITORY):
            messages.error(self.request, "You do not have permission to delete code repositories.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for repository in user_repositories:
                repository.delete()
            logger.info(f"All repositories associated with User: {user.id} have been deleted.")
            messages.success(request, "All repositories associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting repositories: {e}")
            messages.error(request, f"Error deleting repositories: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_metatempo_connections_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_metatempo_connections_views.py
#  Last Modified: 2024-10-30 19:18:09
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 19:18:09
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.metatempo.models import MetaTempoConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllMetaTempoConnections(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user]).all()
        metatempo_connections = MetaTempoConnection.objects.filter(board__project__organization__in=user_orgs).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL METATEMPO CONNECTIONS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL METATEMPO CONNECTIONS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_METATEMPO_CONNECTION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_METATEMPO_CONNECTION):
            messages.error(self.request, "You do not have permission to delete MetaTempo connections.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for connection in metatempo_connections:
                connection.delete()
            messages.success(request, "All MetaTempo connections associated with your account have been deleted.")
            logger.info(f"All MetaTempo connections associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting MetaTempo connections: {e}")
            logger.error(f"Error deleting MetaTempo connections: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_sheetos_documents_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_sheetos_documents_views.py
#  Last Modified: 2024-10-31 23:48:31
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 23:48:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosDocument
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllSheetosDocuments(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_sheetos_documents = SheetosDocument.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL SHEETOS DOCUMENTS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL SHEETOS DOCUMENTS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_SHEETOS_DOCUMENTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SHEETOS_DOCUMENTS):
            messages.error(self.request, "You do not have permission to delete Sheetos documents.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for sheetos_document in user_sheetos_documents:
                sheetos_document.delete()
            logger.info(f"All sheetos documents associated with User: {user.id} have been deleted.")
            messages.success(request, "All sheetos documents associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting sheetos documents: {e}")
            messages.error(request, f"Error deleting sheetos documents: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_message_templates_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_message_templates_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.message_templates.models import MessageTemplate
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllMessageTemplates(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_message_templates = MessageTemplate.objects.filter(user=user).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL MESSAGE TEMPLATES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL MESSAGE TEMPLATES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - REMOVE_TEMPLATE_MESSAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_TEMPLATE_MESSAGES):
            messages.error(self.request, "You do not have permission to delete message templates.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for message_template in user_message_templates:
                message_template.delete()
            messages.success(request, "All message templates associated with your account have been deleted.")
            logger.info(f"All message templates associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting message templates: {e}")
            logger.error(f"Error deleting message templates: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_starred_messages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_starred_messages_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.starred_messages.models import StarredMessage
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllStarredMessages(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_starred_messages = StarredMessage.objects.filter(user=user).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL STARRED MESSAGES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL STARRED MESSAGES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - REMOVE_STARRED_MESSAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_STARRED_MESSAGES):
            messages.error(self.request, "You do not have permission to remove starred messages.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for starred_message in user_starred_messages:
                starred_message.delete()
            messages.success(request, "All starred messages associated with your account have been deleted.")
            logger.info(f"All starred messages associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting starred messages: {e}")
            logger.error(f"Error deleting starred messages: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_sheetos_folders_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_sheetos_folders_views.py
#  Last Modified: 2024-10-31 23:48:21
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-31 23:48:22
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.sheetos.models import SheetosFolder
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllSheetosFolders(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        sheetos_folders = SheetosFolder.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL SHEETOS FOLDERS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL SHEETOS FOLDERS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_SHEETOS_FOLDERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SHEETOS_FOLDERS):
            messages.error(self.request, "You do not have permission to delete sheetos folders.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for sheetos_folder in sheetos_folders:
                sheetos_folder.delete()
            logger.info(f"All sheetos folders associated with User: {user.id} have been deleted.")
            messages.success(request, "All sheetos folders associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting sheetos folders: {e}")
            messages.error(request, f"Error deleting sheetos folders: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_ellma_scripts_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_ellma_scripts_views.py
#  Last Modified: 2024-10-30 22:59:38
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 22:59:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.ellma.models import EllmaScript
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllEllmaScripts(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_ellma_scripts = EllmaScript.objects.filter(organization__users__in=[user])
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL ELLMA SCRIPTS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL ELLMA SCRIPTS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_ELLMA_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ELLMA_SCRIPTS):
            messages.error(self.request, "You do not have permission to delete eLLMa scripts.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for ellma_script in user_ellma_scripts:
                ellma_script.delete()
            logger.info(f"All eLLMa scripts associated with User: {user.id} have been deleted.")
            messages.success(request, "All eLLMa scripts associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting eLLMa scripts: {e}")
            messages.error(request, f"Error deleting eLLMa scripts: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_triggered_jobs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_triggered_jobs_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_triggered_jobs.models import TriggeredJob
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllTriggeredJobs(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_triggered_jobs = TriggeredJob.objects.filter(trigger_assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL TRIGGERED JOBS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL TRIGGERED JOBS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_TRIGGERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_TRIGGERS):
            messages.error(self.request, "You do not have permission to delete triggered jobs.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for triggered_job in user_triggered_jobs:
                triggered_job.delete()
            messages.success(request, "All triggered jobs associated with your account have been deleted.")
            logger.info(f"All triggered jobs associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting triggered jobs: {e}")
            logger.error(f"Error deleting triggered jobs: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_custom_apis_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_custom_apis_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_apis.models import CustomAPI
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllAPIs(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_apis = CustomAPI.objects.filter(created_by_user=user).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL APIS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL APIS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_APIS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_APIS):
            messages.error(self.request, "You do not have permission to delete custom APIs.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for api in user_apis:
                api.delete()
            logger.info(f"All APIs associated with User: {user.id} have been deleted.")
            messages.success(request, "All APIs associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting APIs: {e}")
            messages.error(request, f"Error deleting APIs: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_knowledge_base_documents_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_knowledge_base_documents_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_knowledge_base.models import KnowledgeBaseDocument
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllVectorStoreDocuments(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_vector_store_docs = KnowledgeBaseDocument.objects.filter(
            knowledge_base__assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL KNOWLEDGE BASE DOCUMENTS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL KNOWLEDGE BASE DOCUMENTS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_KNOWLEDGE_BASE_DOCS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_KNOWLEDGE_BASE_DOCS):
            messages.error(self.request, "You do not have permission to delete knowledge base documents.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for vector_store_doc in user_vector_store_docs:
                vector_store_doc.delete()
            logger.info(f"All knowledge base documents associated with User: {user.id} have been deleted.")
            messages.success(request, "All knowledge base documents associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting knowledge base documents: {e}")
            messages.error(request, f"Error deleting knowledge base documents: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_lean_assistants_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_lean_assistants_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import LeanAssistant
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllLeanModAssistants(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_leanmod_agents = LeanAssistant.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL LEAN ASSISTANTS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL LEAN ASSISTANTS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_LEAN_ASSISTANT
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_LEAN_ASSISTANT):
            messages.error(self.request, "You do not have permission to delete LeanMod assistants.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for leanmod_agent in user_leanmod_agents:
                leanmod_agent.delete()
            logger.info(f"All lean assistants associated with User: {user.id} have been deleted.")
            messages.success(request, "All lean assistants associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting lean assistants: {e}")
            messages.error(request, f"Error deleting lean assistants: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_ml_models_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_ml_models_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_ml_models.models import DataSourceMLModelItem
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)



class SettingsView_DeleteAllMLModels(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_ml_models = DataSourceMLModelItem.objects.filter(
            ml_model_base__assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL ML MODELS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL ML MODELS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_ML_MODEL_FILES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ML_MODEL_FILES):
            messages.error(self.request, "You do not have permission to delete ML model files.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for ml_model in user_ml_models:
                ml_model.delete()
            messages.success(request, "All ML models associated with your account have been deleted.")
            logger.info(f"All ML models associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting ML models: {e}")
            logger.error(f"Error deleting ML models: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_code_storages_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_code_storages_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_codebase.models import CodeRepositoryStorageConnection
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class SettingsView_DeleteAllCodeStorages(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_code_storages = CodeRepositoryStorageConnection.objects.filter(
            assistant__organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL CODE STORAGES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL CODE STORAGES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_CODE_BASE
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CODE_BASE):
            messages.error(self.request, "You do not have permission to delete code base storages.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for code_storage in user_code_storages:
                code_storage.delete()
            logger.info(f"All code storages associated with User: {user.id} have been deleted.")
            messages.success(request, "All code storages associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting code storages: {e}")
            messages.error(request, f"Error deleting code storages: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_hadron_systems_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_hadron_systems_views.py
#  Last Modified: 2024-10-18 21:54:27
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 21:54:29
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronSystem
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllHadronSystems(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user])
        hadron_systems = HadronSystem.objects.filter(organization__in=user_orgs)
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL HADRON SYSTEMS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL HADRON SYSTEMS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_SYSTEMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_SYSTEMS):
            messages.error(self.request, "You do not have permission to delete hadron systems.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for hadron_system in hadron_systems:
                hadron_system.delete()
            logger.info(f"All hadron systems associated with User: {user.id} have been deleted.")
            messages.success(request, "All hadron systems associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron systems: {e}")
            messages.error(request, f"Error deleting hadron systems: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_teams_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_teams_views.py
#  Last Modified: 2024-10-30 19:34:54
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-30 19:34:55
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.projects.models import ProjectTeamItem
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllTeams(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user]).all()
        user_teams = ProjectTeamItem.objects.filter(project__organization__in=user_orgs).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL TEAMS':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL TEAMS'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_TEAMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_TEAMS):
            messages.error(self.request, "You do not have permission to delete teams.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for team in user_teams:
                team.delete()
            messages.success(request, "All teams associated with your account have been deleted.")
            logger.info(f"All teams associated with User: {user.id} have been deleted.")
        except Exception as e:
            messages.error(request, f"Error deleting teams: {e}")
            logger.error(f"Error teams projects: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_hadron_nodes_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_hadron_nodes_views.py
#  Last Modified: 2024-10-18 21:54:49
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-18 21:55:36
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.hadron_prime.models import HadronNode
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllHadronNodes(View, LoginRequiredMixin):

    def post(self, request, *args, **kwargs):
        user = request.user
        user_orgs = Organization.objects.filter(users__in=[user])
        hadron_nodes = HadronNode.objects.filter(system__organization__in=user_orgs)
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL HADRON NODES':
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL HADRON NODES'.")
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_HADRON_NODES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_HADRON_NODES):
            messages.error(self.request, "You do not have permission to delete hadron nodes.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for hadron_node in hadron_nodes:
                hadron_node.delete()
            logger.info(f"All hadron nodes associated with User: {user.id} have been deleted.")
            messages.success(request, "All hadron nodes associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting hadron nodes: {e}")
            messages.error(request, f"Error deleting hadron nodes: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/user_settings/views/deletions/delete_all_data_backups_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_all_data_backups_views.py
#  Last Modified: 2024-10-17 12:48:39
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-17 12:48:40
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.data_backups.models import DataBackup
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SettingsView_DeleteAllDataBackups(View, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        user = request.user
        user_data_backups = DataBackup.objects.filter(organization__users__in=[user]).all()
        confirmation_field = request.POST.get('confirmation', None)
        if confirmation_field != 'CONFIRM DELETING ALL DATA BACKUPS':
            logger.error(f"Invalid confirmation field: {confirmation_field}")
            messages.error(request, "Invalid confirmation field. Please confirm the deletion by typing "
                                    "exactly 'CONFIRM DELETING ALL DATA BACKUPS'.")
            return redirect('user_settings:settings')

        ##############################
        # PERMISSION CHECK FOR - DELETE_DATA_BACKUPS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_DATA_BACKUPS):
            messages.error(self.request, "You do not have permission to delete data backups.")
            return redirect('user_settings:settings')
        ##############################

        try:
            for data_backup in user_data_backups:
                data_backup.delete()
            logger.info(f"All data backups associated with User: {user.id} have been deleted.")
            messages.success(request, "All data backups associated with your account have been deleted.")
        except Exception as e:
            logger.error(f"Error deleting data backups: {e}")
            messages.error(request, f"Error deleting data backups: {e}")
        return redirect('user_settings:settings')


Contents of ../../apps/message_templates/views/delete_message_template_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_message_template_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.message_templates.models import MessageTemplate
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class MessageTemplateView_Delete(DeleteView, LoginRequiredMixin):
    model = MessageTemplate
    success_url = 'message_templates:list'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - REMOVE_TEMPLATE_MESSAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_TEMPLATE_MESSAGES):
            messages.error(self.request, "You do not have permission to delete template messages.")
            return redirect('message_templates:list')
        ##############################

        msg_tmpl = get_object_or_404(MessageTemplate, id=self.kwargs['pk'])

        try:
            msg_tmpl.delete()
        except Exception as e:
            logger.error(f"Error deleting Message Template: {e}")
            return redirect(self.success_url)

        success_message = "Message template deleted successfully."
        logger.info(f"Message Template was deleted by User: {self.request.user.id}.")
        messages.success(request, success_message)
        return redirect(self.success_url)


Contents of ../../apps/message_templates/views/update_message_template_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_message_template_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.message_templates.forms import MessageTemplateForm
from apps.message_templates.models import MessageTemplate
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class MessageTemplateView_Update(TemplateView, LoginRequiredMixin):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        orgs = self.request.user.organizations.all()
        msg_tmpl = get_object_or_404(MessageTemplate, pk=self.kwargs['pk'])
        context['form'] = MessageTemplateForm(instance=msg_tmpl)
        context['message_template'] = msg_tmpl
        context['organizations'] = orgs
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_TEMPLATE_MESSAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_TEMPLATE_MESSAGES):
            messages.error(self.request, "You do not have permission to update template messages.")
            return redirect('message_templates:list')
        ##############################

        msg_tmpl = get_object_or_404(MessageTemplate, pk=self.kwargs['pk'])
        form = MessageTemplateForm(request.POST, instance=msg_tmpl)
        if form.is_valid():
            form.save()
            logger.info(f"Message Template was updated by User: {self.request.user.id}.")
            return redirect('message_templates:list')
        logger.error(f"Message Template update failed by User: {self.request.user.id}.")
        return render(request, self.template_name, {'form': form, 'message_template': msg_tmpl})


Contents of ../../apps/message_templates/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .delete_message_template_views import *
from .create_message_template_views import *
from .list_message_templates_views import *
from .update_message_template_views import *


Contents of ../../apps/message_templates/views/create_message_template_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_message_template_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.message_templates.forms import MessageTemplateForm
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class MessageTemplateView_Create(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = self.request.user.organizations.all()
        return context

    def post(self, request, *args, **kwargs):
        form = MessageTemplateForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_TEMPLATE_MESSAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_TEMPLATE_MESSAGES):
            messages.error(self.request, "You do not have permission to add template messages.")
            return redirect('message_templates:list')
        ##############################

        if form.is_valid():
            msg_tmpl = form.save(commit=False)
            msg_tmpl.user = request.user
            msg_tmpl.save()
            logger.info(f"Message Template was created by User: {self.request.user.id}.")
            messages.success(request, "Message Template created successfully!")
            return redirect("message_templates:list")
        else:
            logger.error(f"Message Template creation failed by User: {self.request.user.id}.")
            messages.error(request, "Please correct the errors below.")
            return self.render_to_response(self.get_context_data(form=form, error_messages=form.errors))


Contents of ../../apps/message_templates/views/list_message_templates_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_message_templates_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.message_templates.models import MessageTemplate
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class MessageTemplateView_List(TemplateView, LoginRequiredMixin):
    model = MessageTemplate

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_TEMPLATE_MESSAGES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_TEMPLATE_MESSAGES):
            messages.error(self.request, "You do not have permission to list template messages.")
            return context
        ##############################

        logger.info(f"User: {self.request.user.id} is listing message templates.")
        context['message_templates'] = MessageTemplate.objects.filter(user=self.request.user)
        return context


Contents of ../../apps/datasource_sql/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .sql_query import *
from .sql_database import *


Contents of ../../apps/datasource_sql/views/sql_database/list_sql_databases_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_sql_databases_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_sql.models import SQLDatabaseConnection
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SQLDatabaseView_ManagerList(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SQL_DATABASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SQL_DATABASES):
            messages.error(self.request, "You do not have permission to list SQL Data Sources.")
            return context
        ##############################

        context_user = self.request.user
        try:
            c = SQLDatabaseConnection.objects.filter(assistant__in=Assistant.objects.filter(
                organization__in=context_user.organizations.all())).select_related('assistant__organization')

            c_by_orgs = {}
            for connection in c:
                orgs = connection.assistant.organization
                agent = connection.assistant
                if orgs not in c_by_orgs:
                    c_by_orgs[orgs] = {}
                if agent not in c_by_orgs[orgs]:
                    c_by_orgs[orgs][agent] = []
                c_by_orgs[orgs][agent].append(connection)
        except Exception as e:
            logger.error(f"User: {context_user} - SQL Data Source - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing SQL Data Sources.')
            return context

        context['connections_by_organization'] = c_by_orgs
        logger.info(f"SQL Database Connections were listed.")
        return context


Contents of ../../apps/datasource_sql/views/sql_database/delete_sql_database_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_sql_database_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_sql.models import SQLDatabaseConnection
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SQLDatabaseView_ManagerDelete(LoginRequiredMixin, DeleteView):
    model = SQLDatabaseConnection
    success_url = 'datasource_sql:list'

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_SQL_DATABASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SQL_DATABASES):
            messages.error(self.request, "You do not have permission to delete SQL Data Sources.")
            return redirect('datasource_sql:list')
        ##############################

        try:
            self.object = self.get_object()
            self.object.delete()
        except Exception as e:
            logger.error(f"Error deleting SQL Database Connection: {e}")
            messages.error(self.request, 'An error occurred while deleting SQL Database Connection.')
            return redirect(self.success_url)

        logger.info(f"SQL Database Connection {self.object.name} was deleted.")
        messages.success(request, f'SQL Database Connection {self.object.name} was deleted successfully.')
        return redirect(self.success_url)


Contents of ../../apps/datasource_sql/views/sql_database/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .delete_sql_database_views import *
from .list_sql_databases_views import *
from .update_sql_database_views import *
from .create_sql_database_views import *


Contents of ../../apps/datasource_sql/views/sql_database/update_sql_database_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_sql_database_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_sql.forms import SQLDatabaseConnectionForm
from apps.datasource_sql.models import SQLDatabaseConnection
from apps.datasource_sql.utils import DBMS_CHOICES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SQLDatabaseView_ManagerUpdate(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            conn = SQLDatabaseConnection.objects.get(id=kwargs['pk'])
            user_orgs = Organization.objects.filter(users__in=[context_user])
            agents = Assistant.objects.filter(organization__in=user_orgs)
            context['dbms_choices'] = DBMS_CHOICES
            context['form'] = SQLDatabaseConnectionForm(instance=conn)
            context['assistants'] = agents
            context['connection'] = conn
        except Exception as e:
            logger.error(f"User: {context_user} - SQL Data Source - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating SQL Data Source.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SQL_DATABASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SQL_DATABASES):
            messages.error(self.request, "You do not have permission to update SQL Data Sources.")
            return redirect('datasource_sql:list')
        ##############################

        conn = SQLDatabaseConnection.objects.get(id=kwargs['pk'], created_by_user=context_user)
        form = SQLDatabaseConnectionForm(request.POST, instance=conn)
        if form.is_valid():
            form.save()
            logger.info("SQL Data Source updated.")
            messages.success(request, "SQL Data Source updated successfully.")
            return redirect('datasource_sql:list')
        else:
            logger.error("Error updating SQL Data Source: " + str(form.errors))
            messages.error(request, "Error updating SQL Data Source: " + str(form.errors))
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_sql/views/sql_database/create_sql_database_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_sql_database_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_sql.forms import SQLDatabaseConnectionForm
from apps.datasource_sql.utils import DBMS_CHOICES
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SQLDatabaseView_ManagerCreate(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            user_orgs = Organization.objects.filter(users__in=[context_user])
            agents = Assistant.objects.filter(organization__in=user_orgs)
            context['dbms_choices'] = DBMS_CHOICES
            context['form'] = SQLDatabaseConnectionForm()
            context['assistants'] = agents
        except Exception as e:
            logger.error(f"User: {context_user} - SQL Data Source - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating SQL Data Source.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        form = SQLDatabaseConnectionForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_SQL_DATABASES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SQL_DATABASES):
            messages.error(self.request, "You do not have permission to create SQL Data Sources.")
            return redirect('datasource_sql:list')
        ##############################

        if form.is_valid():
            form.save()
            logger.info("SQL Data Source created.")
            messages.success(request, "SQL Data Source created successfully.")
            return redirect('datasource_sql:create')
        else:
            logger.error("Error creating SQL Data Source.")
            messages.error(request, "Error creating SQL Data Source.")
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_sql/views/sql_query/delete_sql_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_sql_query_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_sql.models import CustomSQLQuery
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class SQLDatabaseView_QueryDelete(LoginRequiredMixin, DeleteView):
    model = CustomSQLQuery
    success_url = 'datasource_sql:list_queries'

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_CUSTOM_SQL_QUERIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_CUSTOM_SQL_QUERIES):
            messages.error(self.request, "You do not have permission to delete custom SQL queries.")
            return redirect('datasource_sql:list_queries')
        ##############################

        try:
            self.object = self.get_object()
            self.object.delete()
        except Exception as e:
            logger.error(f"Error deleting SQL Query: {e}")
            messages.error(self.request, 'An error occurred while deleting SQL Query.')
            return redirect(self.success_url)

        logger.info(f"SQL Query {self.object.name} was deleted.")
        messages.success(request, f'SQL Query {self.object.name} was deleted successfully.')
        return redirect(self.success_url)


Contents of ../../apps/datasource_sql/views/sql_query/create_sql_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_sql_query_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_sql.forms import CustomSQLQueryForm
from apps.datasource_sql.models import SQLDatabaseConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SQLDatabaseView_QueryCreate(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            user_orgs = Organization.objects.filter(users__in=[context_user])
            db_c = SQLDatabaseConnection.objects.filter(
                assistant__in=Assistant.objects.filter(organization__in=user_orgs))
            context['database_connections'] = db_c
            context['form'] = CustomSQLQueryForm()
        except Exception as e:
            logger.error(f"User: {context_user} - SQL Query - Create Error: {e}")
            messages.error(self.request, 'An error occurred while creating SQL Query.')
            return context

        return context

    def post(self, request, *args, **kwargs):
        form = CustomSQLQueryForm(request.POST)

        ##############################
        # PERMISSION CHECK FOR - ADD_CUSTOM_SQL_QUERIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_CUSTOM_SQL_QUERIES):
            messages.error(self.request, "You do not have permission to create custom SQL queries.")
            return redirect('datasource_sql:list_queries')
        ##############################

        if form.is_valid():
            form.save()
            logger.info("SQL Query created.")
            messages.success(request, "SQL Query created successfully.")
            return redirect('datasource_sql:create_query')
        else:
            logger.error("Error creating SQL Query.")
            messages.error(request, "Error creating SQL Query.")
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_sql/views/sql_query/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .create_sql_query_views import *
from .delete_sql_query_views import *
from .update_sql_query_views import *
from .list_sql_queries_views import *


Contents of ../../apps/datasource_sql/views/sql_query/update_sql_query_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_sql_query_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_sql.forms import CustomSQLQueryForm
from apps.datasource_sql.models import CustomSQLQuery, SQLDatabaseConnection
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SQLDatabaseView_QueryUpdate(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        try:
            query = get_object_or_404(CustomSQLQuery, id=kwargs['pk'])
            user_orgs = Organization.objects.filter(users__in=[context_user])
            db_c = SQLDatabaseConnection.objects.filter(
                assistant__in=Assistant.objects.filter(organization__in=user_orgs))
            context['database_connections'] = db_c
            context['form'] = CustomSQLQueryForm(instance=query)
            context['query'] = query
        except Exception as e:
            logger.error(f"User: {context_user} - SQL Query - Update Error: {e}")
            messages.error(self.request, 'An error occurred while updating SQL Query.')
            return context

        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_CUSTOM_SQL_QUERIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_CUSTOM_SQL_QUERIES):
            messages.error(self.request, "You do not have permission to update custom SQL queries.")
            return redirect('datasource_sql:list_queries')
        ##############################

        query = get_object_or_404(CustomSQLQuery, id=kwargs['pk'])
        form = CustomSQLQueryForm(request.POST, instance=query)
        if form.is_valid():
            form.save()
            logger.info("SQL Query updated.")
            messages.success(request, "SQL Query updated successfully.")
            return redirect('datasource_sql:list_queries')
        else:
            logger.error("Error updating SQL Query.")
            messages.error(request, "Error updating SQL Query: " + str(form.errors))
            context = self.get_context_data(**kwargs)
            context['form'] = form
            return self.render_to_response(context)


Contents of ../../apps/datasource_sql/views/sql_query/list_sql_queries_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_sql_queries_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.datasource_sql.models import CustomSQLQuery
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class SQLDatabaseView_QueryList(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_CUSTOM_SQL_QUERIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_CUSTOM_SQL_QUERIES):
            messages.error(self.request, "You do not have permission to list custom SQL queries.")
            return context
        ##############################

        context_user = self.request.user

        try:
            queries = CustomSQLQuery.objects.filter(
                database_connection__assistant__in=Assistant.objects.filter(
                    organization__in=context_user.organizations.all())
            ).select_related('database_connection__assistant', 'database_connection__assistant__organization')

            queries_by_orgs = {}
            for qu in queries:
                org = qu.database_connection.assistant.organization
                agent = qu.database_connection.assistant
                if org not in queries_by_orgs:
                    queries_by_orgs[org] = {}
                if agent not in queries_by_orgs[org]:
                    queries_by_orgs[org][agent] = []
                queries_by_orgs[org][agent].append(qu)
        except Exception as e:
            logger.error(f"User: {context_user} - SQL Query - List Error: {e}")
            messages.error(self.request, 'An error occurred while listing SQL Queries.')
            return context

        context['queries_by_organization'] = queries_by_orgs
        logger.info(f"SQL Queries were listed.")
        return context


Contents of ../../apps/mm_scripts/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .store import *
from .script import *


Contents of ../../apps/mm_scripts/views/script/connections_scripts_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: connections_scripts_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.mm_scripts.models import CustomScript, CustomScriptReference
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomScriptView_Connections(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user
        conn_orgs = Organization.objects.filter(users__in=[user])
        users_of_conn_orgs = [user for org in conn_orgs for user in org.users.all()]
        scripts = CustomScript.objects.filter(created_by_user__in=users_of_conn_orgs)
        ext_script_refs = CustomScriptReference.objects.filter(assistant__organization__in=conn_orgs).exclude(
            custom_script__created_by_user__in=users_of_conn_orgs)
        agents = Assistant.objects.filter(organization__in=conn_orgs).select_related('organization')
        agent_script_map = {
            assistant.id: CustomScriptReference.objects.filter(
                assistant=assistant, custom_script__created_by_user__in=users_of_conn_orgs) for assistant in agents}
        ext_script_refs_map = {
            assistant.id: set(reference for reference in ext_script_refs if reference.assistant.id == assistant.id)
            for assistant in agents}
        context.update({
            'connected_organizations': conn_orgs, 'scripts': scripts, 'assistants': agents,
            'assistant_script_map': agent_script_map, 'external_script_references_map': ext_script_refs_map})
        return context

    def post(self, request, *args, **kwargs):
        agent_id = request.POST.get('assistant_id')
        script_id = request.POST.get('script_id')
        action = request.POST.get('action')

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SCRIPTS):
            messages.error(self.request, "You do not have permission to update scripts.")
            return redirect('mm_scripts:list')
        ##############################

        if not agent_id or not action:
            messages.error(request, "Invalid input. Please try again.")
            logger.error(f"Invalid input. Please try again.")
            return redirect('mm_scripts:connect')
        try:
            agent = Assistant.objects.get(id=agent_id)
            if action == 'add' and script_id:
                custom_script = CustomScript.objects.get(id=script_id)
                CustomScriptReference.objects.create(assistant=agent, custom_script=custom_script,
                                                     created_by_user=request.user)
                logger.info(f"Script '{custom_script.name}' assigned to assistant '{agent.name}'.")
                messages.success(request, f"Script '{custom_script.name}' assigned to assistant '{agent.name}'.")
            elif action == 'remove':
                ref_id = request.POST.get('reference_id')
                if ref_id:
                    ref = CustomScriptReference.objects.get(id=ref_id)
                    ref.delete()
                    logger.info(f"Script reference removed from assistant '{agent.name}'.")
                    messages.success(request, f"Script reference removed from assistant '{agent.name}'.")
        except Assistant.DoesNotExist:
            messages.error(request, "Assistant not found.")
            logger.error(f"Assistant not found.")
        except CustomScript.DoesNotExist:
            logger.error(f"Custom Script not found.")
            messages.error(request, "Custom Script not found.")
        except CustomScriptReference.DoesNotExist:
            logger.error(f"Custom Script Reference not found.")
            messages.error(request, "Custom Script Reference not found.")
        return redirect('mm_scripts:connect')


Contents of ../../apps/mm_scripts/views/script/list_scripts_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_scripts_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.core.paginator import Paginator
from django.db.models import Q
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scripts.models import CustomScript
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomScriptView_List(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SCRIPTS):
            messages.error(self.request, "You do not have permission to list scripts.")
            return context
        ##############################

        context_user = self.request.user
        conn_orgs = Organization.objects.filter(users__in=[context_user])
        users_of_conn_orgs = User.objects.filter(profile__user__in=[
            user for org in conn_orgs for user in org.users.all()])
        scripts_list = CustomScript.objects.filter(created_by_user__in=users_of_conn_orgs)
        search_query = self.request.GET.get('search', '')
        if search_query:
            scripts_list = scripts_list.filter(
                Q(name__icontains=search_query) | Q(description__icontains=search_query))

        paginator = Paginator(scripts_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['scripts'] = page_obj.object_list
        context['total_scripts'] = CustomScript.objects.count()
        context['public_scripts'] = CustomScript.objects.filter(is_public=True).count()
        context['private_scripts'] = CustomScript.objects.filter(is_public=False).count()
        context['search_query'] = search_query
        logger.info(f"User: {self.request.user.id} listed scripts.")
        return context


Contents of ../../apps/mm_scripts/views/script/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_scripts_views import *
from .create_script_views import *
from .delete_script_views import *
from .connections_scripts_views import *


Contents of ../../apps/mm_scripts/views/script/delete_script_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_script_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scripts.models import CustomScript
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class CustomScriptView_Delete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        custom_script_id = self.kwargs.get('pk')
        custom_script = CustomScript.objects.get(id=custom_script_id)
        context['custom_script'] = custom_script
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SCRIPTS):
            messages.error(self.request, "You do not have permission to delete scripts.")
            return redirect('mm_scripts:list')
        ##############################

        custom_script_id = self.kwargs.get('pk')
        custom_script = CustomScript.objects.get(id=custom_script_id)

        try:
            custom_script.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the custom script: " + str(e))
            return redirect("mm_scripts:list")

        logger.info(f"Custom Script was deleted by User: {self.request.user.id}.")
        messages.success(request, "Custom Script deleted successfully.")
        return redirect('mm_scripts:list')


Contents of ../../apps/mm_scripts/views/script/create_script_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_script_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scripts.forms import CustomScriptForm
from apps.mm_scripts.utils import CUSTOM_SCRIPT_CATEGORIES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomScriptView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = CustomScriptForm()
        context['CUSTOM_SCRIPT_CATEGORIES'] = CUSTOM_SCRIPT_CATEGORIES
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SCRIPTS):
            messages.error(self.request, "You do not have permission to add scripts.")
            return redirect('mm_scripts:list')
        ##############################

        form = CustomScriptForm(request.POST, request.FILES)
        if form.is_valid():
            custom_script = form.save(commit=False)
            custom_script.created_by_user = request.user
            categories = request.POST.getlist('categories')
            step_guide = request.POST.getlist('script_step_guide[]')
            custom_script.script_step_guide = step_guide
            if request.FILES.get('script_picture'):
                custom_script.script_picture = request.FILES.get('script_picture')
            custom_script.categories = categories
            script_content = request.POST.get('code_text', '')
            custom_script.script_content = script_content
            custom_script.save()
            logger.info(f"Custom Script was created by User: {self.request.user.id}.")
            messages.success(request, "Custom Script created successfully!")
            return redirect('mm_scripts:list')
        else:
            logger.error(f"Error creating Custom Script by User: {self.request.user.id}.")
            messages.error(request, "There was an error creating the custom script.")

        return render(request, self.template_name, {
            'form': form, 'CUSTOM_SCRIPT_CATEGORIES': CUSTOM_SCRIPT_CATEGORIES})


Contents of ../../apps/mm_scripts/views/store/script_store_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: script_store_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.mm_scripts.models import CustomScript, CustomScriptReference
from apps.mm_scripts.utils import CUSTOM_SCRIPT_CATEGORIES
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class CustomScriptView_Store(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        search_query = self.request.GET.get('search', '')
        selected_categories = self.request.GET.getlist('categories')
        scripts_list = CustomScript.objects.filter(is_public=True)
        if search_query:
            scripts_list = scripts_list.filter(
                Q(name__icontains=search_query) | Q(description__icontains=search_query))
        if selected_categories:
            scripts_list = scripts_list.filter(
                *[Q(categories__icontains=category) for category in selected_categories])

        script_agent_map = {
            script.id: Assistant.objects.exclude(customscriptreference__custom_script=script)
            for script in scripts_list}
        paginator = Paginator(scripts_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['scripts'] = page_obj.object_list
        context['total_scripts'] = CustomScript.objects.count()
        context['public_scripts'] = CustomScript.objects.filter(is_public=True).count()
        context['private_scripts'] = CustomScript.objects.filter(is_public=False).count()
        context['CUSTOM_SCRIPT_CATEGORIES'] = CUSTOM_SCRIPT_CATEGORIES
        context['search_query'] = search_query
        context['selected_categories'] = selected_categories
        context['script_assistant_map'] = script_agent_map
        logger.info(f"Scripts list fetched successfully.")
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_SCRIPTS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_SCRIPTS):
            messages.error(self.request, "You do not have permission to update scripts.")
            return redirect('mm_scripts:list')
        ##############################

        action = request.POST.get('action')
        agent_id = request.POST.get('assistant_id')
        if action and action == "add" and agent_id:
            script_id = request.POST.get('script_id')
            if script_id:
                custom_script = CustomScript.objects.get(id=script_id)
                agent = Assistant.objects.get(id=agent_id)
                CustomScriptReference.objects.create(assistant=agent, custom_script=custom_script,
                                                     created_by_user=request.user)
                logger.info(f"Script '{custom_script.name}' assigned to assistant '{agent.name}'.")
                messages.success(request, f"Script '{custom_script.name}' assigned to assistant '{agent.name}'.")
        else:
            logger.error(f"Invalid input. Please try again.")
            messages.error(request, "Invalid input. Please try again.")
        return redirect('mm_scripts:store')


Contents of ../../apps/mm_scripts/views/store/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .script_store_views import *


Contents of ../../apps/user_permissions/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .permission import *
from .user_role import *


Contents of ../../apps/user_permissions/views/user_role/list_user_roles_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_user_roles_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.models import UserRole
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class PermissionView_UserRoleList(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_USER_ROLES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_USER_ROLES):
            messages.error(self.request, "You do not have permission to list user roles.")
            return context
        ##############################

        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        user_roles = UserRole.objects.filter(organization__in=user_orgs)
        paginator = Paginator(user_roles, 9)  # Show 9 roles per page
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        logger.info(f"User roles were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/user_permissions/views/user_role/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#


from .list_user_roles_views import *
from .create_user_role_views import *
from .manage_user_roles_views import *
from .delete_user_role_views import *
from .update_user_role_views import *


Contents of ../../apps/user_permissions/views/user_role/update_user_role_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_user_role_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404
from django.contrib import messages
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.forms import UserRoleForm
from apps.user_permissions.models import UserRole
from apps.user_permissions.utils import PERMISSION_TYPES, PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class PermissionView_UserRoleUpdate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        role_id = kwargs.get('pk')
        role = get_object_or_404(UserRole, pk=role_id)
        form = UserRoleForm(instance=role)
        orgs = Organization.objects.filter(users__in=[self.request.user])
        available_permissions = PERMISSION_TYPES
        selected_permissions = role.role_permissions
        context['role'] = role
        context['form'] = form
        context['organizations'] = orgs
        context['available_permissions'] = available_permissions
        context['selected_permissions'] = selected_permissions
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_USER_ROLES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_USER_ROLES):
            messages.error(self.request, "You do not have permission to update user roles.")
            return redirect('user_permissions:list_user_roles')
        ##############################

        role_id = kwargs.get('pk')
        role = get_object_or_404(UserRole, pk=role_id)
        form = UserRoleForm(request.POST, instance=role)

        if form.is_valid():
            role = form.save(commit=False)
            role.organization = form.cleaned_data['organization']
            role.role_name = form.cleaned_data['role_name']
            selected_permissions = form.cleaned_data.get('role_permissions')
            role.role_permissions = selected_permissions
            role.save()
            logger.info(f"User role updated by User: {self.request.user.id}.")
            messages.success(request, f'Role "{role.role_name}" updated successfully.')
            return redirect('user_permissions:list_user_roles')
        else:
            logger.error(f"Error updating the role. Form errors: {form.errors}")
            messages.error(request, 'Error updating the role.')
            return self.render_to_response(self.get_context_data(**kwargs))


Contents of ../../apps/user_permissions/views/user_role/manage_user_roles_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: manage_user_roles_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.db import IntegrityError
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.models import UserRole, UserPermission
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class PermissionView_UserRoleManage(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['roles'] = UserRole.objects.filter(organization__users__in=[self.request.user])
        return context

    def _update_user_permissions(self, user, role, add=True):
        for perm_code in role.role_permissions:
            if add:
                try:
                    user_permission, created = UserPermission.objects.get_or_create(
                        user=user,
                        permission_type=perm_code
                    )
                except IntegrityError as e:
                    messages.error(self.request, f"Error adding permission '{perm_code}' for user {user.username}")
            else:
                try:
                    user_permission = UserPermission.objects.get(user=user, permission_type=perm_code)
                    user_permission.delete()
                except UserPermission.DoesNotExist:
                    pass

    def _remove_user_role(self, user, role):
        self._update_user_permissions(user, role, add=False)
        if role in user.roles.all():
            user.roles.remove(role)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - UPDATE_USER_ROLES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_USER_ROLES):
            messages.error(self.request, "You do not have permission to update user roles.")
            return redirect('user_permissions:list_user_roles')
        ##############################

        user_id = request.POST.get('user_id')
        role_id = request.POST.get('role_id')
        user = get_object_or_404(User, pk=user_id)
        role = get_object_or_404(UserRole, pk=role_id)
        if "add_user_to_role" in request.POST:
            self._update_user_permissions(user, role, add=True)
            if role not in user.roles.all():
                user.roles.add(role)
            logger.info(f"User role added by User: {self.request.user.id}.")
            messages.success(request, f"User '{user.username}' successfully assigned to role '{role.role_name}'")
        elif "remove_user_role" in request.POST:
            self._remove_user_role(user, role)
            logger.info(f"User role removed by User: {self.request.user.id}.")
            messages.success(request, f"User '{user.username}' successfully removed from role '{role.role_name}'")
        return redirect('user_permissions:manage_user_roles')


Contents of ../../apps/user_permissions/views/user_role/delete_user_role_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_user_role_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.models import UserRole
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class PermissionView_UserRoleDelete(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        role_id = kwargs.get("pk")
        role = get_object_or_404(UserRole, pk=role_id, organization__users__in=[self.request.user])
        context.update({"role": role})
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_USER_ROLES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_USER_ROLES):
            messages.error(self.request, "You do not have permission to delete a user role.")
            return redirect('user_permissions:list_user_roles')
        ##############################

        role_id = kwargs.get("pk")
        role = get_object_or_404(UserRole, pk=role_id, created_by_user=request.user)

        try:
            role.delete()
        except Exception as e:
            logger.error(f"User role deletion failed. Error: {e}")
            messages.error(request, f'The role "{role.role_name}" could not be deleted.')
            return redirect('user_permissions:list_user_roles')

        logger.info(f"User role was deleted by User: {self.request.user.id}.")
        messages.success(request, f'The role "{role.role_name}" has been deleted successfully.')
        return redirect('user_permissions:list_user_roles')


Contents of ../../apps/user_permissions/views/user_role/create_user_role_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_user_role_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.forms import UserRoleForm
from apps.user_permissions.utils import PERMISSION_TYPES, PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class PermissionView_UserRoleCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        form = UserRoleForm()
        orgs = Organization.objects.filter(users__in=[self.request.user])
        available_permissions = PERMISSION_TYPES
        context['form'] = form
        context['organizations'] = orgs
        context['available_permissions'] = available_permissions
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_USER_ROLES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_USER_ROLES):
            messages.error(self.request, "You do not have permission to add a user role.")
            return redirect('user_permissions:list_user_roles')
        ##############################

        form = UserRoleForm(request.POST)
        if form.is_valid():
            role = form.save(commit=False)
            role.created_by_user = request.user
            selected_permissions = request.POST.getlist('role_permissions')
            role.role_permissions = selected_permissions
            role.save()
            logger.info(f"User role created by User: {self.request.user.id}.")
            messages.success(request, f'Role "{role.role_name}" created successfully.')
            return redirect('user_permissions:list_user_roles')
        else:
            logger.error(f"Error creating the role. Form errors: {form.errors}")
            messages.error(request, 'Error creating the role.')
            return redirect('user_permissions:add_user_role')


Contents of ../../apps/user_permissions/views/permission/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#


from .list_permissions_views import *
from .create_permission_views import *


Contents of ../../apps/user_permissions/views/permission/create_permission_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_permission_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404, redirect, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.models import UserPermission
from apps.user_permissions.utils import PERMISSION_TYPES, PermissionNames, get_permissions_grouped
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class PermissionView_PermissionCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        context['users'] = []
        context['permissions'] = get_permissions_grouped()
        if 'organization' in self.request.GET:
            org_id = self.request.GET.get('organization')
            org = get_object_or_404(Organization, id=org_id)
            context['selected_organization'] = org
            context['users'] = org.users.all()
        if 'user' in self.request.GET:
            user_id = self.request.GET.get('user')
            user = get_object_or_404(User, id=user_id)
            context['selected_user'] = user
            context['existing_permissions'] = list(user.permissions.values_list('permission_type', flat=True))
            context['available_permissions'] = [
                perm for perm in PERMISSION_TYPES if perm[0] not in context['existing_permissions']
            ]
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - MODIFY_USER_PERMISSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.MODIFY_USER_PERMISSIONS):
            messages.error(self.request, "You do not have permission to add/modify permissions.")
            return redirect('user_permissions:list_permissions')
        ##############################

        org_id = request.POST.get('organization')
        user_id = request.POST.get('user')
        selected_permissions = request.POST.getlist('permissions')
        if org_id and user_id and selected_permissions:
            user = get_object_or_404(User, id=user_id)
            for perm in selected_permissions:
                UserPermission.objects.get_or_create(user=user, permission_type=perm)
            logger.info(f"Permissions added to User: {user.id}.")
            return redirect('user_permissions:list_permissions')
        context = self.get_context_data(**kwargs)
        context['error_messages'] = "All fields are required."
        logger.error("All fields are required.")
        return render(request, self.template_name, context)


Contents of ../../apps/user_permissions/views/permission/list_permissions_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_permissions_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import redirect, get_object_or_404, render
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.models import UserPermission
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class PermissionView_PermissionList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        ##############################
        # PERMISSION CHECK FOR - LIST_USER_PERMISSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_USER_PERMISSIONS):
            messages.error(self.request, "You do not have permission to view user permissions.")
            return context
        ##############################

        user = self.request.user
        organizations = Organization.objects.filter(users__in=[user])
        org_users_permissions = {
            org: {"users": {user: user.permissions.all() for user in org.users.all()}} for org in organizations
        }
        context['org_users_permissions'] = org_users_permissions
        return context

    def post(self, request, *args, **kwargs):
        user_id = request.POST.get('user_id')
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - MODIFY_USER_PERMISSIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.MODIFY_USER_PERMISSIONS):
            messages.error(self.request, "You do not have permission to add/modify permissions.")
            return redirect('user_permissions:list_permissions')
        ##############################

        user = get_object_or_404(User, id=user_id)
        permissions_data = request.POST.getlist('permissions')
        delete_requests = request.POST.getlist('delete_requests')
        for permission in user.permissions.all():
            if str(permission.id) in permissions_data and not permission.is_active:
                permission.is_active = True
                permission.save()
            elif str(permission.id) not in permissions_data and permission.is_active:
                permission.is_active = False
                permission.save()
        deletion_names = []
        for permission_id in delete_requests:
            permission = get_object_or_404(UserPermission, id=permission_id)
            deletion_names.append(permission.get_permission_type_code())
            permission.delete()
        logger.info(f"Permissions updated for User: {user.id}.")
        messages.success(request, 'Permissions updated successfully!')

        modify_permissions = PermissionNames.MODIFY_USER_PERMISSIONS
        list_permissions = PermissionNames.LIST_USER_PERMISSIONS
        if user.is_superuser:
            UserPermission.objects.get_or_create(user=user, permission_type=modify_permissions)
            UserPermission.objects.get_or_create(user=user, permission_type=list_permissions)
            modify_object = UserPermission.objects.get(user=user, permission_type=modify_permissions)
            list_object = UserPermission.objects.get(user=user, permission_type=list_permissions)
            if (not modify_object.is_active or not list_object.is_active or modify_permissions in deletion_names
                or list_permissions in deletion_names):
                messages.warning(request, 'You have removed your permission rights as an administrator, '
                                          'which would have prevented you from granting them back to yourself. '
                                          'We have automatically granted these permissions back to your account.')

            modify_object.is_active = True
            list_object.is_active = True
            modify_object.save()
            list_object.save()
            logger.info(f"User: {context_user.id} has granted permissions to User: {user.id}.")
        return render(request, self.template_name, self.get_context_data(**kwargs))


Contents of ../../apps/user_management/views/connect_user_to_organization_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: connect_user_to_organization_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class UserManagementView_ConnectUser(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user
        context_sub_users = context_user.profile.sub_users.all()
        context['users'] = context_sub_users
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        return context

    def post(self, request, *args, **kwargs):
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - CONNECT_USER_TO_ORGANIZATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CONNECT_USER_TO_ORGANIZATION):
            messages.error(self.request, "You do not have permission to connect users to organizations.")
            return redirect('user_management:list')
        ##############################

        user = request.POST.get('user')
        org_id = request.POST.get('organization')
        try:
            user = User.objects.get(id=user)
            org = Organization.objects.get(id=org_id)
            if user in org.users.all():
                messages.error(request, 'User is already a member of this organization.')
            else:
                org.users.add(user)
                logger.info(f"User: {user.id} was added to Organization: {org.id} by User: {context_user.id}.")
                messages.success(request, 'User added to organization successfully!')
        except User.DoesNotExist:
            logger.error(f"User does not exist. User ID: {user}")
            messages.error(request, 'User does not exist.')
        except Organization.DoesNotExist:
            logger.error(f"Organization does not exist. Organization ID: {org_id}")
            messages.error(request, 'Organization does not exist.')
        except Exception as e:
            logger.error(f"Error adding user to organization: {str(e)}")
            messages.error(request, f'Error adding user to organization: {str(e)}')
        return redirect('user_management:add_user_to_organization')


Contents of ../../apps/user_management/views/__init__.py:

#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .remove_user_from_all_organizations_views import *
from .remove_user_from_organization_views import *
from .list_users_views import *
from .create_user_views import *
from .delete_user_views import *
from .update_user_status_views import *
from .connect_user_to_organization_views import *


Contents of ../../apps/user_management/views/delete_user_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_user_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class UserManagementView_UserDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = get_object_or_404(User, id=kwargs['pk'])
        context['user_to_delete'] = user
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_USERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_USERS):
            messages.error(self.request, "You do not have permission to delete user accounts.")
            return redirect('user_management:list')
        ##############################

        user = get_object_or_404(User, id=kwargs['pk'])

        try:
            orgs = Organization.objects.filter(users__in=[user])
            for org in orgs:
                org.users.remove(user)
                org.save()
            user.delete()
        except Exception as e:
            logger.error(f"User deletion failed. Error: {e}")
            messages.error(request, 'User deletion failed.')
            return redirect('user_management:list')

        logger.info(f"User was deleted by User: {self.request.user.id}.")
        messages.success(request, 'User deleted successfully.')
        return redirect('user_management:list')


Contents of ../../apps/user_management/views/list_users_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_users_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_management.forms import UserStatusForm
from apps.user_permissions.utils import PermissionNames
from auth.models import Profile
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class UserManagementView_UserList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_USERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_USERS):
            messages.error(self.request, "You do not have permission to list users.")
            return context
        ##############################

        context_user = self.request.user
        orgs = Organization.objects.filter(users__in=[context_user])
        search_query = self.request.GET.get('search', '')
        page_number = self.request.GET.get('page', 1)
        org_users = {}
        for org in orgs:
            users = org.users.all()
            if search_query:
                users = users.filter(
                    Q(username__icontains=search_query) | Q(email__icontains=search_query) |
                    Q(profile__first_name__icontains=search_query) | Q(profile__last_name__icontains=search_query))
            paginator = Paginator(users, 10)
            page_obj = paginator.get_page(page_number)
            user_profiles = [(user, Profile.objects.filter(user=user).first()) for user in page_obj]
            org_users[org] = {'page_obj': page_obj, 'user_profiles': user_profiles,
                                       'search_query': search_query}
        context['org_users'] = org_users
        context['context_user'] = context_user
        return context

    def post(self, request, *args, **kwargs):
        form = UserStatusForm(request.POST)
        if form.is_valid():
            user_id = request.POST.get('user_id')
            profile = get_object_or_404(Profile, user__id=user_id)
            profile.is_active = form.cleaned_data['is_active']
            profile.save()
            user = profile.user
            user_permissions = user.permissions.all()
            for user_permission in user_permissions:
                user_permission.is_active = profile.is_active
                user_permission.save()
            logger.info(f"User status updated by User: {self.request.user.id}.")
            messages.success(request, 'User status updated successfully!')
        else:
            logger.error(f"Failed to update user status by User: {self.request.user.id}.")
            messages.error(request, 'Failed to update user status.')
        return redirect('user_management:list')


Contents of ../../apps/user_management/views/remove_user_from_all_organizations_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: remove_user_from_all_organizations_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class UserManagementView_UserRemoveFromAll(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = get_object_or_404(User, id=kwargs['pk'])
        context['user_to_remove'] = user
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - REMOVE_USER_FROM_ORGANIZATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_USER_FROM_ORGANIZATION):
            messages.error(self.request, "You do not have permission to remove users from organizations.")
            return redirect('user_management:list')
        ##############################

        user = get_object_or_404(User, id=kwargs['pk'])

        try:
            orgs = Organization.objects.filter(users__in=[user])
            for org in orgs:
                org.users.remove(user)
                org.save()
        except Exception as e:
            logger.error(f"User removal from organizations failed. Error: {e}")
            messages.error(request, 'User removal from organizations failed.')
            return redirect('user_management:list')

        logger.info(f"User was removed from all organizations by User: {self.request.user.id}.")
        messages.success(request, f'User removed from all organizations successfully.')
        return redirect('user_management:list')


Contents of ../../apps/user_management/views/create_user_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_user_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging
import uuid

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User, Group
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from auth.models import Profile
from auth.utils import is_valid_password, send_verification_email, send_invitation_email
from config import settings
from web_project import TemplateLayout


logger = logging.getLogger(__name__)

class UserManagementView_UserInvite(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_USERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_USERS):
            messages.error(self.request, "You do not have permission to add new users.")
            return redirect('user_management:list')
        ##############################

        username = request.POST.get('username')
        email = request.POST.get('email')
        pw = request.POST.get('password')
        confirm_pw = request.POST.get('confirm_password')
        org = request.POST.get('organization')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        phone_no = request.POST.get('phone_number')
        address = request.POST.get('address')
        city = request.POST.get('city')
        country = request.POST.get('country')
        postal_code = request.POST.get('postal_code')
        is_active = request.POST.get('is_active') == 'on'
        created_by_user = request.user

        if User.objects.filter(username=username, email=email).exists():
            messages.error(request, "This user already exists in the system.")
            return redirect("register")
        elif User.objects.filter(email=email).exists():
            messages.error(request, "The specified email is already in use.")
            return redirect("register")
        elif User.objects.filter(username=username).exists():
            messages.error(request, "The specified username is already in use.")
            return redirect("register")

        try:
            is_valid, message = is_valid_password(pw)
            if not is_valid:
                messages.error(request, message)
                return redirect("user_management:add")
            if pw != confirm_pw:
                messages.error(request, 'Passwords do not match')
                return redirect('user_management:add')

            created_user = User.objects.create_user(username=username, email=email, password=pw)
            created_user.set_password(pw)
            created_user.save()
            user_group, created = Group.objects.get_or_create(name="user")
            created_user.groups.add(user_group)
            token = str(uuid.uuid4())
            user_profile, created = Profile.objects.get_or_create(user=created_user)
            user_profile.email_token = token
            user_profile.email = email
            user_profile.username = username
            user_profile.first_name = first_name
            user_profile.last_name = last_name
            user_profile.phone_number = phone_no
            user_profile.address = address
            user_profile.city = city
            user_profile.country = country
            user_profile.postal_code = postal_code
            user_profile.is_active = is_active
            user_profile.organization = Organization.objects.get(id=org)
            user_profile.created_by_user = created_by_user
            user_profile.save()

            org = Organization.objects.get(id=org)
            org.users.add(created_user)
            org.save()
            created_by_user.profile.sub_users.add(created_user)
            created_by_user.profile.save()
            send_verification_email(email, token)

            if settings.EMAIL_HOST_USER and settings.EMAIL_HOST_PASSWORD:
                logger.info(f"Verification email sent to {email}")
                messages.success(request, "Verification email sent successfully.")
            else:
                logger.error("Email settings are not configured. Unable to send verification email.")
                messages.error(request, "Email settings are not configured. Unable to send verification email.")
            messages.success(request, 'User created successfully!')
            logger.info(f"User: {created_user.id} was created by User: {created_by_user.id}.")

            try:
                email = created_user.email
                send_invitation_email(email, token)
                if settings.EMAIL_HOST_USER and settings.EMAIL_HOST_PASSWORD:
                    logger.info(f"Invitation email sent to {email}")
                    messages.success(request, 'Invitation email sent successfully!')
                else:
                    logger.error('Email settings are not configured. Unable to send invitation email.')
                    messages.error(request, 'Email settings are not configured. Unable to send invitation email.')
                messages.success(request, 'Invitation email sent successfully!')
                logger.info(f"User: {created_user.id} was created by User: {created_by_user.id}.")
            except Exception as e:
                logger.error(f'Error sending invitation email: {str(e)}')
                messages.error(request, f'Error sending invitation email: {str(e)}')
        except Exception as e:
            logger.error(f'Error creating user: {str(e)}')
            messages.error(request, f'Error creating user: {str(e)}')
        return redirect('user_management:list')


Contents of ../../apps/user_management/views/update_user_status_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_user_status_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import redirect
from django.utils.decorators import method_decorator
from django.views.decorators.http import require_POST
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


@method_decorator(require_POST, name='dispatch')
class UserManagementView_UserUpdateStatus(LoginRequiredMixin, TemplateView):
    def post(self, request, *args, **kwargs):
        user_id = request.POST.get('user_id')
        is_active = request.POST.get('is_active') == 'true'

        ##############################
        # PERMISSION CHECK FOR - UPDATE_USERS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_USERS):
            messages.error(self.request, "You do not have permission to update/modify user accounts.")
            return redirect('user_management:list')
        ##############################

        try:
            user = User.objects.get(id=user_id)
            user.profile.is_active = is_active
            user.profile.save()
            logger.info(f"User status was updated by User: {self.request.user.id}.")
            return redirect('user_management:list')
        except Exception as e:
            logger.error(f"Error updating user status: {e}")
            messages.error(request, f'Error updating user status')
            return redirect('user_management:list')


Contents of ../../apps/user_management/views/remove_user_from_organization_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: remove_user_from_organization_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class UserManagementView_UserRemoveFromOrganization(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = get_object_or_404(User, id=kwargs['pk'])
        org = get_object_or_404(Organization, id=kwargs['org_id'])
        context['user_to_remove'] = user
        context['organization'] = org
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - REMOVE_USER_FROM_ORGANIZATION
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_USER_FROM_ORGANIZATION):
            messages.error(self.request, "You do not have permission to remove users from organizations.")
            return redirect('user_management:list')
        ##############################

        user = get_object_or_404(User, id=kwargs['pk'])
        org = get_object_or_404(Organization, id=kwargs['org_id'])

        try:
            org.users.remove(user)
            org.save()
        except Exception as e:
            logger.error(f"User removal from Organization failed. Error: {e}")
            messages.error(request, 'User removal from Organization failed.')
            return redirect('user_management:list')

        logger.info(f"User was removed from Organization: {org.id} by User: {self.request.user.id}.")
        messages.success(request, f'User removed from {org.name} successfully.')
        return redirect('user_management:list')


Contents of ../../apps/meta_integrations/views/store_meta_integration_category_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: store_meta_integration_category_views.py
#  Last Modified: 2024-11-06 17:50:41
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-06 17:50:42
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.datasource_codebase.models import CodeRepositoryStorageConnection
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection
from apps.datasource_ml_models.models import DataSourceMLModelConnection
from apps.datasource_nosql.models import NoSQLDatabaseConnection
from apps.datasource_sql.models import SQLDatabaseConnection
from apps.hadron_prime.models import HadronNodeAssistantConnection
from apps.llm_core.models import LLMCore
from apps.meta_integrations.models import MetaIntegrationCategory, MetaIntegrationTeam
from apps.metakanban.models import MetaKanbanAssistantConnection
from apps.metatempo.models import MetaTempoAssistantConnection
from apps.orchestrations.models import OrchestrationReactantAssistantConnection
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection
from web_project import TemplateLayout


class MetaIntegrationView_MetaIntegrationCategoryStore(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_PLUG_AND_PLAY_TEAMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_PLUG_AND_PLAY_TEAMS):
            messages.error(self.request, "You do not have permission to list plug and play teams.")
            return context
        ##############################

        category = MetaIntegrationCategory.objects.get(category_slug=self.kwargs['category_slug'])

        user_organizations = Organization.objects.filter(users__in=[self.request.user])
        llm_models = LLMCore.objects.filter(organization__in=user_organizations)
        web_browsers = DataSourceBrowserConnection.objects.filter(assistant__organization__in=user_organizations)
        ssh_file_systems = DataSourceFileSystem.objects.filter(assistant__organization__in=user_organizations)
        sql_databases = SQLDatabaseConnection.objects.filter(assistant__organization__in=user_organizations)
        nosql_databases = NoSQLDatabaseConnection.objects.filter(assistant__organization__in=user_organizations)
        knowledge_bases = DocumentKnowledgeBaseConnection.objects.filter(
            assistant__organization__in=user_organizations)
        code_bases = CodeRepositoryStorageConnection.objects.filter(assistant__organization__in=user_organizations)
        media_storages = DataSourceMediaStorageConnection.objects.filter(
            assistant__organization__in=user_organizations)
        ml_storages = DataSourceMLModelConnection.objects.filter(assistant__organization__in=user_organizations)
        video_generators = VideoGeneratorConnection.objects.filter(assistant__organization__in=user_organizations)
        project_items = ProjectItem.objects.filter(organization__in=user_organizations)
        hadron_node_connections = HadronNodeAssistantConnection.objects.filter(
            assistant__organization__in=user_organizations)
        metakanban_connections = MetaKanbanAssistantConnection.objects.filter(
            assistant__organization__in=user_organizations)
        metatempo_connections = MetaTempoAssistantConnection.objects.filter(
            assistant__organization__in=user_organizations)
        orchestration_connections = OrchestrationReactantAssistantConnection.objects.filter(
            assistant__organization__in=user_organizations)

        meta_integrations = MetaIntegrationTeam.objects.filter(
            meta_integration_category__category_slug=self.kwargs['category_slug']).order_by("meta_integration_name")
        context['category'] = category
        context['organizations'] = user_organizations
        context['meta_integration_teams'] = meta_integrations
        context['llm_models'] = llm_models
        context['web_browsers'] = web_browsers
        context['ssh_file_systems'] = ssh_file_systems
        context['sql_databases'] = sql_databases
        context['nosql_databases'] = nosql_databases
        context['knowledge_bases'] = knowledge_bases
        context['code_bases'] = code_bases
        context['media_storages'] = media_storages
        context['ml_storages'] = ml_storages
        context['video_generators'] = video_generators
        context['project_items'] = project_items
        context['hadron_node_connections'] = hadron_node_connections
        context['metakanban_connections'] = metakanban_connections
        context['metatempo_connections'] = metatempo_connections
        context['orchestration_connections'] = orchestration_connections
        return context


Contents of ../../apps/meta_integrations/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-06 17:47:50
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-06 17:47:51
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .integrate_meta_integration_team_views import *
from .list_meta_integration_categories_views import *
from .store_meta_integration_category_views import *


Contents of ../../apps/meta_integrations/views/integrate_meta_integration_team_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: integrate_meta_integration_team_views.py
#  Last Modified: 2024-11-06 17:50:49
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-06 17:50:50
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging
import os
import random
import uuid

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.files import File
from django.core.files.storage import default_storage
from django.shortcuts import redirect
from django.views import View

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.datasource_browsers.models import DataSourceBrowserConnection
from apps.datasource_codebase.models import CodeRepositoryStorageConnection, CodeBaseRepositoryChunk, \
    CodeBaseRepository
from apps.datasource_file_systems.models import DataSourceFileSystem
from apps.datasource_knowledge_base.models import DocumentKnowledgeBaseConnection, KnowledgeBaseDocumentChunk, \
    KnowledgeBaseDocument
from apps.datasource_media_storages.models import DataSourceMediaStorageConnection, DataSourceMediaStorageItem
from apps.datasource_ml_models.models import DataSourceMLModelConnection, DataSourceMLModelItem
from apps.datasource_nosql.models import NoSQLDatabaseConnection, CustomNoSQLQuery
from apps.datasource_sql.models import SQLDatabaseConnection, CustomSQLQuery
from apps.hadron_prime.models import HadronNodeAssistantConnection
from apps.leanmod.models import ExpertNetwork, ExpertNetworkAssistantReference, LeanAssistant
from apps.llm_core.models import LLMCore
from apps.meta_integrations.models import MetaIntegrationCategory, MetaIntegrationTeam
from apps.meta_integrations.utils import META_INTEGRATION_ORCHESTRATOR_STANDARD_INSTRUCTIONS, \
    META_INTEGRATION_LEANMOD_STANDARD_INSTRUCTIONS
from apps.metakanban.models import MetaKanbanAssistantConnection
from apps.metatempo.models import MetaTempoAssistantConnection
from apps.orchestrations.models import Maestro, OrchestrationReactantAssistantConnection
from apps.organization.models import Organization
from apps.projects.models import ProjectItem
from apps.user_permissions.utils import PermissionNames
from apps.video_generations.models import VideoGeneratorConnection
from config import settings

logger = logging.getLogger(__name__)


class MetaIntegrationView_IntegrateMetaIntegrationTeam(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        category_id = request.POST.get('category_id')
        category = MetaIntegrationCategory.objects.get(id=category_id)
        user = request.user

        ##############################
        # PERMISSION CHECK FOR - INTEGRATE_PLUG_AND_PLAY_TEAMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.INTEGRATE_PLUG_AND_PLAY_TEAMS):
            messages.error(self.request, "You do not have permission to integrate plug and play teams.")
            return redirect('meta_integrations:store', category.category_slug)
        ##############################

        meta_integration_id = request.POST.get('meta_integration_id')
        meta_integration_data: MetaIntegrationTeam = MetaIntegrationTeam.objects.get(id=meta_integration_id)

        organization_id = request.POST.get('organization')
        llm_model_id = request.POST.get('llm_model')
        web_browser_id = request.POST.get('web_browser')
        file_system_id = request.POST.get('file_system')
        sql_database_id = request.POST.get('sql_database')
        nosql_database_id = request.POST.get('nosql_database')
        knowledge_base_id = request.POST.get('knowledge_base')
        code_base_id = request.POST.get('code_base')
        media_storage_id = request.POST.get('media_storage')
        ml_storage_id = request.POST.get('ml_storage')
        video_generator_id = request.POST.get('video_generator')
        project_item_id = request.POST.get('project_item')
        hadron_node_conn_id = request.POST.get('hadron_node')
        metakanban_conn_id = request.POST.get('metakanban')
        metatempo_conn_id = request.POST.get('metatempo')
        orchestration_conn_id = request.POST.get('orchestration')

        organization = Organization.objects.get(id=organization_id)
        llm_model = LLMCore.objects.get(id=llm_model_id)

        web_browser = None
        if web_browser_id:
            web_browser = DataSourceBrowserConnection.objects.get(id=web_browser_id)
        file_system = None
        if file_system_id:
            file_system = DataSourceFileSystem.objects.get(id=file_system_id)
        sql_database = None
        if sql_database_id:
            sql_database = SQLDatabaseConnection.objects.get(id=sql_database_id)
        nosql_database = None
        if nosql_database_id:
            nosql_database = NoSQLDatabaseConnection.objects.get(id=nosql_database_id)
        knowledge_base = None
        if knowledge_base_id:
            knowledge_base = DocumentKnowledgeBaseConnection.objects.get(id=knowledge_base_id)
        code_base = None
        if code_base_id:
            code_base = CodeRepositoryStorageConnection.objects.get(id=code_base_id)
        media_storage = None
        if media_storage_id:
            media_storage = DataSourceMediaStorageConnection.objects.get(id=media_storage_id)
        ml_storage = None
        if ml_storage_id:
            ml_storage = DataSourceMLModelConnection.objects.get(id=ml_storage_id)
        video_generator = None
        if video_generator_id:
            video_generator = VideoGeneratorConnection.objects.get(id=video_generator_id)
        project_item = None
        if project_item_id:
            project_item = ProjectItem.objects.get(id=project_item_id)
        hadron_node = None
        if hadron_node_conn_id:
            hadron_node = HadronNodeAssistantConnection.objects.get(id=hadron_node_conn_id)
        metakanban = None
        if metakanban_conn_id:
            metakanban = MetaKanbanAssistantConnection.objects.get(id=metakanban_conn_id)
        metatempo = None
        if metatempo_conn_id:
            metatempo = MetaTempoAssistantConnection.objects.get(id=metatempo_conn_id)
        orchestration = None
        if orchestration_conn_id:
            orchestration = OrchestrationReactantAssistantConnection.objects.get(id=orchestration_conn_id)

        # Step 1: Retrieve the integration assistants
        integration_assistants = meta_integration_data.integration_assistants.all()

        # Step 2: Create each of the assistants and the specified data sources
        created_team_members = []
        for integration_data in integration_assistants:
            # Step 2.1: Create the assistant
            created_assistant = Assistant.objects.create(
                organization=organization,
                llm_model=llm_model,
                name=integration_data.integration_name,
                description=integration_data.integration_description,
                instructions=integration_data.integration_instructions,
                response_template=integration_data.integration_response_template,
                audience=integration_data.integration_audience,
                tone=integration_data.integration_tone,
                assistant_image=integration_data.integration_assistant_image,
                max_retry_count=integration_data.integration_max_retries,
                tool_max_attempts_per_instance=integration_data.integration_max_tool_retries,
                tool_max_chains=integration_data.integration_max_tool_pipelines,
                max_context_messages=integration_data.integration_max_message_memory,
                time_awareness=integration_data.integration_time_awareness,
                place_awareness=integration_data.integration_location_awareness,
                multi_step_reasoning_capability_choice=integration_data.integration_multi_step_reasoning,
                image_generation_capability=integration_data.integration_image_generation_capability,
                context_overflow_strategy=integration_data.integration_context_overflow_strategy,
                response_language=integration_data.integration_response_language,
                glossary=integration_data.integration_glossary,
                ner_integration=integration_data.ner_integration,
                created_by_user=user,
                last_updated_by_user=user
            )
            if project_item:
                created_assistant.project_items.set([project_item])
            created_assistant.save()

            # Step 2.2: Create a copy of the web browser
            try:
                if web_browser:
                    duplicated_web_browser = web_browser
                    duplicated_web_browser.pk = None
                    duplicated_web_browser.assistant = created_assistant
                    duplicated_web_browser.created_by_user = user
                    duplicated_web_browser.save()
                    created_assistant.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the web browser.')
                logger.error(f"Error occurred while integrating the web browser: {e}")

            # Step 2.3: Create a copy of the file system
            try:
                if file_system:
                    duplicated_file_system = file_system
                    duplicated_file_system.pk = None
                    duplicated_file_system.assistant = created_assistant
                    duplicated_file_system.created_by_user = user
                    duplicated_file_system.save()
                    created_assistant.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the file system.')
                logger.error(f"Error occurred while integrating the file system: {e}")

            # Step 2.4: Create a copy of the video generator
            try:
                if video_generator:
                    duplicated_video_generator = video_generator
                    duplicated_video_generator.pk = None
                    duplicated_video_generator.organization = organization
                    duplicated_video_generator.assistant = created_assistant
                    duplicated_video_generator.created_by_user = user
                    duplicated_video_generator.save()
                    created_assistant.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the video generator.')
                logger.error(f"Error occurred while integrating the video generator: {e}")

            # Step 2.5: Create a copy of the SQL database
            try:
                if sql_database:
                    sql_database: SQLDatabaseConnection
                    duplicated_sql_database = sql_database
                    duplicated_sql_database.pk = None
                    duplicated_sql_database.assistant = created_assistant
                    duplicated_sql_database.created_by_user = user
                    duplicated_sql_database.save()
                    created_assistant.save()

                    sql_queries = sql_database.custom_queries.all()
                    for sql_query in sql_queries:
                        sql_query: CustomSQLQuery
                        duplicated_sql_query = sql_query
                        duplicated_sql_query: CustomSQLQuery
                        duplicated_sql_query.pk = None
                        duplicated_sql_query.database_connection = duplicated_sql_database
                        duplicated_sql_query.save()
                        duplicated_sql_database.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the SQL database.')
                logger.error(f"Error occurred while integrating the SQL database: {e}")

            # Step 2.6: Create a copy of the NoSQL database
            try:
                if nosql_database:
                    nosql_database: NoSQLDatabaseConnection
                    duplicated_nosql_database = nosql_database
                    duplicated_nosql_database.pk = None
                    duplicated_nosql_database.assistant = created_assistant
                    duplicated_nosql_database.created_by_user = user
                    duplicated_nosql_database.save()
                    created_assistant.save()

                    nosql_queries = nosql_database.custom_queries.all()
                    for nosql_query in nosql_queries:
                        nosql_query: CustomNoSQLQuery
                        duplicated_nosql_query = nosql_query
                        duplicated_nosql_query: CustomNoSQLQuery
                        duplicated_nosql_query.pk = None
                        duplicated_nosql_query.database_connection = duplicated_nosql_database
                        duplicated_nosql_query.save()
                        duplicated_nosql_database.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the NoSQL database.')
                logger.error(f"Error occurred while integrating the NoSQL database: {e}")

            # Step 2.7: Create a copy of the knowledge base
            try:
                if knowledge_base:
                    knowledge_base: DocumentKnowledgeBaseConnection
                    duplicated_knowledge_base = knowledge_base
                    duplicated_knowledge_base: DocumentKnowledgeBaseConnection
                    duplicated_knowledge_base.pk = None
                    duplicated_knowledge_base.assistant = created_assistant
                    duplicated_knowledge_base.save()
                    created_assistant.save()

                    kb_documents = knowledge_base.knowledge_base_documents.all()
                    for kb_document in kb_documents:
                        kb_document: KnowledgeBaseDocument
                        duplicated_kb_document = kb_document
                        duplicated_kb_document: KnowledgeBaseDocument
                        duplicated_kb_document.pk = None
                        duplicated_kb_document.knowledge_base = duplicated_knowledge_base
                        duplicated_kb_document.save()
                        duplicated_knowledge_base.save()

                        kb_document_chunks = kb_document.document_chunks.all()
                        for kb_document_chunk in kb_document_chunks:
                            kb_document_chunk: KnowledgeBaseDocumentChunk
                            duplicated_kb_document_chunk = kb_document_chunk
                            duplicated_kb_document_chunk: KnowledgeBaseDocumentChunk
                            duplicated_kb_document_chunk.pk = None
                            duplicated_kb_document_chunk.document = duplicated_kb_document
                            duplicated_kb_document_chunk.save()
                            duplicated_kb_document.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the knowledge base.')
                logger.error(f"Error occurred while integrating the knowledge base: {e}")

            # Step 2.8: Create a copy of the code base
            try:
                if code_base:
                    code_base: CodeRepositoryStorageConnection
                    duplicated_code_base = code_base
                    duplicated_code_base: CodeRepositoryStorageConnection
                    duplicated_code_base.pk = None
                    duplicated_code_base.assistant = created_assistant
                    duplicated_code_base.save()
                    created_assistant.save()

                    code_repos = code_base.code_base_repositories.all()
                    for code_repo in code_repos:
                        code_repo: CodeBaseRepository
                        duplicated_code_repo = code_repo
                        duplicated_code_repo: CodeBaseRepository
                        duplicated_code_repo.pk = None
                        duplicated_code_repo.knowledge_base = duplicated_code_base
                        duplicated_code_repo.save()
                        duplicated_code_base.save()

                        code_repo_chunks = code_repo.repository_chunks.all()
                        for code_repo_chunk in code_repo_chunks:
                            code_repo_chunk: CodeBaseRepositoryChunk
                            duplicated_code_repo_chunk = code_repo_chunk
                            duplicated_code_repo_chunk: CodeBaseRepositoryChunk
                            duplicated_code_repo_chunk.pk = None
                            duplicated_code_repo_chunk.repository = duplicated_code_repo
                            duplicated_code_repo_chunk.save()
                            duplicated_code_repo.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the code base.')
                logger.error(f"Error occurred while integrating the code base: {e}")

            # Step 2.9: Create a copy of the media storage
            try:
                if media_storage:
                    media_storage: DataSourceMediaStorageConnection
                    duplicated_media_storage = media_storage
                    duplicated_media_storage: DataSourceMediaStorageConnection
                    duplicated_media_storage.pk = None
                    duplicated_media_storage.assistant = created_assistant
                    duplicated_media_storage.save()
                    created_assistant.save()

                    media_files = media_storage.items.all()
                    for media_file in media_files:
                        media_file: DataSourceMediaStorageItem
                        duplicated_media_file = media_file
                        duplicated_media_file: DataSourceMediaStorageItem
                        duplicated_media_file.pk = None
                        duplicated_media_file.storage_base = duplicated_media_storage
                        duplicated_media_file.save()
                        duplicated_media_storage.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the media storage.')
                logger.error(f"Error occurred while integrating the media storage: {e}")

            # Step 2.10: Create a copy of the ML storage
            try:
                if ml_storage:
                    ml_storage: DataSourceMLModelConnection
                    duplicated_ml_storage = ml_storage
                    duplicated_ml_storage: DataSourceMLModelConnection
                    duplicated_ml_storage.pk = None
                    duplicated_ml_storage.assistant = created_assistant
                    duplicated_ml_storage.save()
                    created_assistant.save()

                    ml_models = ml_storage.items.all()
                    for ml_model in ml_models:
                        ml_model: DataSourceMLModelItem
                        duplicated_ml_model = ml_model
                        duplicated_ml_model: DataSourceMLModelItem
                        duplicated_ml_model.pk = None
                        duplicated_ml_model.ml_model_base = duplicated_ml_storage
                        duplicated_ml_model.save()
                        duplicated_ml_storage.save()
            except Exception as e:
                messages.error(request, 'An error occurred while integrating the ML storage.')
                logger.error(f"Error occurred while integrating the ML storage: {e}")

            # Step 2.11: Create a copy of the Hadron Node connection
            try:
                if hadron_node:
                    hadron_node: HadronNodeAssistantConnection
                    duplicated_hadron_node = hadron_node
                    duplicated_hadron_node: HadronNodeAssistantConnection
                    duplicated_hadron_node.pk = None
                    duplicated_hadron_node.assistant = created_assistant
                    duplicated_hadron_node.save()
                    created_assistant.save()
            except Exception as e:
                messages.error(request,
                               'An error occurred while integrating the Hadron Node <> Assistant connection.')
                logger.error(f"Error occurred while integrating the Hadron Node <> Assistant connection: {e}")

            # Step 2.12: Create a copy of the MetaKanban connection
            try:
                if metakanban:
                    metakanban: MetaKanbanAssistantConnection
                    duplicated_metakanban = metakanban
                    duplicated_metakanban: MetaKanbanAssistantConnection
                    duplicated_metakanban.pk = None
                    duplicated_metakanban.assistant = created_assistant
                    duplicated_metakanban.save()
                    created_assistant.save()
            except Exception as e:
                messages.error(request,
                               'An error occurred while integrating the MetaKanban <> Assistant connection.')
                logger.error(f"Error occurred while integrating the MetaKanban <> Assistant connection: {e}")

            # Step 2.13: Create a copy of the MetaTempo connection
            try:
                if metatempo:
                    metatempo: MetaTempoAssistantConnection
                    duplicated_metatempo = metatempo
                    duplicated_metatempo: MetaTempoAssistantConnection
                    duplicated_metatempo.pk = None
                    duplicated_metatempo.assistant = created_assistant
                    duplicated_metatempo.save()
                    created_assistant.save()
            except Exception as e:
                messages.error(request,
                               'An error occurred while integrating the MetaTempo <> Assistant connection.')
                logger.error(f"Error occurred while integrating the MetaTempo <> Assistant connection: {e}")

            # Step 2.14: Create a copy of the Orchestration connection
            try:
                if orchestration:
                    orchestration: OrchestrationReactantAssistantConnection
                    duplicated_orchestration = orchestration
                    duplicated_orchestration: OrchestrationReactantAssistantConnection
                    duplicated_orchestration.pk = None
                    duplicated_orchestration.assistant = created_assistant
                    duplicated_orchestration.save()
                    created_assistant.save()
            except Exception as e:
                messages.error(request,
                               'An error occurred while integrating the Orchestration <> Assistant connection.')
                logger.error(f"Error occurred while integrating the Orchestration <> Assistant connection: {e}")

            messages.success(request, 'Team Member Integrated: ' + created_assistant.name)
            created_team_members.append(created_assistant)

        # Step 3: Create the orchestrator (maestro) with the assistants
        try:
            orchestration_maestro = Maestro.objects.create(
                organization=organization,
                llm_model=llm_model,
                name="Team Manager: " + meta_integration_data.meta_integration_name,
                description="Team Description: " + meta_integration_data.meta_integration_description,
                instructions=META_INTEGRATION_ORCHESTRATOR_STANDARD_INSTRUCTIONS,
                workflow_step_guide="",
                maximum_assistant_limits=10,
                response_template="",
                audience="Inherited from Team",
                tone="Inherited from Team",
                maestro_image=meta_integration_data.meta_integration_team_image,
                created_by_user=user,
                last_updated_by_user=user
            )
            orchestration_maestro.workers.set(created_team_members)
            orchestration_maestro.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the orchestrator.')
            logger.error(f"Error occurred while integrating the orchestrator: {e}")

        # Step 4.1: expert network, references and leanmod assistant
        try:
            expert_network = ExpertNetwork.objects.create(
                organization=organization,
                name="Team Expert Network: " + meta_integration_data.meta_integration_name,
                meta_description="Team Description: " + meta_integration_data.meta_integration_description,
                created_by_user=user,
                last_updated_by_user=user
            )
            expert_network.save()

            for team_member in created_team_members:
                created_expert_network_member = ExpertNetworkAssistantReference.objects.create(
                    network=expert_network,
                    assistant=team_member,
                    context_instructions=team_member.instructions,
                    created_by_user=user,
                    last_updated_by_user=user
                )
                created_expert_network_member.save()

            static_image_directory = os.path.join(settings.STATIC_ROOT, 'img', 'team-leanmod-oracle-avatars')
            unique_filename = None
            available_images = [f for f in os.listdir(static_image_directory) if f.endswith(('png', 'jpg', 'jpeg'))]
            if available_images:
                random_image = random.choice(available_images)
                random_image_path = os.path.join(static_image_directory, random_image)
                unique_filename = f'lean_assistant_images/{uuid.uuid4()}.png'
                with open(random_image_path, 'rb') as img_file:
                    default_storage.save(unique_filename, File(img_file))

            created_lean_assistant = LeanAssistant.objects.create(
                organization=organization,
                llm_model=llm_model,
                name="Oracle Assistant for Team: " + meta_integration_data.meta_integration_name,
                instructions=META_INTEGRATION_LEANMOD_STANDARD_INSTRUCTIONS,
                lean_assistant_image=unique_filename if available_images else None,
                created_by_user=user,
                last_updated_by_user=user
            )
            created_lean_assistant.expert_networks.set([expert_network])
            created_lean_assistant.save()
        except Exception as e:
            messages.error(request, 'An error occurred while integrating the expert network and lean assistant.')
            logger.error(f"Error occurred while integrating the expert network and lean assistant: {e}")

        messages.success(request, 'Team member assistants has been integrated to the organization successfully.')
        return redirect('meta_integrations:store', category.category_slug)


Contents of ../../apps/meta_integrations/views/list_meta_integration_categories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_meta_integration_categories_views.py
#  Last Modified: 2024-11-06 17:50:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-06 17:50:33
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.meta_integrations.models import MetaIntegrationCategory
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


class MetaIntegrationView_MetaIntegrationCategoryList(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_PLUG_AND_PLAY_TEAMS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_PLUG_AND_PLAY_TEAMS):
            messages.error(self.request, "You do not have permission to list plug and play teams.")
            return context
        ##############################

        categories = MetaIntegrationCategory.objects.all().order_by("category_name")
        context['categories'] = categories

        total_boiler_plate_teams = 0
        for category in categories:
            total_boiler_plate_teams += category.metaintegrationteam_set.count()
        context['total_teams'] = total_boiler_plate_teams

        return context


Contents of ../../apps/voidforger/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-14 21:29:01
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 21:29:02
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .logs import *
from .configuration import *
from .chat import *


Contents of ../../apps/voidforger/views/configuration/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-15 16:14:43
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 16:14:44
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .voidforger_configuration_views import *
from .toggle_auto_run_voidforger_views import *
from .manual_trigger_voidforger_run_views import *
from .refresh_voidforger_connections_views import *


Contents of ../../apps/voidforger/views/configuration/toggle_auto_run_voidforger_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: toggle_auto_run_voidforger_views.py
#  Last Modified: 2024-11-14 22:31:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 18:54:11
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import VoidForger, VoidForgerToggleAutoExecutionLog
from apps.voidforger.utils import VoidForgerRuntimeStatusesNames, VoidForgerToggleAutoExecutionActionTypesNames


class VoidForgerView_AutoRunVoidForger(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - TOGGLE_ACTIVATE_AND_DEACTIVATE_VOIDFORGER
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.TOGGLE_ACTIVATE_AND_DEACTIVATE_VOIDFORGER):
            messages.error(self.request, "You do not have permission to toggle the activation status of VoidForger.")
            return redirect('voidforger:configuration')
        ##############################

        try:
            voidforger_id = kwargs.get('voidforger_id')
            voidforger = VoidForger.objects.get(id=voidforger_id)
            if voidforger.runtime_status == VoidForgerRuntimeStatusesNames.PAUSED:
                voidforger.runtime_status = VoidForgerRuntimeStatusesNames.ACTIVE
            elif voidforger.runtime_status == VoidForgerRuntimeStatusesNames.ACTIVE:
                voidforger.runtime_status = VoidForgerRuntimeStatusesNames.PAUSED
                voidforger.last_auto_execution_started_at = None
                voidforger.last_auto_execution_ended_at = None
                # Reset the current cycle if the VoidForger is paused.
                voidforger.auto_run_current_cycle = 0
            elif voidforger.runtime_status == VoidForgerRuntimeStatusesNames.WORKING:
                messages.error(self.request,
                               "VoidForger is currently working on a task. Please wait for it to finish before toggling.")
                return redirect('voidforger:configuration')
            else:
                messages.error(self.request, "VoidForger status is invalid.")
                return redirect('voidforger:configuration')
            voidforger.save()
            new_status = voidforger.runtime_status

            if new_status == VoidForgerRuntimeStatusesNames.ACTIVE:
                action_type = VoidForgerToggleAutoExecutionActionTypesNames.ACTIVATED
                metadata = {
                    "message": "VoidForger activation has been triggered by manual user interference. Activated VoidForger auto-execution pipeline."
                }
            elif new_status == VoidForgerRuntimeStatusesNames.PAUSED:
                action_type = VoidForgerToggleAutoExecutionActionTypesNames.PAUSED
                metadata = {
                    "message": "VoidForger de-activation has been triggered by manual user interference. Paused VoidForger auto-execution pipeline."
                }
            else:
                messages.error(self.request, "VoidForger action type is invalid.")
                return redirect('voidforger:configuration')

            VoidForgerToggleAutoExecutionLog.objects.create(voidforger=voidforger, action_type=action_type, metadata=metadata,
                                                            responsible_user=self.request.user)
        except Exception as e:
            messages.error(self.request, "VoidForger not found.")
            return redirect('voidforger:configuration')

        messages.success(self.request, "VoidForger activation status toggled to [" + new_status + "].")
        return redirect('voidforger:configuration')


Contents of ../../apps/voidforger/views/configuration/refresh_voidforger_connections_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_voidforger_connections_views.py
#  Last Modified: 2024-11-15 15:37:17
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 15:37:18
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import VoidForger


class VoidForgerView_RefreshVoidForgerConnections(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - REFRESH_VOIDFORGER_CONNECTIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REFRESH_VOIDFORGER_CONNECTIONS):
            messages.error(self.request, "You do not have permission to refresh VoidForger connections.")
            return redirect('voidforger:configuration')
        ##############################

        try:
            voidforger_id = kwargs.get('voidforger_id')
            voidforger = VoidForger.objects.get(id=voidforger_id)
            user_orgs = Organization.objects.filter(users=self.request.user)
            voidforger.organizations.set(user_orgs)
        except Exception as e:
            messages.error(self.request, "VoidForger not found.")
            return redirect('voidforger:configuration')

        messages.success(self.request, "VoidForger connections refreshed with all organizations of user.")
        return redirect('voidforger:configuration')


Contents of ../../apps/voidforger/views/configuration/voidforger_configuration_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: voidforger_configuration_views.py
#  Last Modified: 2024-11-14 22:31:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 18:53:12
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.assistants.utils import AGENT_SPEECH_LANGUAGES
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.llm_core.models import LLMCore
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import VoidForger
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VoidForgerView_Configuration(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        config, created = VoidForger.objects.get_or_create(user=self.request.user)

        # Updatable data selections
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        llm_cores = LLMCore.objects.filter(organization__in=user_orgs)

        # Calculate lifetime
        remaining_lifetime_cycles = config.auto_run_max_lifetime_cycles - config.auto_run_current_cycle
        remaining_lifetime_pct = (remaining_lifetime_cycles / config.auto_run_max_lifetime_cycles) * 100

        context['config'] = config
        context['user_orgs'] = user_orgs
        context['llm_cores'] = llm_cores
        context['AGENT_SPEECH_LANGUAGES'] = AGENT_SPEECH_LANGUAGES
        context['remaining_lifetime_cycles'] = remaining_lifetime_cycles
        context['remaining_lifetime_pct'] = remaining_lifetime_pct
        return context

    def post(self, request, *args, **kwargs):
        # Update VoidForger configurations here.

        ##############################
        # PERMISSION CHECK FOR - UPDATE_VOIDFORGER_CONFIGURATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UPDATE_VOIDFORGER_CONFIGURATIONS):
            messages.error(self.request, "You do not have permission to update VoidForger configurations.")
            return redirect('voidforger:configuration')
        ##############################

        config: VoidForger = VoidForger.objects.filter(user=request.user).first()
        if config:
            try:
                llm_model_id = request.POST.getlist('llm_model_id')
                llm_model = LLMCore.objects.filter(id__in=llm_model_id).first()

                additional_instructions = request.POST.get('additional_instructions')
                tone = request.POST.get('tone')
                response_language = request.POST.get('response_language')
                maximum_actions_per_cycle = request.POST.get('maximum_actions_per_cycle')
                auto_run_max_lifetime_cycles = request.POST.get('auto_run_max_lifetime_cycles')
                auto_run_trigger_interval_minutes = request.POST.get('auto_run_trigger_interval_minutes')

                if int(auto_run_trigger_interval_minutes) < 15:
                    messages.error(request, "Auto Run Trigger Interval Minutes must be at least 15 minutes.")
                    return redirect("voidforger:configuration")

                short_term_memory_max_messages = request.POST.get('short_term_memory_max_messages')

                if response_language not in [x for x, y in AGENT_SPEECH_LANGUAGES]:
                    response_language = "auto"

                config.llm_model = llm_model
                config.additional_instructions = additional_instructions
                config.tone = tone
                config.response_language = response_language
                config.maximum_actions_per_cycle = maximum_actions_per_cycle
                config.auto_run_max_lifetime_cycles = auto_run_max_lifetime_cycles
                config.auto_run_trigger_interval_minutes = auto_run_trigger_interval_minutes
                config.short_term_memory_max_messages = short_term_memory_max_messages
                config.save()
            except Exception as e:
                logger.error(f"Error while updating VoidForger configuration: {e}")
                messages.error(request, "Error while updating VoidForger configuration.")
                return redirect("voidforger:configuration")

        messages.success(request, "VoidForger Configuration updated successfully.")
        return redirect("voidforger:configuration")


Contents of ../../apps/voidforger/views/configuration/manual_trigger_voidforger_run_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: trigger_voidforger_run_views.py
#  Last Modified: 2024-11-14 22:34:34
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 22:34:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.tool_calls.utils import VoidForgerModesNames
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.core.voidforger.voidforger_executor import VoidForgerExecutionManager
from apps.user_permissions.utils import PermissionNames


class VoidForgerView_ManualTriggerVoidForgerRun(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - MANUALLY_TRIGGER_VOIDFORGER
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.MANUALLY_TRIGGER_VOIDFORGER):
            messages.error(self.request, "You do not have permission to manually trigger VoidForger runs.")
            return redirect('voidforger:configuration')
        ##############################

        try:
            voidforger_id = kwargs.get('voidforger_id')
            xc = VoidForgerExecutionManager(user=self.request.user, voidforger_id=voidforger_id)
            error = xc.run_cycle(trigger=VoidForgerModesNames.MANUAL)
            if error:
                messages.error(self.request, "VoidForger execution has failed: " + str(error))
                return redirect('voidforger:configuration')
        except Exception as e:
            messages.error(self.request, "VoidForger execution has failed: " + str(e))
            return redirect('voidforger:configuration')

        messages.success(self.request, "VoidForger execution has been triggered successfully.")
        return redirect('voidforger:configuration')


Contents of ../../apps/voidforger/views/chat/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-15 16:14:30
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 16:14:31
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .delete_voidforger_chat_views import *


Contents of ../../apps/voidforger/views/chat/delete_voidforger_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_voidforger_chat_views.py
#  Last Modified: 2024-11-14 22:31:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 18:53:06
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import MultimodalVoidForgerChat
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class VoidForgerView_DeleteVoidForgerChat(LoginRequiredMixin, DeleteView):
    template_name = 'voidforger/chats/voidforger_confirm_delete_chat.html'
    success_url = '/workspace/'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        chat = self.get_object()
        context['chat'] = chat
        return context

    def get_queryset(self):
        return MultimodalVoidForgerChat.objects.filter(user=self.request.user,
                                                       chat_source=SourcesForMultimodalChatsNames.APP)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - REMOVE_VOIDFORGER_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_VOIDFORGER_CHATS):
            messages.error(self.request, "You do not have permission to remove VoidForger Chats.")
            return redirect('multimodal_chat:main_workspace')
        ##############################

        chat = get_object_or_404(MultimodalVoidForgerChat, id=self.kwargs['pk'], user=self.request.user)

        try:
            chat.delete()
        except Exception as e:
            logger.error(f"VoidForger chat deletion failed. Error: {e}")
            messages.error(request, f'The VoidForger chat could not be deleted.')
            return redirect('multimodal_chat:main_workspace')

        logger.info(f"VoidForger chat was deleted by User: {self.request.user.id}.")
        return redirect('multimodal_chat:main_workspace')


Contents of ../../apps/voidforger/views/logs/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-15 16:15:26
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 16:15:26
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .list_action_memory_logs_views import *
from .purge_action_memory_logs_views import *
from .purge_auto_execution_logs_views import *
from .list_auto_execution_logs_views import *


Contents of ../../apps/voidforger/views/logs/purge_action_memory_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: purge_action_memory_logs_views.py
#  Last Modified: 2024-11-14 22:32:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 18:56:53
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import VoidForger


class VoidForgerView_PurgeActionMemoryLogs(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_VOIDFORGER_ACTION_MEMORY_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_VOIDFORGER_ACTION_MEMORY_LOGS):
            messages.error(self.request, "You do not have permission to delete VoidForger Action Memory Logs.")
            return redirect('voidforger:list_action_memory_logs')
        ##############################

        try:
            voidforger_id = kwargs.get('voidforger_id')
            voidforger = VoidForger.objects.get(id=voidforger_id)
            action_memory_logs = voidforger.voidforgeractionmemorylog_set.all()
            for action_memory_log in action_memory_logs:
                action_memory_log.delete()
        except Exception as e:
            messages.error(request, f"Error purging action memory logs: {e}")
            return redirect('voidforger:list_action_memory_logs')

        messages.success(request, "Action memory logs purged successfully.")
        return redirect('voidforger:list_action_memory_logs')


Contents of ../../apps/voidforger/views/logs/purge_auto_execution_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: purge_auto_execution_logs_views.py
#  Last Modified: 2024-11-14 22:32:32
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 18:57:06
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import VoidForger


class VoidForgerView_PurgeAutoExecutionLogs(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_VOIDFORGER_AUTO_EXECUTION_MEMORY_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_VOIDFORGER_AUTO_EXECUTION_MEMORY_LOGS):
            messages.error(self.request, "You do not have permission to delete VoidForger Auto Execution Memory Logs.")
            return redirect('voidforger:list_auto_execution_logs')
        ##############################

        try:
            voidforger_id = kwargs.get('voidforger_id')
            voidforger = VoidForger.objects.get(id=voidforger_id)
            auto_execution_memory_logs = voidforger.voidforgertoggleautoexecutionlog_set.all()
            for auto_execution_memory_log in auto_execution_memory_logs:
                auto_execution_memory_log.delete()
        except Exception as e:
            messages.error(request, f"Error purging auto execution memory logs: {e}")
            return redirect('voidforger:list_auto_execution_logs')

        messages.success(request, "Auto execution memory logs purged successfully.")
        return redirect('voidforger:list_auto_execution_logs')


Contents of ../../apps/voidforger/views/logs/list_action_memory_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_action_memory_logs_views.py
#  Last Modified: 2024-11-14 22:31:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 18:56:12
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import VoidForger
from web_project import TemplateLayout


class VoidForgerView_ListActionMemoryLogs(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - LIST_VOIDFORGER_ACTION_MEMORY_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_VOIDFORGER_ACTION_MEMORY_LOGS):
            messages.error(self.request, "You do not have permission to list VoidForger Action Memory Logs.")
            return context
        ##############################

        voidforger = VoidForger.objects.get(user=user)
        action_memory_logs = voidforger.voidforgeractionmemorylog_set.all().order_by('-timestamp')

        # Paginate logs
        paginator = Paginator(action_memory_logs, 10)
        page = self.request.GET.get('page', 1)
        try:
            logs = paginator.page(page)
        except PageNotAnInteger:
            logs = paginator.page(1)
        except EmptyPage:
            logs = paginator.page(paginator.num_pages)

        context['action_memory_logs'] = logs
        context['voidforger'] = voidforger
        return context


Contents of ../../apps/voidforger/views/logs/list_auto_execution_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_auto_execution_logs_views.py
#  Last Modified: 2024-11-14 22:31:35
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-15 18:56:30
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import VoidForger
from web_project import TemplateLayout


class VoidForgerView_ListVoidForgerAutoExecutionLogs(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - LIST_VOIDFORGER_AUTO_EXECUTION_MEMORY_LOGS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_VOIDFORGER_AUTO_EXECUTION_MEMORY_LOGS):
            messages.error(self.request, "You do not have permission to list VoidForger Auto Execution Memory Logs.")
            return context
        ##############################

        voidforger = VoidForger.objects.get(user=user)
        auto_execution_logs = voidforger.voidforgertoggleautoexecutionlog_set.all().order_by('-timestamp')

        # Paginate logs
        paginator = Paginator(auto_execution_logs, 10)
        page = self.request.GET.get('page', 1)
        try:
            logs = paginator.page(page)
        except PageNotAnInteger:
            logs = paginator.page(1)
        except EmptyPage:
            logs = paginator.page(paginator.num_pages)

        context['auto_execution_logs'] = logs
        context['voidforger'] = voidforger
        return context


Contents of ../../apps/data_backups/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .manage_backups_views import *
from .delete_data_backup_views import *
from .reload_backup_views import *


Contents of ../../apps/data_backups/views/delete_data_backup_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_data_backup_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.data_backups.models import DataBackup
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class DataBackupView_BackupDelete(LoginRequiredMixin, View):
    def post(self, request, backup_id, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_DATA_BACKUPS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_DATA_BACKUPS):
            messages.error(request, "You do not have permission to delete backups.")
            return redirect('data_backups:manage')
        ##############################

        backup = get_object_or_404(DataBackup, id=backup_id)
        try:
            backup.delete()
            logger.info(f"User: {request.user} - Backup: {backup.backup_name} - Deleted.")
            messages.success(request, f"The backup '{backup.backup_name}' was deleted successfully.")
        except Exception as e:
            messages.error(request, f"An error occurred while trying to delete the backup: {str(e)}")
        logger.error(f"User: {request.user} - Backup: {backup.backup_name} - Deletion failed.")
        return redirect('data_backups:manage')


Contents of ../../apps/data_backups/views/reload_backup_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: reload_backup_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.data_backups.data_backup_executor import DataBackupExecutor
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.data_backups.models import DataBackup
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class DataBackupView_ReloadBackup(LoginRequiredMixin, View):
    def post(self, request, backup_id, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - RESTORE_DATA_BACKUPS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.RESTORE_DATA_BACKUPS):
            messages.error(self.request, "You do not have permission to restore backups.")
            return redirect('data_backups:manage')
        ##############################

        backup = get_object_or_404(DataBackup, id=backup_id)
        password = request.POST.get('backup_password')
        try:
            result = DataBackupExecutor.restore(backup_object=backup, password=password)
            if result is None:
                logger.info(f"User: {request.user} - Backup: {backup.backup_name} - Reloaded.")
                messages.success(request, f"Backup '{backup.backup_name}' has been successfully reloaded.")
            else:
                logger.error(f"User: {request.user} - Backup: {backup.backup_name} - Reload failed.")
                messages.error(request, result)
        except Exception as e:
            logger.error(f"User: {request.user} - Backup: {backup.backup_name} - Reload failed.")
            messages.error(request, f"An error occurred while trying to reload the backup: {str(e)}")
        return redirect('data_backups:manage')


Contents of ../../apps/data_backups/views/manage_backups_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: manage_backups_views.py
#  Last Modified: 2024-10-05 01:39:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:39
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.data_backups.data_backup_executor import DataBackupExecutor
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.data_backups.models import DataBackup
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout
from apps.data_backups.utils import BACKUP_TYPES, BackupTypesNames

logger = logging.getLogger(__name__)


class DataBackupView_BackupManage(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_DATA_BACKUPS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_DATA_BACKUPS):
            messages.error(self.request, "You do not have permission to list backups.")
            return context
        ##############################

        try:
            user_orgs = Organization.objects.filter(users__in=[self.request.user])
            backups_list = DataBackup.objects.filter(
                Q(responsible_user=self.request.user) | Q(organization__in=user_orgs)
            ).order_by('-created_at')
            paginator = Paginator(backups_list, 10)
            page_number = self.request.GET.get('page')
            page_obj = paginator.get_page(page_number)
        except Exception as e:
            logger.error(f"Error getting data backup list: {e}")
            return context

        context['page_obj'] = page_obj
        context['organizations'] = user_orgs
        context['backup_types'] = BACKUP_TYPES
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_DATA_BACKUPS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_DATA_BACKUPS):
            messages.error(self.request, "You do not have permission to create backups.")
            return redirect('data_backups:manage')
        ##############################

        try:
            org_id = request.POST.get('organization')
            org = Organization.objects.get(id=org_id)
            backup_name = request.POST.get('backup_name')
            backup_password = request.POST.get('backup_password')
            backup_model = request.POST.get('backup_model')
            if org and backup_name and backup_password and backup_model:

                e = None
                if backup_model == BackupTypesNames.LLM_MODELS:
                    executor = DataBackupExecutor.BackupLLMModel(responsible_user=request.user, organization=org)
                    e = executor.backup_llm_models(backup_name=backup_name, password=backup_password)
                elif backup_model == BackupTypesNames.NER_INSTANCES:
                    executor = DataBackupExecutor.BackupNERInstance(responsible_user=request.user, organization=org)
                    e = executor.backup_ner_instances(backup_name=backup_name, password=backup_password)
                elif backup_model == BackupTypesNames.ASSISTANTS:
                    executor = DataBackupExecutor.BackupAssistant(responsible_user=request.user, organization=org)
                    e = executor.backup_assistants(backup_name=backup_name, password=backup_password)
                elif backup_model == BackupTypesNames.CUSTOM_FUNCTIONS:
                    executor = DataBackupExecutor.BackupCustomFunction(responsible_user=request.user, organization=None)
                    e = executor.backup_custom_functions(backup_name=backup_name, password=backup_password)
                elif backup_model == BackupTypesNames.CUSTOM_APIS:
                    executor = DataBackupExecutor.BackupCustomAPI(responsible_user=request.user, organization=None)
                    e = executor.backup_custom_apis(backup_name=backup_name, password=backup_password)
                elif backup_model == BackupTypesNames.CUSTOM_SCRIPTS:
                    executor = DataBackupExecutor.BackupCustomScript(responsible_user=request.user, organization=None)
                    e = executor.backup_custom_scripts(backup_name=backup_name, password=backup_password)
                else:
                    e = "Invalid backup model selected."
                    messages.error(request, e)
                if e is None:
                    logger.info(f"User: {request.user} - Backup created successfully.")
                    messages.success(request, "Backup created successfully!")
                else:
                    logger.error(f"User: {request.user} - Backup creation failed. Error: {e}")
                    messages.error(request, "An error occurred while creating the backup.")
            else:
                logger.error("User: {request.user} - Backup creation failed.")
                messages.error(request, "Please provide all the required fields.")
        except Exception as e:
            logger.error(f"Error creating backup: {e}")
            messages.error(request, "An error occurred while creating the backup: {e}")

        return redirect('data_backups:manage')


Contents of ../../apps/notifications/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-20 14:07:47
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-20 14:07:47
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .notification import *


Contents of ../../apps/notifications/views/notification/notification_delete_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: notification_delete_views.py
#  Last Modified: 2024-10-20 14:19:57
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-20 14:19:57
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.notifications.models import NotificationItem
from apps.user_permissions.utils import PermissionNames

logger = logging.getLogger(__name__)


class NotificationView_ItemDelete(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - DELETE_INTERNAL_NOTIFICATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_INTERNAL_NOTIFICATIONS):
            messages.error(request, "You do not have permission to delete internal notifications.")
            return redirect('notifications:list_create')
        ##############################

        try:
            notification_id = kwargs.get('pk')
            notification = get_object_or_404(NotificationItem, id=notification_id)
            notification.delete()
            logger.info(f"Notification deleted: {notification_id} by {request.user.username}")
            messages.success(request, 'Notification deleted successfully.')
        except NotificationItem.DoesNotExist:
            logger.error(f"Notification not found.")
            messages.error(request, 'Notification not found.')
        except Exception as e:
            logger.error(f"Error deleting notification: {e}")
            messages.error(request, 'An error occurred while trying to delete the notification.')
        return redirect('notifications:list_create')


Contents of ../../apps/notifications/views/notification/notification_toggle_read_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: notification_toggle_read_views.py
#  Last Modified: 2024-10-20 16:59:14
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-20 16:59:15
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views import View

from apps.notifications.models import NotificationItem

logger = logging.getLogger(__name__)


class NotificationView_MarkAllAsRead(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        try:
            user = request.user
            user_notifications = user.profile.notifications.all()
            for notification in user_notifications:
                notification: NotificationItem
                notification.readers.add(user) if notification.readers is not None else notification.readers.set(
                    [user])
                notification.save()
        except Exception as e:
            logger.error(f"Error marking all notifications as read: {e}")
            return redirect("notifications:list_create")

        logger.info(f"All notifications marked as read for user.")
        return redirect("notifications:list_create")


Contents of ../../apps/notifications/views/notification/notification_list_create_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: notification_create_views.py
#  Last Modified: 2024-10-20 14:19:45
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-20 14:19:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.notifications.models import NotificationItem
from apps.notifications.utils import (NotificationFAIconChoicesNames, NotificationSenderTypeNames,
                                      NOTIFICATION_TITLE_CATEGORY_CHOICES)
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames

from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class NotificationView_ItemListCreate(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        internal_notifications = NotificationItem.objects.filter(
            notification_sender_type=NotificationSenderTypeNames.SYSTEM,
            organization__in=user_orgs).order_by('-created_at')

        paginator = Paginator(internal_notifications, 10)
        page = self.request.GET.get('page')
        paginated_notifications = paginator.get_page(page)
        context['organizations'] = user_orgs
        context['internal_notifications'] = paginated_notifications
        context["notification_categories"] = NOTIFICATION_TITLE_CATEGORY_CHOICES
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - CREATE_INTERNAL_NOTIFICATIONS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.CREATE_INTERNAL_NOTIFICATIONS):
            messages.error(request, "You do not have permission to create internal notifications.")
            return redirect('notifications:list_create')
        ##############################

        try:
            organization_id = request.POST.get('organization_id')
            notification_category = request.POST.get('notification_category')
            organization = Organization.objects.get(id=organization_id)
            notification_text = request.POST.get('notification_text')

            new_notification = NotificationItem.objects.create(
                organization=organization,
                notification_sender_type=NotificationSenderTypeNames.SYSTEM,
                notification_title_category=notification_category,
                notification_fa_icon=NotificationFAIconChoicesNames.BUILDING,
                notification_message=notification_text)
            new_notification.save()
            NotificationItem.add_notification_to_users(notification=new_notification, acting_user=request.user)
            logger.info(f"Notification created: {new_notification}")
            messages.success(request, 'Notification created successfully.')
            return redirect('notifications:list_create')
        except Exception as e:
            logger.error(f"Error creating notification: {e}")
            messages.error(request, 'Error creating notification.')
            return redirect('notifications:list_create')


Contents of ../../apps/notifications/views/notification/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-20 14:19:37
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-20 14:19:38
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .notification_list_create_views import *
from .notification_delete_views import *
from .notification_toggle_read_views import *


Contents of ../../apps/memories/views/list_assistant_memories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_assistant_memories_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.memories.models import AssistantMemory
from apps.memories.utils import AgentStandardMemoryTypesNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class AssistantMemoryView_List(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ASSISTANT_MEMORIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ASSISTANT_MEMORIES):
            messages.error(self.request, "You do not have permission to list assistant memories.")
            return context
        ##############################

        org_memories = {}
        orgs = Organization.objects.filter(users=self.request.user)
        for org in orgs:
            agents = Assistant.objects.filter(organization=org)
            org_memories[org] = []
            for agent in agents:
                organization_spec_mems = AssistantMemory.objects.filter(
                    organization=org, assistant=agent, memory_type=AgentStandardMemoryTypesNames.ORGANIZATION_SPECIFIC)
                agent_spec_mems = AssistantMemory.objects.filter(
                    organization=org, assistant=agent, memory_type=AgentStandardMemoryTypesNames.ASSISTANT_SPECIFIC)
                user_spec_mems = AssistantMemory.objects.filter(
                    organization=org, assistant=agent, memory_type=AgentStandardMemoryTypesNames.USER_SPECIFIC, user=self.request.user)
                memories = list(organization_spec_mems) + list(agent_spec_mems) + list(set(user_spec_mems))
                org_memories[org].extend(memories)
        context['org_assistants'] = org_memories
        logger.info(f"Assistant Memories were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/memories/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .create_assistant_memories_views import *
from .delete_assistant_memories_views import *
from .list_assistant_memories_views import *


Contents of ../../apps/memories/views/delete_assistant_memories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_assistant_memories_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.memories.models import AssistantMemory
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class AssistantMemoryView_Delete(LoginRequiredMixin, DeleteView):
    model = AssistantMemory
    success_url = 'memories:list'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_ASSISTANT_MEMORIES
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ASSISTANT_MEMORIES):
            messages.error(self.request, "You do not have permission to delete assistant memories.")
            return redirect('memories:list')
        ##############################

        memory = get_object_or_404(AssistantMemory, id=self.kwargs['pk'])

        try:
            memory.delete()
        except Exception as e:
            logger.error(f"Error deleting Assistant Memory: {e}")
            return redirect(self.success_url)

        success_message = "Memory deleted successfully!"
        messages.success(request, success_message)
        logger.info(f"Assistant Memory was deleted by User: {self.request.user.id}.")
        return redirect(self.success_url)


Contents of ../../apps/memories/views/create_assistant_memories_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_assistant_memories_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:34
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.memories.models import AssistantMemory
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class AssistantMemoryView_Create(TemplateView, LoginRequiredMixin):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        user = self.request.user
        agents = Assistant.objects.filter(organization__users=user)
        organizations = Organization.objects.filter(users__in=[user])
        context.update({'organizations': organizations, 'assistants': agents})
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - ADD_ASSISTANT_MEMORIES
        if not UserPermissionManager.is_authorized(
            user=self.request.user, operation=PermissionNames.ADD_ASSISTANT_MEMORIES):
            messages.error(self.request, "You do not have permission to add assistant memories.")
            return redirect('memories:list')
        ##############################

        org_id = request.POST.get('organization')
        org = Organization.objects.get(id=org_id)
        agent_id = request.POST.get('assistant')
        memory_type = request.POST.get('memory_type')
        memory_text_content = request.POST.get('memory_text_content')

        try:
            AssistantMemory.objects.create(user=request.user, assistant_id=agent_id, memory_type=memory_type,
                                           memory_text_content=memory_text_content, organization=org)
            agent = Assistant.objects.get(id=agent_id)
            agent.memories.add(AssistantMemory.objects.last())
        except Exception as e:
            logger.error(f"Error creating Assistant Memory: {e}")
            return redirect('memories:create')

        logger.info(f"Assistant Memory was created by User: {self.request.user.id}.")
        return redirect('memories:list')


Contents of ../../apps/multimodal_chat/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

from .lean_chat import *
from .chat import *
from .workspace import *
from .multimodality import *


Contents of ../../apps/multimodal_chat/views/lean_chat/stream_lean_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: stream_lean_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import base64
import logging

from django.contrib import messages
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
from apps.core.media_managers.media_manager_execution_handler import MediaManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalLeanChat, MultimodalLeanChatMessage
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class ChatView_LeanChatStream(View):

    def post(self, request, *args, **kwargs):
        context_user_id = request.POST.get('user_id')
        context_user = get_object_or_404(User, id=context_user_id)

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_LEAN_CHATS
        if not UserPermissionManager.is_authorized(user=context_user,
                                                   operation=PermissionNames.CREATE_AND_USE_LEAN_CHATS):
            messages.error(self.request, "You do not have permission to create and use LeanMod chats.")
            return redirect('multimodal_chat:lean_chat')
        ##############################

        chat_id = request.POST.get('chat_id')
        chat: MultimodalLeanChat = get_object_or_404(MultimodalLeanChat, id=chat_id, user=request.user)
        msg_content = request.POST.get('message_content')
        attached_images = request.FILES.getlist('attached_images[]')
        attached_files = request.FILES.getlist('attached_files[]')
        sketch_image_full_uris_list = self._handle_sketch_image(request)
        edit_image_full_uris_list = self._handle_edit_image(request)
        image_full_uris = self._handle_save_images(attached_images, edit_image_full_uris_list, sketch_image_full_uris_list)
        file_full_uris = self._handle_save_files(attached_files)
        self._handle_record_audio(file_full_uris, request)

        MultimodalLeanChatMessage.objects.create(
            multimodal_lean_chat=chat, sender_type='USER', message_text_content=msg_content,
            message_image_contents=image_full_uris, message_file_contents=file_full_uris
        )
        user_msg = MultimodalLeanChatMessage.objects.filter(multimodal_lean_chat=chat).last()
        internal_llm_client_lean = GenerativeAIDecodeController.get_lean(
            user=request.user, assistant=chat.lean_assistant, multimodal_chat=chat)
        final_response = internal_llm_client_lean.respond_stream(latest_message=user_msg,
                                                                 image_uris=image_full_uris,
                                                                 file_uris=file_full_uris)
        MultimodalLeanChatMessage.objects.create(
            multimodal_lean_chat=chat, sender_type='ASSISTANT', message_text_content=final_response)
        logger.info(f"LeanMod Assistant responded to User: {context_user.id}.")
        return redirect('multimodal_chat:lean_chat')

    @staticmethod
    def _handle_record_audio(file_full_uris, request):
        record_audio = request.POST.get('record_audio')
        audio_full_uri = None
        if record_audio:
            audio_base_64 = request.POST.get('record_audio')
            audio_bytes = base64.b64decode(audio_base_64.split("base64,")[1].encode())
            audio_full_uri = MediaManager.save_files_and_return_uris([(audio_bytes, 'audio.webm')])[0]
        if audio_full_uri:
            file_full_uris.append(audio_full_uri)
        logger.info(f"Audio was saved successfully.")
        return

    @staticmethod
    def _handle_save_files(attached_files):
        file_bytes_list = []
        for file in attached_files:
            file_name = file.name
            try:
                file_bytes = file.read()
                logger.info(f"File was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading file.")
                continue
            file_bytes_list.append((file_bytes, file_name))
        file_full_uris = MediaManager.save_files_and_return_uris(file_bytes_list)
        return file_full_uris

    @staticmethod
    def _handle_save_images(attached_images, edit_image_full_uris_list, sketch_image_full_uris_list):
        image_bytes_list = []
        for image in attached_images:
            try:
                image_bytes = image.read()
                logger.info(f"Image was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading image.")
                continue
            image_bytes_list.append(image_bytes)
        image_full_uris = MediaManager.save_images_and_return_uris(image_bytes_list)
        if sketch_image_full_uris_list:
            image_full_uris.extend(sketch_image_full_uris_list)
        if edit_image_full_uris_list:
            image_full_uris.extend(edit_image_full_uris_list)
        return image_full_uris

    @staticmethod
    def _handle_edit_image(request):
        edit_image_bytes_dict = {'edit_image': None, 'edit_image_mask': None}
        attached_edit_image = request.FILES.get('edit_image')
        attached_edit_image_mask = request.POST.get('edit_image_mask')
        edit_image_full_uris_list = []
        try:
            edit_image_bytes = attached_edit_image.read()
            edit_image_mask_bytes = base64.b64decode(attached_edit_image_mask.split("base64,")[1].encode())
            edit_image_bytes_dict['edit_image'] = edit_image_bytes
            edit_image_bytes_dict['edit_image_mask'] = edit_image_mask_bytes
            edit_image_full_uris_list = MediaManager.save_edit_image_and_masked_image(
                edit_img_map=edit_image_bytes_dict)
            logger.info(f"Edit image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving edit image.")
            pass
        return edit_image_full_uris_list

    @staticmethod
    def _handle_sketch_image(request):
        sketch_image = {'sketch_image': None}
        attached_canvas_image = request.POST.get('sketch_image')
        sketch_image_full_uris_list = []
        try:
            sketch_image_bytes = base64.b64decode(attached_canvas_image.split("base64,")[1].encode())
            sketch_image['sketch_image'] = sketch_image_bytes
            sketch_image_full_uris_list = MediaManager.save_sketch(sketch_data_map=sketch_image)
            logger.info(f"Sketch image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving sketch image.")
            pass
        return sketch_image_full_uris_list


Contents of ../../apps/multimodal_chat/views/lean_chat/list_archived_lean_chats_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_archived_lean_chats_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import LeanAssistant
from apps.message_templates.models import MessageTemplate
from apps.multimodal_chat.models import MultimodalLeanChat
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from config.settings import MEDIA_URL
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ChatView_LeanChatListArchivedChats(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        active_chat = None
        context_user = self.request.user
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_LEAN_CHATS
        if not UserPermissionManager.is_authorized(user=context_user,
                                                   operation=PermissionNames.CREATE_AND_USE_LEAN_CHATS):
            messages.error(self.request, "You do not have permission to create and use LeanMod chats.")
            return context
        ##############################

        if 'chat_id' in self.request.GET:
            active_chat = get_object_or_404(MultimodalLeanChat, id=self.request.GET['chat_id'], user=self.request.user)

        chats = MultimodalLeanChat.objects.filter(
            user=self.request.user, chat_source=SourcesForMultimodalChatsNames.APP, is_archived=True)
        if active_chat:
            chats = [active_chat] + [chat for chat in chats if chat.id != active_chat.id]
        else:
            if len(chats) > 0:
                active_chat = chats[0]

        lean_agents = LeanAssistant.objects.filter(organization__users=self.request.user)
        orgs = Organization.objects.filter(lean_assistants__in=lean_agents)
        msg_templates = MessageTemplate.objects.filter(user=context_user, organization__in=orgs)
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        active_chat_msgs = active_chat.lean_chat_messages.all().order_by('sent_at') if active_chat else None
        context.update({
            "chats": chats, "assistants": lean_agents, "active_chat": active_chat,
            "chat_messages": active_chat_msgs, "message_templates": msg_templates, "base_url": MEDIA_URL})
        logger.info(f"LeanMod chats were listed for User: {self.request.user.id}.")
        return context


Contents of ../../apps/multimodal_chat/views/lean_chat/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

#
from .lean_chat_views import *
from .delete_lean_chat_views import *
from .stream_lean_chat_views import *
from .unarchive_lean_chat_views import *
from .archive_lean_chat_views import *
from .list_archived_lean_chats_views import *


Contents of ../../apps/multimodal_chat/views/lean_chat/delete_lean_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_lean_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalLeanChat
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ChatView_LeanChatDelete(LoginRequiredMixin, DeleteView):
    template_name = 'multimodal_chat/chats/confirm_delete_lean_chat.html'
    success_url = '/lean_chat/'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        chat = self.get_object()
        context['chat'] = chat
        return context

    def get_queryset(self):
        return MultimodalLeanChat.objects.filter(user=self.request.user, chat_source=SourcesForMultimodalChatsNames.APP)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - REMOVE_LEAN_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_LEAN_CHATS):
            messages.error(self.request, "You do not have permission to remove LeanMod chats.")
            return redirect('multimodal_chat:lean_chat')
        ##############################

        chat = get_object_or_404(MultimodalLeanChat, id=self.kwargs['pk'], user=self.request.user)
        chat.delete()
        logger.info(f"LeanMod chat was deleted by User: {self.request.user.id}.")
        return redirect('multimodal_chat:lean_chat')


Contents of ../../apps/multimodal_chat/views/lean_chat/archive_lean_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: archive_lean_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalLeanChat
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ChatView_LeanChatArchive(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)

        ##############################
        # PERMISSION CHECK FOR - ARCHIVE_LEAN_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ARCHIVE_LEAN_CHATS):
            messages.error(self.request, "You do not have permission to archive LeanMod chats.")
            return self.render_to_response(context)
        ##############################

        pk = kwargs.get('pk')
        chat = get_object_or_404(MultimodalLeanChat, id=pk, user=self.request.user)
        chat.is_archived = True
        chat.save()
        logger.info(f"LeanMod chat was archived by User: {self.request.user.id}.")
        return redirect('multimodal_chat:lean_chat')


Contents of ../../apps/multimodal_chat/views/lean_chat/unarchive_lean_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: unarchive_lean_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalLeanChat
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ChatView_LeanChatUnarchive(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)

        ##############################
        # PERMISSION CHECK FOR - UNARCHIVE_LEAN_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UNARCHIVE_LEAN_CHATS):
            messages.error(self.request, "You do not have permission to archive LeanMod chats.")
            return self.render_to_response(context)
        ##############################

        pk = kwargs.get('pk')
        chat = get_object_or_404(MultimodalLeanChat, id=pk, user=self.request.user)
        chat.is_archived = False
        chat.save()
        logger.info(f"LeanMod chat was unarchived by User: {self.request.user.id}.")
        return redirect('multimodal_chat:lean_chat')


Contents of ../../apps/multimodal_chat/views/lean_chat/lean_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: lean_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import base64
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.media_managers.media_manager_execution_handler import MediaManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.leanmod.models import LeanAssistant
from apps.message_templates.models import MessageTemplate
from apps.multimodal_chat.models import MultimodalLeanChat, MultimodalLeanChatMessage
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames, generate_chat_name, ChatPostActionSpecifiers
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from config.settings import MEDIA_URL
from web_project import TemplateLayout, TemplateHelper


logger = logging.getLogger(__name__)


class ChatView_LeanChat(TemplateView, LoginRequiredMixin):

    @staticmethod
    def refresh_page(chat_id, user_id):
        return redirect(f'/lean_chat/?chat_id={chat_id}')

    def get_context_data(self, **kwargs):
        active_chat = None
        context_user = self.request.user
        if 'chat_id' in self.request.GET:
            active_chat = get_object_or_404(MultimodalLeanChat, id=self.request.GET['chat_id'], user=self.request.user)
        chats = MultimodalLeanChat.objects.filter(
            user=self.request.user, chat_source=SourcesForMultimodalChatsNames.APP, is_archived=False)
        if active_chat:
            chats = [active_chat] + [chat for chat in chats if chat.id != active_chat.id]
        else:
            pass

        lean_agents = LeanAssistant.objects.filter(organization__users=self.request.user)
        orgs = Organization.objects.filter(lean_assistants__in=lean_agents)
        msg_templates = MessageTemplate.objects.filter(user=context_user, organization__in=orgs)
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        active_chat_msgs = active_chat.lean_chat_messages.all().order_by('sent_at') if active_chat else None
        context.update({
            "chats": chats, "assistants": lean_agents, "active_chat": active_chat, "user": context_user,
            "chat_messages": active_chat_msgs, "message_templates": msg_templates, "base_url": MEDIA_URL
        })
        return context

    def post(self, request, *args, **kwargs):
        from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_LEAN_CHATS
        if not UserPermissionManager.is_authorized(user=context_user,
                                                   operation=PermissionNames.CREATE_AND_USE_LEAN_CHATS):
            messages.error(self.request, "You do not have permission to create and use LeanMod chats.")
            return redirect('multimodal_chat:lean_chat')
        ##############################

        if ChatPostActionSpecifiers.NEW_CHAT_WITH_ASSISTANT_SPECIFIER in request.POST:
            assistant_id = request.POST.get('assistant_id')
            assistant = get_object_or_404(LeanAssistant, id=assistant_id, organization__users=request.user)
            chat = MultimodalLeanChat.objects.create(
                organization=assistant.organization, lean_assistant=assistant, user=request.user,
                chat_name=request.POST.get('chat_name', generate_chat_name()), created_by_user=request.user,
                chat_source=SourcesForMultimodalChatsNames.APP
            )
            active_chat = chat
        elif ChatPostActionSpecifiers.CHANGE_CHAT_NAME_SPECIFIER in request.POST:
            chat_id = request.POST.get('chat_id')
            chat = get_object_or_404(MultimodalLeanChat, id=chat_id, user=request.user)
            chat.chat_name = request.POST.get('new_chat_name')
            chat.save()
            active_chat = chat
        else:
            chat_id = request.POST.get('chat_id')
            chat = get_object_or_404(MultimodalLeanChat, id=chat_id, user=request.user)
            msg_content = request.POST.get('message_content')
            attached_images = request.FILES.getlist('attached_images[]')
            attached_files = request.FILES.getlist('attached_files[]')

            sketch_image_full_uris_list = self._handle_sketch_image(request)
            edit_image_full_uris_list = self._handle_edit_image(request)
            image_full_uris = self._handle_save_images(attached_images, edit_image_full_uris_list,
                                                       sketch_image_full_uris_list)
            file_full_uris = self._handle_save_files(attached_files)
            self._handle_record_audio(file_full_uris, request)

            MultimodalLeanChatMessage.objects.create(multimodal_lean_chat=chat, sender_type='USER',
                                                     message_text_content=msg_content,
                                                     message_image_contents=image_full_uris,
                                                     message_file_contents=file_full_uris)
            user_msg = MultimodalLeanChatMessage.objects.filter(multimodal_lean_chat=chat).last()
            internal_llm_client_lean = GenerativeAIDecodeController.get_lean(
                user=request.user, assistant=chat.lean_assistant, multimodal_chat=chat)
            response = internal_llm_client_lean.respond(latest_message=user_msg, image_uris=image_full_uris,
                                                        file_uris=file_full_uris)
            MultimodalLeanChatMessage.objects.create(multimodal_lean_chat=chat, sender_type='ASSISTANT',
                                                     message_text_content=response)
            active_chat = chat
        chats = MultimodalLeanChat.objects.filter(user=request.user, chat_source=SourcesForMultimodalChatsNames.APP)
        lean_agents = LeanAssistant.objects.filter(organization__users=request.user)
        context.update({
            "layout_path": TemplateHelper.set_layout("layout_vertical.html", context),
            'chat_id': active_chat.id if active_chat else None, 'chats': chats, 'assistants': lean_agents,
            'active_chat': active_chat})
        redirect_string = self.request.path_info + '?chat_id=' + str(active_chat.id)
        logger.info(f"LeanMod chat was streamed by User: {context_user.id}.")
        return redirect(redirect_string, *args, **kwargs)

    @staticmethod
    def _handle_record_audio(file_full_uris, request):
        record_audio = request.POST.get('record_audio')
        audio_full_uri = None
        if record_audio:
            audio_base_64 = request.POST.get('record_audio')
            audio_bytes = base64.b64decode(audio_base_64.split("base64,")[1].encode())
            audio_full_uri = MediaManager.save_files_and_return_uris([(audio_bytes, 'audio.webm')])[0]
        if audio_full_uri:
            file_full_uris.append(audio_full_uri)
        logger.info(f"Audio was recorded successfully.")
        return

    @staticmethod
    def _handle_save_files(attached_files):
        file_bytes_list = []
        for file in attached_files:
            file_name = file.name
            try:
                file_bytes = file.read()
                logger.info(f"File: {file_name} was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading file: {file_name}.")
                continue
            file_bytes_list.append((file_bytes, file_name))
        file_full_uris = MediaManager.save_files_and_return_uris(file_bytes_list)
        return file_full_uris

    @staticmethod
    def _handle_save_images(attached_images, edit_image_full_uris_list, sketch_image_full_uris_list):
        image_bytes_list = []
        for image in attached_images:
            try:
                image_bytes = image.read()
                logger.info(f"Image: {image.name} was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading image: {image.name}.")
                continue
            image_bytes_list.append(image_bytes)
        image_full_uris = MediaManager.save_images_and_return_uris(image_bytes_list)
        if sketch_image_full_uris_list:
            image_full_uris.extend(sketch_image_full_uris_list)
        if edit_image_full_uris_list:
            image_full_uris.extend(edit_image_full_uris_list)
        return image_full_uris

    @staticmethod
    def _handle_edit_image(request):
        edit_image_bytes_dict = {'edit_image': None, 'edit_image_mask': None}
        attached_edit_image = request.FILES.get('edit_image')
        attached_edit_image_mask = request.POST.get('edit_image_mask')
        edit_image_full_uris_list = []
        try:
            edit_image_bytes = attached_edit_image.read()
            edit_image_mask_bytes = base64.b64decode(attached_edit_image_mask.split("base64,")[1].encode())
            edit_image_bytes_dict['edit_image'] = edit_image_bytes
            edit_image_bytes_dict['edit_image_mask'] = edit_image_mask_bytes
            edit_image_full_uris_list = MediaManager.save_edit_image_and_masked_image(
                edit_img_map=edit_image_bytes_dict)
            logger.info(f"Edit image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving edit image.")
            pass
        return edit_image_full_uris_list

    @staticmethod
    def _handle_sketch_image(request):
        sketch_image = {'sketch_image': None}
        attached_canvas_image = request.POST.get('sketch_image')
        sketch_image_full_uris_list = []
        try:
            sketch_image_bytes = base64.b64decode(attached_canvas_image.split("base64,")[1].encode())
            sketch_image['sketch_image'] = sketch_image_bytes
            sketch_image_full_uris_list = MediaManager.save_sketch(sketch_data_map=sketch_image)
            logger.info(f"Sketch image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving sketch image.")
            pass
        return sketch_image_full_uris_list


Contents of ../../apps/multimodal_chat/views/chat/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

#
from .chat_views import *
from .archive_chat_views import *
from .delete_chat_views import *
from .stream_chat_views import *
from .unarchive_chat_views import *
from .list_archived_chats_views import *


Contents of ../../apps/multimodal_chat/views/chat/delete_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import DeleteView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalChat
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ChatView_ChatDelete(LoginRequiredMixin, DeleteView):
    template_name = 'multimodal_chat/chats/confirm_delete_chat.html'
    success_url = '/chat/'

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        chat = self.get_object()
        context['chat'] = chat
        return context

    def get_queryset(self):
        return MultimodalChat.objects.filter(user=self.request.user, chat_source=SourcesForMultimodalChatsNames.APP)

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - REMOVE_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.REMOVE_CHATS):
            messages.error(self.request, "You do not have permission to remove chats.")
            return redirect('multimodal_chat:chat')
        ##############################

        chat = get_object_or_404(MultimodalChat, id=self.kwargs['pk'], user=self.request.user)
        chat.delete()
        logger.info(f"Chat was deleted by User: {self.request.user.id}.")
        return redirect('multimodal_chat:chat')


Contents of ../../apps/multimodal_chat/views/chat/list_archived_chats_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_archived_chats_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.message_templates.models import MessageTemplate
from apps.multimodal_chat.models import MultimodalChat
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from config.settings import MEDIA_URL
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ChatView_ListArchivedChats(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        active_chat = None
        context_user = self.request.user
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_CHATS
        if not UserPermissionManager.is_authorized(user=context_user,
                                                   operation=PermissionNames.CREATE_AND_USE_CHATS):
            messages.error(self.request, "You do not have permission to create and use chats.")
            return context
        ##############################

        if 'chat_id' in self.request.GET:
            active_chat = get_object_or_404(MultimodalChat, id=self.request.GET['chat_id'], user=self.request.user)

        chats = MultimodalChat.objects.filter(
            user=self.request.user, chat_source=SourcesForMultimodalChatsNames.APP,
            is_archived=True
        )

        if active_chat:
            chats = [active_chat] + [chat for chat in chats if chat.id != active_chat.id]
        else:
            if len(chats) > 0:
                active_chat = chats[0]

        agents = Assistant.objects.filter(organization__users=self.request.user)
        orgs = Organization.objects.filter(assistants__in=agents)
        msg_templates = MessageTemplate.objects.filter(user=context_user, organization__in=orgs)
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        active_chat_msgs = active_chat.chat_messages.all().order_by('sent_at') if active_chat else None
        context.update({"chats": chats, "assistants": agents, "active_chat": active_chat,
                        "chat_messages": active_chat_msgs, "message_templates": msg_templates,
                        "base_url": MEDIA_URL})
        logger.info(f"Archived Chats were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/multimodal_chat/views/chat/chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import base64
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, get_object_or_404
from django.views.generic import TemplateView

from apps.core.media_managers.media_manager_execution_handler import MediaManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.assistants.models import Assistant
from apps.message_templates.models import MessageTemplate
from apps.multimodal_chat.models import MultimodalChat, MultimodalChatMessage
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames, generate_chat_name, ChatPostActionSpecifiers
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from config.settings import MEDIA_URL
from web_project import TemplateLayout, TemplateHelper


logger = logging.getLogger(__name__)

class ChatView_Chat(LoginRequiredMixin, TemplateView):
    @staticmethod
    def refresh_page(chat_id, user_id):
        return redirect(f'/chat/?chat_id={chat_id}')

    def get_context_data(self, **kwargs):
        active_chat = None
        context_user = self.request.user
        if 'chat_id' in self.request.GET:
            active_chat = get_object_or_404(MultimodalChat, id=self.request.GET['chat_id'], user=self.request.user)
        chats = MultimodalChat.objects.filter(
            user=self.request.user, chat_source=SourcesForMultimodalChatsNames.APP, is_archived=False
        )
        if active_chat:
            chats = [active_chat] + [chat for chat in chats if chat.id != active_chat.id]
        else:
            pass

        agents = Assistant.objects.filter(organization__users=self.request.user)
        orgs = Organization.objects.filter(assistants__in=agents)
        msg_tmpls = MessageTemplate.objects.filter(user=context_user, organization__in=orgs)
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        active_chat_msgs = active_chat.chat_messages.all().order_by('sent_at') if active_chat else None
        context.update({
            "chats": chats, "assistants": agents, "active_chat": active_chat, "user": context_user,
            "chat_messages": active_chat_msgs, "message_templates": msg_tmpls, "base_url": MEDIA_URL
        })
        return context

    def post(self, request, *args, **kwargs):
        from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_CHATS
        if not UserPermissionManager.is_authorized(user=context_user,
                                                   operation=PermissionNames.CREATE_AND_USE_CHATS):
            messages.error(self.request, "You do not have permission to create and use chats.")
            return redirect('multimodal_chat:chat')
        ##############################

        if ChatPostActionSpecifiers.NEW_CHAT_WITH_ASSISTANT_SPECIFIER in request.POST:
            agent_id = request.POST.get('assistant_id')
            agent = get_object_or_404(Assistant, id=agent_id, organization__users=request.user)
            chat = MultimodalChat.objects.create(
                organization=agent.organization, assistant=agent, user=request.user,
                chat_name=request.POST.get('chat_name', generate_chat_name()), created_by_user=request.user,
                chat_source=SourcesForMultimodalChatsNames.APP
            )
            active_chat = chat
        elif ChatPostActionSpecifiers.CHANGE_CHAT_NAME_SPECIFIER in request.POST:
            chat_id = request.POST.get('chat_id')
            chat = get_object_or_404(MultimodalChat, id=chat_id, user=request.user)
            chat.chat_name = request.POST.get('new_chat_name')
            chat.save()
            active_chat = chat
            logger.info(f"Chat name was changed by User: {context_user.id}.")
        elif ChatPostActionSpecifiers.STARRING_MESSAGE_SPECIFIER in request.POST:
            chat_id = request.POST.get('chat_id')
            chat = get_object_or_404(MultimodalChat, id=chat_id, user=request.user)
            msg_id = request.POST.get('message_id')
            msg = get_object_or_404(MultimodalChatMessage, id=msg_id, multimodal_chat=chat)
            msg.starred = not msg.starred
            msg.save()
            active_chat = chat
            logger.info(f"Message was starred by User: {context_user.id}.")
        else:
            attached_fs, attached_imgs, chat, msg_content, sketch_image_full_uris_list = (
                self._handle_attached_images(request))
            edit_image_full_uris_list = self._handle_edit_images(request)
            image_full_uris = self._handle_save_images(attached_imgs, edit_image_full_uris_list,
                                                       sketch_image_full_uris_list)
            file_full_uris = self._handle_save_files(attached_fs)
            self._handle_record_audio(file_full_uris, request)

            MultimodalChatMessage.objects.create(
                multimodal_chat=chat, sender_type='USER', message_text_content=msg_content,
                message_image_contents=image_full_uris, message_file_contents=file_full_uris
            )
            user_message = MultimodalChatMessage.objects.filter(multimodal_chat=chat).last()
            internal_llm_client = GenerativeAIDecodeController.get(assistant=chat.assistant, multimodal_chat=chat)
            response = internal_llm_client.respond(latest_message=user_message,
                                                   image_uris=image_full_uris,
                                                   file_uris=file_full_uris)
            MultimodalChatMessage.objects.create(
                multimodal_chat=chat, sender_type='ASSISTANT', message_text_content=response
            )
            active_chat = chat
            logger.info(f"Message was sent by User: {context_user.id}.")

        chats = MultimodalChat.objects.filter(user=request.user, chat_source=SourcesForMultimodalChatsNames.APP)
        agents = Assistant.objects.filter(organization__users=request.user)
        context.update(
            {
                "layout_path": TemplateHelper.set_layout("layout_vertical.html", context),
                'chat_id': active_chat.id if active_chat else None, 'chats': chats, 'assistants': agents,
                'active_chat': active_chat
            }
        )
        redirect_string = self.request.path_info + '?chat_id=' + str(active_chat.id)
        return redirect(redirect_string, *args, **kwargs)

    def _handle_attached_images(self, request):
        chat_id = request.POST.get('chat_id')
        chat = get_object_or_404(MultimodalChat, id=chat_id, user=request.user)
        msg_content = request.POST.get('message_content')
        attached_imgs = request.FILES.getlist('attached_images[]')
        attached_fs = request.FILES.getlist('attached_files[]')
        sketch_image = {'sketch_image': None}
        attached_canvas_image = request.POST.get('sketch_image')
        sketch_image_full_uris_list = []
        try:
            sketch_image_bytes = base64.b64decode(attached_canvas_image.split("base64,")[1].encode())
            sketch_image['sketch_image'] = sketch_image_bytes
            sketch_image_full_uris_list = MediaManager.save_sketch(sketch_data_map=sketch_image)
            logger.info(f"Sketch image was saved by User: {request.user.id}.")
        except Exception as e:
            pass
        return attached_fs, attached_imgs, chat, msg_content, sketch_image_full_uris_list

    @staticmethod
    def _handle_edit_images(request):
        edit_image_bytes_dict = {'edit_image': None, 'edit_image_mask': None}
        attached_edit_image = request.FILES.get('edit_image')
        attached_edit_image_mask = request.POST.get('edit_image_mask')
        edit_image_full_uris_list = []
        try:
            edit_image_bytes = attached_edit_image.read()
            edit_image_mask_bytes = base64.b64decode(attached_edit_image_mask.split("base64,")[1].encode())
            edit_image_bytes_dict['edit_image'] = edit_image_bytes
            edit_image_bytes_dict['edit_image_mask'] = edit_image_mask_bytes
            edit_image_full_uris_list = MediaManager.save_edit_image_and_masked_image(
                edit_img_map=edit_image_bytes_dict)
            logger.info(f"Edit image was saved by User: {request.user.id}.")
        except Exception as e:
            pass
        return edit_image_full_uris_list

    @staticmethod
    def _handle_save_images(attached_imgs, edit_image_full_uris_list, sketch_image_full_uris_list):
        image_bytes_list = []
        for image in attached_imgs:
            try:
                image_bytes = image.read()
                logger.info(f"Image was read.")
            except Exception as e:
                logger.error(f"Error reading image: {e}")
                continue
            image_bytes_list.append(image_bytes)
        image_full_uris = MediaManager.save_images_and_return_uris(image_bytes_list)
        if sketch_image_full_uris_list:
            image_full_uris.extend(sketch_image_full_uris_list)
        if edit_image_full_uris_list:
            image_full_uris.extend(edit_image_full_uris_list)
        return image_full_uris

    @staticmethod
    def _handle_save_files(attached_fs):
        file_bytes_list = []
        for file in attached_fs:
            file_name = file.name
            try:
                file_bytes = file.read()
                logger.info(f"File was read.")
            except Exception as e:
                logger.error(f"Error reading file: {e}")
                continue
            file_bytes_list.append((file_bytes, file_name))
        file_full_uris = MediaManager.save_files_and_return_uris(file_bytes_list)
        return file_full_uris

    @staticmethod
    def _handle_record_audio(file_full_uris, request):
        record_audio = request.POST.get('record_audio')
        audio_full_uri = None
        if record_audio:
            audio_base_64 = request.POST.get('record_audio')
            audio_bytes = base64.b64decode(audio_base_64.split("base64,")[1].encode())
            audio_full_uri = MediaManager.save_files_and_return_uris([(audio_bytes, 'audio.webm')])[0]
        if audio_full_uri:
            file_full_uris.append(audio_full_uri)
        logger.info(f"Audio was saved by User: {request.user.id}.")
        return


Contents of ../../apps/multimodal_chat/views/chat/unarchive_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: unarchive_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalChat
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ChatView_ChatUnarchive(LoginRequiredMixin, TemplateView):

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)

        ##############################
        # PERMISSION CHECK FOR - UNARCHIVE_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.UNARCHIVE_CHATS):
            messages.error(self.request, "You do not have permission to archive chats.")
            return self.render_to_response(context)
        ##############################

        pk = kwargs.get('pk')
        chat = get_object_or_404(MultimodalChat, id=pk, user=self.request.user)
        chat.is_archived = False
        chat.save()
        logger.info(f"Chat was unarchived by User: {self.request.user.id}.")
        return redirect('multimodal_chat:chat')


Contents of ../../apps/multimodal_chat/views/chat/stream_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: stream_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


import base64
import logging

from django.contrib import messages
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
from apps.core.media_managers.media_manager_execution_handler import MediaManager
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalChat, MultimodalChatMessage
from apps.user_permissions.utils import PermissionNames


logger = logging.getLogger(__name__)


class ChatView_ChatStream(View):
    def post(self, request, *args, **kwargs):
        context_user_id = request.POST.get('user_id')
        context_user = get_object_or_404(User, id=context_user_id)

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_CHATS
        if not UserPermissionManager.is_authorized(user=context_user,
                                                   operation=PermissionNames.CREATE_AND_USE_CHATS):
            messages.error(self.request, "You do not have permission to create and use chats.")
            return redirect('multimodal_chat:chat')
        ##############################

        attached_files, attached_images, chat, message_content, sketch_image_full_uris_list = (
            self._handle_sketch_images(request))
        edit_image_full_uris_list = self._handle_edit_images(request)
        image_full_uris = self._handle_save_images(attached_images, edit_image_full_uris_list,
                                                   sketch_image_full_uris_list)
        file_full_uris = self._handle_save_files(attached_files)
        self._handle_record_audio(file_full_uris, request)
        logger.info(f"Chat was streamed by User: {context_user.id}.")

        MultimodalChatMessage.objects.create(
            multimodal_chat=chat, sender_type='USER', message_text_content=message_content,
            message_image_contents=image_full_uris, message_file_contents=file_full_uris
        )
        user_msg = MultimodalChatMessage.objects.filter(multimodal_chat=chat).last()
        int_llm_c = GenerativeAIDecodeController.get(assistant=chat.assistant, multimodal_chat=chat)
        output = int_llm_c.respond_stream(latest_message=user_msg, image_uris=image_full_uris,
                                          file_uris=file_full_uris)
        MultimodalChatMessage.objects.create(
            multimodal_chat=chat, sender_type='ASSISTANT', message_text_content=output)
        logger.info(f"Assistant responded to User: {context_user.id}.")
        return redirect('multimodal_chat:chat')

    @staticmethod
    def _handle_record_audio(file_full_uris, request):
        record_audio = request.POST.get('record_audio')
        audio_full_uri = None
        if record_audio:
            audio_base_64 = request.POST.get('record_audio')
            audio_bytes = base64.b64decode(audio_base_64.split("base64,")[1].encode())
            audio_full_uri = MediaManager.save_files_and_return_uris([(audio_bytes, 'audio.webm')])[0]
        if audio_full_uri:
            file_full_uris.append(audio_full_uri)

    @staticmethod
    def _handle_save_files(attached_files):
        file_bytes_list = []
        for file in attached_files:
            file_name = file.name
            try:
                file_bytes = file.read()
                logger.info(f"File: {file_name} was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading file: {file_name}.")
                continue
            file_bytes_list.append((file_bytes, file_name))
        file_full_uris = MediaManager.save_files_and_return_uris(file_bytes_list)
        return file_full_uris

    @staticmethod
    def _handle_sketch_images(request):
        chat_id = request.POST.get('chat_id')
        chat = get_object_or_404(MultimodalChat, id=chat_id, user=request.user)
        message_content = request.POST.get('message_content')
        attached_images = request.FILES.getlist('attached_images[]')
        attached_files = request.FILES.getlist('attached_files[]')
        sketch_image = {'sketch_image': None}
        attached_canvas_image = request.POST.get('sketch_image')
        sketch_image_full_uris_list = []
        try:
            sketch_image_bytes = base64.b64decode(attached_canvas_image.split("base64,")[1].encode())
            sketch_image['sketch_image'] = sketch_image_bytes
            sketch_image_full_uris_list = MediaManager.save_sketch(sketch_data_map=sketch_image)
            logger.info(f"Sketch image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving sketch image.")
            pass
        return attached_files, attached_images, chat, message_content, sketch_image_full_uris_list

    @staticmethod
    def _handle_save_images(attached_images, edit_image_full_uris_list, sketch_image_full_uris_list):
        image_bytes_list = []
        for image in attached_images:
            try:
                image_bytes = image.read()
                logger.info(f"Image: {image.name} was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading image: {image.name}.")
                continue
            image_bytes_list.append(image_bytes)
        image_full_uris = MediaManager.save_images_and_return_uris(image_bytes_list)
        if sketch_image_full_uris_list:
            image_full_uris.extend(sketch_image_full_uris_list)
        if edit_image_full_uris_list:
            image_full_uris.extend(edit_image_full_uris_list)
        return image_full_uris

    @staticmethod
    def _handle_edit_images(request):
        edit_image_bytes_dict = {'edit_image': None, 'edit_image_mask': None}
        attached_edit_image = request.FILES.get('edit_image')
        attached_edit_image_mask = request.POST.get('edit_image_mask')
        edit_image_full_uris_list = []
        try:
            edit_image_bytes = attached_edit_image.read()
            edit_image_mask_bytes = base64.b64decode(attached_edit_image_mask.split("base64,")[1].encode())
            edit_image_bytes_dict['edit_image'] = edit_image_bytes
            edit_image_bytes_dict['edit_image_mask'] = edit_image_mask_bytes
            edit_image_full_uris_list = MediaManager.save_edit_image_and_masked_image(
                edit_img_map=edit_image_bytes_dict)
            logger.info(f"Edit image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving edit image.")
            pass
        return edit_image_full_uris_list


Contents of ../../apps/multimodal_chat/views/chat/archive_chat_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: archive_chat_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.multimodal_chat.models import MultimodalChat
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ChatView_ChatArchive(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        return context

    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)

        ##############################
        # PERMISSION CHECK FOR - ARCHIVE_CHATS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ARCHIVE_CHATS):
            messages.error(self.request, "You do not have permission to archive chats.")
            return self.render_to_response(context)
        ##############################

        pk = kwargs.get('pk')
        chat = get_object_or_404(MultimodalChat, id=pk, user=self.request.user)
        chat.is_archived = True
        chat.save()
        logger.info(f"Chat was archived by User: {self.request.user.id}.")
        return redirect('multimodal_chat:chat')


Contents of ../../apps/multimodal_chat/views/workspace/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-11-12 22:59:40
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-12 22:59:41
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#


from .main_workspace_views import *
from .main_workspace_stream_views import *


Contents of ../../apps/multimodal_chat/views/workspace/main_workspace_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: main_workspace_views.py
#  Last Modified: 2024-11-12 23:00:13
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-12 23:00:13
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import base64
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.media_managers.media_manager_execution_handler import MediaManager
from apps.core.tool_calls.utils import VoidForgerModesNames
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.message_templates.models import MessageTemplate
from apps.multimodal_chat.utils import SourcesForMultimodalChatsNames, ChatPostActionSpecifiers, generate_chat_name
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import MultimodalVoidForgerChat, MultimodalVoidForgerChatMessage, VoidForger
from config.settings import MEDIA_URL
from web_project import TemplateLayout, TemplateHelper

logger = logging.getLogger(__name__)


class ChatView_MainWorkspace(TemplateView, LoginRequiredMixin):

    @staticmethod
    def refresh_page(chat_id, user_id):
        return redirect(f'/workspace/?chat_id={chat_id}')

    def get_context_data(self, **kwargs):
        _, _ = VoidForger.objects.get_or_create(user=self.request.user)
        active_chat = None
        context_user = self.request.user
        if 'chat_id' in self.request.GET:
            active_chat = get_object_or_404(MultimodalVoidForgerChat, id=self.request.GET['chat_id'],
                                            user=self.request.user)
        chats = MultimodalVoidForgerChat.objects.filter(
            user=self.request.user, chat_source=SourcesForMultimodalChatsNames.APP)
        if active_chat:
            chats = [active_chat] + [chat for chat in chats if chat.id != active_chat.id]
        else:
            pass

        orgs = Organization.objects.filter(users__in=[context_user])
        msg_templates = MessageTemplate.objects.filter(user=context_user, organization__in=orgs)
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        active_chat_msgs = active_chat.voidforger_chat_messages.all().order_by('sent_at') if active_chat else None
        context.update({
            "layout": "blank",
            "layout_path": TemplateHelper.set_layout("layout_blank.html", context),
            "chats": chats, "active_chat": active_chat, "user": context_user,
            "chat_messages": active_chat_msgs, "message_templates": msg_templates, "base_url": MEDIA_URL,
        })
        return context

    def post(self, request, *args, **kwargs):
        from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_VOIDFORGER_CHATS
        if not UserPermissionManager.is_authorized(user=context_user,
                                                   operation=PermissionNames.CREATE_AND_USE_VOIDFORGER_CHATS):
            messages.error(self.request, "You do not have permission to create and use VoidForger chats.")
            return redirect('multimodal_chat:main_workspace')
        ##############################

        if ChatPostActionSpecifiers.NEW_CHAT_WITH_ASSISTANT_SPECIFIER in request.POST:
            voidforger = get_object_or_404(VoidForger, user=request.user)
            chat = MultimodalVoidForgerChat.objects.create(
                voidforger=voidforger, user=request.user,
                chat_name=request.POST.get('chat_name', generate_chat_name()),
                created_by_user=request.user,
                chat_source=SourcesForMultimodalChatsNames.APP
            )
            active_chat = chat
        elif ChatPostActionSpecifiers.CHANGE_CHAT_NAME_SPECIFIER in request.POST:
            chat_id = request.POST.get('chat_id')
            chat = get_object_or_404(MultimodalVoidForgerChat, id=chat_id, user=request.user)
            chat.chat_name = request.POST.get('new_chat_name')
            chat.save()
            active_chat = chat
        else:
            chat_id = request.POST.get('chat_id')
            chat = get_object_or_404(MultimodalVoidForgerChat, id=chat_id, user=request.user)
            msg_content = request.POST.get('message_content')
            attached_images = request.FILES.getlist('attached_images[]')
            attached_files = request.FILES.getlist('attached_files[]')

            sketch_image_full_uris_list = self._handle_sketch_image(request)
            edit_image_full_uris_list = self._handle_edit_image(request)
            image_full_uris = self._handle_save_images(attached_images, edit_image_full_uris_list,
                                                       sketch_image_full_uris_list)
            file_full_uris = self._handle_save_files(attached_files)
            self._handle_record_audio(file_full_uris, request)

            MultimodalVoidForgerChatMessage.objects.create(
                multimodal_voidforger_chat=chat,
                sender_type='USER',
                message_text_content=msg_content,
                message_image_contents=image_full_uris,
                message_file_contents=file_full_uris
            )
            user_msg = MultimodalVoidForgerChatMessage.objects.filter(
                multimodal_voidforger_chat=chat
            ).last()

            internal_llm_client_voidforger = GenerativeAIDecodeController.get_voidforger(
                user=request.user,
                assistant=chat.voidforger,
                multimodal_chat=chat
            )
            response = internal_llm_client_voidforger.respond(
                latest_message=user_msg,
                current_mode=VoidForgerModesNames.CHAT,
                image_uris=image_full_uris,
                file_uris=file_full_uris
            )
            MultimodalVoidForgerChatMessage.objects.create(
                multimodal_voidforger_chat=chat,
                sender_type='ASSISTANT',
                message_text_content=response

            )
            active_chat = chat

        chats = MultimodalVoidForgerChat.objects.filter(
            user=request.user,
            chat_source=SourcesForMultimodalChatsNames.APP
        )

        context.update({
            "layout_path": TemplateHelper.set_layout("layout_vertical.html", context),
            'chat_id': active_chat.id if active_chat else None, 'chats': chats,
            'active_chat': active_chat
        })

        redirect_string = self.request.path_info + '?chat_id=' + str(active_chat.id)
        logger.info(f"VoidForger chat was streamed by User: {context_user.id}.")
        return redirect(redirect_string, *args, **kwargs)

    @staticmethod
    def _handle_record_audio(file_full_uris, request):
        record_audio = request.POST.get('record_audio')
        audio_full_uri = None
        if record_audio:
            audio_base_64 = request.POST.get('record_audio')
            audio_bytes = base64.b64decode(audio_base_64.split("base64,")[1].encode())
            audio_full_uri = MediaManager.save_files_and_return_uris([(audio_bytes, 'audio.webm')])[0]
        if audio_full_uri:
            file_full_uris.append(audio_full_uri)
        logger.info(f"Audio was recorded successfully.")
        return

    @staticmethod
    def _handle_save_files(attached_files):
        file_bytes_list = []
        for file in attached_files:
            file_name = file.name
            try:
                file_bytes = file.read()
                logger.info(f"File: {file_name} was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading file: {file_name}.")
                continue
            file_bytes_list.append((file_bytes, file_name))
        file_full_uris = MediaManager.save_files_and_return_uris(file_bytes_list)
        return file_full_uris

    @staticmethod
    def _handle_save_images(attached_images, edit_image_full_uris_list, sketch_image_full_uris_list):
        image_bytes_list = []
        for image in attached_images:
            try:
                image_bytes = image.read()
                logger.info(f"Image: {image.name} was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading image: {image.name}.")
                continue
            image_bytes_list.append(image_bytes)
        image_full_uris = MediaManager.save_images_and_return_uris(image_bytes_list)
        if sketch_image_full_uris_list:
            image_full_uris.extend(sketch_image_full_uris_list)
        if edit_image_full_uris_list:
            image_full_uris.extend(edit_image_full_uris_list)
        return image_full_uris

    @staticmethod
    def _handle_edit_image(request):
        edit_image_bytes_dict = {'edit_image': None, 'edit_image_mask': None}
        attached_edit_image = request.FILES.get('edit_image')
        attached_edit_image_mask = request.POST.get('edit_image_mask')
        edit_image_full_uris_list = []
        try:
            edit_image_bytes = attached_edit_image.read()
            edit_image_mask_bytes = base64.b64decode(attached_edit_image_mask.split("base64,")[1].encode())
            edit_image_bytes_dict['edit_image'] = edit_image_bytes
            edit_image_bytes_dict['edit_image_mask'] = edit_image_mask_bytes
            edit_image_full_uris_list = MediaManager.save_edit_image_and_masked_image(
                edit_img_map=edit_image_bytes_dict)
            logger.info(f"Edit image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving edit image.")
            pass
        return edit_image_full_uris_list

    @staticmethod
    def _handle_sketch_image(request):
        sketch_image = {'sketch_image': None}
        attached_canvas_image = request.POST.get('sketch_image')
        sketch_image_full_uris_list = []
        try:
            sketch_image_bytes = base64.b64decode(attached_canvas_image.split("base64,")[1].encode())
            sketch_image['sketch_image'] = sketch_image_bytes
            sketch_image_full_uris_list = MediaManager.save_sketch(sketch_data_map=sketch_image)
            logger.info(f"Sketch image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving sketch image.")
            pass
        return sketch_image_full_uris_list


Contents of ../../apps/multimodal_chat/views/workspace/main_workspace_stream_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: main_workspace_stream_views.py
#  Last Modified: 2024-11-16 05:07:08
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-16 05:07:09
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import base64
import logging

from django.contrib import messages
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404, redirect
from django.views import View

from apps.core.generative_ai.generative_ai_decode_manager import GenerativeAIDecodeController
from apps.core.media_managers.media_manager_execution_handler import MediaManager
from apps.core.tool_calls.utils import VoidForgerModesNames
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.user_permissions.utils import PermissionNames
from apps.voidforger.models import MultimodalVoidForgerChat, MultimodalVoidForgerChatMessage

logger = logging.getLogger(__name__)


class ChatView_MainWorkspaceStream(View):

    def post(self, request, *args, **kwargs):
        context_user_id = request.POST.get('user_id')
        context_user = get_object_or_404(User, id=context_user_id)

        ##############################
        # PERMISSION CHECK FOR - CREATE_AND_USE_VOIDFORGER_CHATS
        if not UserPermissionManager.is_authorized(user=context_user,
                                                   operation=PermissionNames.CREATE_AND_USE_VOIDFORGER_CHATS):
            messages.error(self.request, "You do not have permission to create and use VoidForger chats.")
            return redirect('multimodal_chat:main_workspace')
        ##############################

        chat_id = request.POST.get('chat_id')
        chat: MultimodalVoidForgerChat = get_object_or_404(MultimodalVoidForgerChat, id=chat_id, user=request.user)
        msg_content = request.POST.get('message_content')
        attached_images = request.FILES.getlist('attached_images[]')
        attached_files = request.FILES.getlist('attached_files[]')
        sketch_image_full_uris_list = self._handle_sketch_image(request)
        edit_image_full_uris_list = self._handle_edit_image(request)
        image_full_uris = self._handle_save_images(attached_images, edit_image_full_uris_list,
                                                   sketch_image_full_uris_list)
        file_full_uris = self._handle_save_files(attached_files)
        self._handle_record_audio(file_full_uris, request)

        try:
            MultimodalVoidForgerChatMessage.objects.create(
                multimodal_voidforger_chat=chat, sender_type='USER', message_text_content=msg_content,
                message_image_contents=image_full_uris, message_file_contents=file_full_uris
            )
            logger.info(f"User message was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving User message.")
            messages.error(self.request, "Error while saving User message: " + str(e))
            return redirect('multimodal_chat:main_workspace')

        try:
            user_msg = MultimodalVoidForgerChatMessage.objects.filter(multimodal_voidforger_chat=chat).last()
            internal_llm_client_voidforger = GenerativeAIDecodeController.get_voidforger(
                user=request.user, assistant=chat.voidforger, multimodal_chat=chat)
            final_response = internal_llm_client_voidforger.respond_stream(latest_message=user_msg,
                                                                           current_mode=VoidForgerModesNames.CHAT,
                                                                           image_uris=image_full_uris,
                                                                           file_uris=file_full_uris)
        except Exception as e:
            logger.error(f"Error while responding to User: {context_user.id}.")
            messages.error(self.request, "Error while responding: " + str(e))
            return redirect('multimodal_chat:main_workspace')

        MultimodalVoidForgerChatMessage.objects.create(
            multimodal_voidforger_chat=chat, sender_type='ASSISTANT', message_text_content=final_response)
        logger.info(f"VoidForger responded to User: {context_user.id}.")
        return redirect('multimodal_chat:main_workspace')

    @staticmethod
    def _handle_record_audio(file_full_uris, request):
        record_audio = request.POST.get('record_audio')
        audio_full_uri = None
        if record_audio:
            audio_base_64 = request.POST.get('record_audio')
            audio_bytes = base64.b64decode(audio_base_64.split("base64,")[1].encode())
            audio_full_uri = MediaManager.save_files_and_return_uris([(audio_bytes, 'audio.webm')])[0]
        if audio_full_uri:
            file_full_uris.append(audio_full_uri)
        logger.info(f"Audio was saved successfully.")
        return

    @staticmethod
    def _handle_save_files(attached_files):
        file_bytes_list = []
        for file in attached_files:
            file_name = file.name
            try:
                file_bytes = file.read()
                logger.info(f"File was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading file.")
                continue
            file_bytes_list.append((file_bytes, file_name))
        file_full_uris = MediaManager.save_files_and_return_uris(file_bytes_list)
        return file_full_uris

    @staticmethod
    def _handle_save_images(attached_images, edit_image_full_uris_list, sketch_image_full_uris_list):
        image_bytes_list = []
        for image in attached_images:
            try:
                image_bytes = image.read()
                logger.info(f"Image was read successfully.")
            except Exception as e:
                logger.error(f"Error while reading image.")
                continue
            image_bytes_list.append(image_bytes)
        image_full_uris = MediaManager.save_images_and_return_uris(image_bytes_list)
        if sketch_image_full_uris_list:
            image_full_uris.extend(sketch_image_full_uris_list)
        if edit_image_full_uris_list:
            image_full_uris.extend(edit_image_full_uris_list)
        return image_full_uris

    @staticmethod
    def _handle_edit_image(request):
        edit_image_bytes_dict = {'edit_image': None, 'edit_image_mask': None}
        attached_edit_image = request.FILES.get('edit_image')
        attached_edit_image_mask = request.POST.get('edit_image_mask')
        edit_image_full_uris_list = []
        try:
            edit_image_bytes = attached_edit_image.read()
            edit_image_mask_bytes = base64.b64decode(attached_edit_image_mask.split("base64,")[1].encode())
            edit_image_bytes_dict['edit_image'] = edit_image_bytes
            edit_image_bytes_dict['edit_image_mask'] = edit_image_mask_bytes
            edit_image_full_uris_list = MediaManager.save_edit_image_and_masked_image(
                edit_img_map=edit_image_bytes_dict)
            logger.info(f"Edit image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving edit image.")
            pass
        return edit_image_full_uris_list

    @staticmethod
    def _handle_sketch_image(request):
        sketch_image = {'sketch_image': None}
        attached_canvas_image = request.POST.get('sketch_image')
        sketch_image_full_uris_list = []
        try:
            sketch_image_bytes = base64.b64decode(attached_canvas_image.split("base64,")[1].encode())
            sketch_image['sketch_image'] = sketch_image_bytes
            sketch_image_full_uris_list = MediaManager.save_sketch(sketch_data_map=sketch_image)
            logger.info(f"Sketch image was saved successfully.")
        except Exception as e:
            logger.error(f"Error while saving sketch image.")
            pass
        return sketch_image_full_uris_list


Contents of ../../apps/multimodal_chat/views/multimodality/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

#
from .narrate_chat_message_views import *


Contents of ../../apps/multimodal_chat/views/multimodality/narrate_chat_message_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: narrate_chat_message_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import JsonResponse
from django.shortcuts import get_object_or_404
from django.views import View

from apps.core.generative_ai.auxiliary_clients.auxiliary_llm_audio_client import AuxiliaryLLMAudioClient
from apps.multimodal_chat.models import MultimodalChatMessage, MultimodalLeanChatMessage
from apps.voidforger.models import MultimodalVoidForgerChatMessage

logger = logging.getLogger(__name__)


class Chat_MessageNarration(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        msg_id = kwargs.get('pk')
        try:
            msg = get_object_or_404(MultimodalChatMessage, id=msg_id, multimodal_chat__user=request.user)
        except Exception as e:
            logger.error(f"Assistant chat message not found. Error: {e}")
            return JsonResponse({'audio_url': None})
        try:
            if msg.message_audio:
                logger.info(f"Assistant chat message audio found. Returning audio URL.")
                return JsonResponse({'audio_url': msg.message_audio})
        except Exception as e:
            logger.error(f"Assistant chat message audio not found. Error: {e}")
            pass
        try:
            output = (
                AuxiliaryLLMAudioClient(
                    assistant=msg.multimodal_chat.assistant,
                    chat_object=msg.multimodal_chat).tts_audio_content_message(message=msg)
            )
        except Exception as e:
            logger.error(f"Assistant chat message audio generation failed. Error: {e}")
            return JsonResponse({'audio_url': None})
        try:
            msg.message_audio = output['audio_url']
            msg.save()
            logger.info(f"Assistant chat message audio generated and saved.")
        except Exception as e:
            logger.error(f"Assistant chat message audio saving failed. Error: {e}")
            pass
        logger.info(f"Assistant chat message audio generated. Returning audio URL.")
        return JsonResponse({'audio_url': output['audio_url']})




class LeanChat_MessageNarration(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        msg_id = kwargs.get('pk')
        try:
            msg = get_object_or_404(MultimodalLeanChatMessage, id=msg_id, multimodal_lean_chat__user=request.user)
        except Exception as e:
            logger.error(f"LeanMod chat message not found. Error: {e}")
            return JsonResponse({'audio_url': None})
        try:
            if msg.message_audio:
                logger.info(f"LeanMod chat message audio found. Returning audio URL.")
                return JsonResponse({'audio_url': msg.message_audio})
        except Exception as e:
            logger.error(f"LeanMod chat message audio not found. Error: {e}")
            pass
        try:
            output = (
                AuxiliaryLLMAudioClient(
                    assistant=msg.multimodal_lean_chat.lean_assistant,
                    chat_object=msg.multimodal_lean_chat).tts_audio_content_message(message=msg)
            )
        except Exception as e:
            logger.error(f"LeanMod chat message audio generation failed. Error: {e}")
            return JsonResponse({'audio_url': None})
        try:
            msg.message_audio = output['audio_url']
            msg.save()
            logger.info(f"LeanMod chat message audio generated and saved.")
        except Exception as e:
            logger.error(f"LeanMod chat message audio saving failed. Error: {e}")
            pass
        logger.info(f"LeanMod chat message audio generated. Returning audio URL.")
        return JsonResponse({'audio_url': output['audio_url']})


class VoidForgerChat_MessageNarration(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        msg_id = kwargs.get('pk')
        try:
            msg = get_object_or_404(MultimodalVoidForgerChatMessage, id=msg_id, multimodal_voidforger_chat__user=request.user)
        except Exception as e:
            logger.error(f"VoidForger chat message not found. Error: {e}")
            return JsonResponse({'audio_url': None})
        try:
            if msg.message_audio:
                logger.info(f"VoidForger chat message audio found. Returning audio URL.")
                return JsonResponse({'audio_url': msg.message_audio})
        except Exception as e:
            logger.error(f"VoidForger chat message audio not found. Error: {e}")
            pass
        try:
            output = (
                AuxiliaryLLMAudioClient(
                    assistant=msg.multimodal_voidforger_chat.voidforger,
                    chat_object=msg.multimodal_voidforger_chat).tts_audio_content_message(message=msg)
            )
        except Exception as e:
            logger.error(f"VoidForger chat message audio generation failed. Error: {e}")
            return JsonResponse({'audio_url': None})
        try:
            msg.message_audio = output['audio_url']
            msg.save()
            logger.info(f"VoidForger chat message audio generated and saved.")
        except Exception as e:
            logger.error(f"VoidForger chat message audio saving failed. Error: {e}")
            pass
        logger.info(f"VoidForger chat message audio generated. Returning audio URL.")
        return JsonResponse({'audio_url': output['audio_url']})


Contents of ../../apps/llm_transaction/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .invoice import *
from .auto_topup import *
from .llm_transaction import *
from .manual_topup import *
from .transfer_balance import *


Contents of ../../apps/llm_transaction/views/auto_topup/update_auto_topup_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: update_auto_topup_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.utils import timezone
from django.views.generic import TemplateView

from apps.llm_transaction.models import AutoBalanceTopUpModel
from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class Transactions_AutoTopUp_Update(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        user = self.request.user
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        p = get_object_or_404(AutoBalanceTopUpModel, id=kwargs.get('plan_id'))
        context.update({'plan': p, 'organizations': Organization.objects.filter(users__in=[user])})
        return context

    def post(self, request, plan_id):

        try:
            p = get_object_or_404(AutoBalanceTopUpModel, id=plan_id)
            p.on_balance_threshold_trigger = request.POST.get('on_balance_threshold_trigger') == 'on' or False
            p.on_interval_by_days_trigger = request.POST.get('on_interval_by_days_trigger') == 'on' or False
            p.balance_lower_trigger_threshold_value = request.POST.get('balance_lower_trigger_threshold_value') or None
            p.addition_on_balance_threshold_trigger = request.POST.get('addition_on_balance_threshold_trigger') or None
            p.regular_by_days_interval = request.POST.get('regular_by_days_interval') or None
            p.addition_on_interval_by_days_trigger = request.POST.get('addition_on_interval_by_days_trigger') or None
            p.monthly_hard_limit_auto_addition_amount = request.POST.get(
                'monthly_hard_limit_auto_addition_amount') or 100_000
            p.date_of_last_auto_top_up = timezone.now()
            p.save()
        except Exception as e:
            logger.error(f"Error updating Auto Top Up: {e}")
            return redirect('llm_transaction:auto_top_up_list')

        logger.info(f"Auto Top Up was updated by User: {self.request.user.id}.")
        return redirect('llm_transaction:auto_top_up_list')


Contents of ../../apps/llm_transaction/views/auto_topup/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_auto_topups_views import *
from .create_auto_topup_views import *
from .update_auto_topup_views import *


Contents of ../../apps/llm_transaction/views/auto_topup/create_auto_topup_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_auto_topup_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.utils import timezone
from django.views.generic import TemplateView

from apps.llm_transaction.models import AutoBalanceTopUpModel
from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class Transactions_AutoTopUpCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        return context

    def post(self, request, *args, **kwargs):
        org_id = request.POST.get('organization_id')
        on_balance_threshold_trigger = request.POST.get('on_balance_threshold_trigger')
        on_interval_by_days_trigger = request.POST.get('on_interval_by_days_trigger')
        if on_balance_threshold_trigger == 'on':
            on_balance_threshold_trigger = True
        else:
            on_balance_threshold_trigger = False
        if on_interval_by_days_trigger == 'on':
            on_interval_by_days_trigger = True
        else:
            on_interval_by_days_trigger = False

        balance_lower_trigger_threshold_value = None
        addition_on_balance_threshold_trigger = None
        if on_balance_threshold_trigger:
            balance_lower_trigger_threshold_value = request.POST.get('balance_lower_trigger_threshold_value')
            addition_on_balance_threshold_trigger = request.POST.get('addition_on_balance_threshold_trigger')

        regular_by_days_interval = None
        addition_on_interval_by_days_trigger = None
        date_of_last_auto_top_up = None
        if on_interval_by_days_trigger:
            regular_by_days_interval = request.POST.get('regular_by_days_interval')
            addition_on_interval_by_days_trigger = request.POST.get('addition_on_interval_by_days_trigger')
            date_of_last_auto_top_up = timezone.now()

        monthly_hard_limit_auto_addition_amount = request.POST.get('monthly_hard_limit_auto_addition_amount', 100_000)
        if monthly_hard_limit_auto_addition_amount == '':
            monthly_hard_limit_auto_addition_amount = 100_000

        org = Organization.objects.get(id=org_id)
        if org.auto_balance_topup:
            org.auto_balance_topup.delete()

        try:
            top_up_model = AutoBalanceTopUpModel.objects.create(
                organization=org, on_balance_threshold_trigger=on_balance_threshold_trigger,
                on_interval_by_days_trigger=on_interval_by_days_trigger,
                balance_lower_trigger_threshold_value=balance_lower_trigger_threshold_value,
                addition_on_balance_threshold_trigger=round(float(addition_on_balance_threshold_trigger),
                                                            2) if addition_on_balance_threshold_trigger else None,
                regular_by_days_interval=regular_by_days_interval,
                addition_on_interval_by_days_trigger=round(float(addition_on_interval_by_days_trigger),
                                                           2) if addition_on_interval_by_days_trigger else None,
                date_of_last_auto_top_up=date_of_last_auto_top_up, calendar_month_total_auto_addition_value=0,
                monthly_hard_limit_auto_addition_amount=monthly_hard_limit_auto_addition_amount
            )
            top_up_model.save()
            org.auto_balance_topup = top_up_model
            org.save()
        except Exception as e:
            logger.error(f"Error creating Auto Top Up Plan: {e}")
            return redirect('llm_transaction:auto_top_up_list')

        logger.info(f"Auto Top Up Plan created for organization: {org.id}")
        return redirect('llm_transaction:auto_top_up_list')


Contents of ../../apps/llm_transaction/views/auto_topup/list_auto_topups_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_auto_topups_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class Transactions_AutoTopUpList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['organizations'] = Organization.objects.filter(users__in=[self.request.user])
        return context

    def post(self, request, *args, **kwargs):
        organization_id = request.POST.get('organization_id')
        organization = Organization.objects.get(id=organization_id)

        try:
            if 'delete' in request.POST:
                organization.auto_balance_topup.delete()
                organization.auto_balance_topup = None
                organization.save()
        except Exception as e:
            logger.error(f"Error deleting Auto Top Up: {e}")
            return redirect('llm_transaction:auto_top_up_list')

        logger.info(f"Auto Top Up was deleted by User: {self.request.user.id}.")
        return redirect('llm_transaction:auto_top_up_list')


Contents of ../../apps/llm_transaction/views/manual_topup/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .create_manual_topup_views import *


Contents of ../../apps/llm_transaction/views/manual_topup/create_manual_topup_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_manual_topup_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class Transactions_ManualTopUpCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        try:
            selected_org = Organization.objects.filter(users__in=[self.request.user]).first()
            context['selected_organization'] = selected_org
            orgs = Organization.objects.filter(users__in=[self.request.user]).all()
            context['organizations'] = orgs
        except Exception as e:
            logger.error(f"Error getting context data for Manual Top Up: {e}")
            return context

        logger.info(f"Manual Top Up was created by User: {self.request.user.id}.")
        return context


Contents of ../../apps/llm_transaction/views/transfer_balance/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

#
from .transfer_balance_views import *


Contents of ../../apps/llm_transaction/views/transfer_balance/transfer_balance_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: transfer_balance_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class Transactions_BalanceTransfer(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        try:
            orgs = Organization.objects.filter(users__in=[self.request.user]).all()
            context['organizations'] = orgs
        except Exception as e:
            logger.error(f"Error getting context data for Balance Transfer: {e}")
            return context

        logger.info(f"Balance Transfer was initiated by User: {self.request.user.id}.")
        return context


Contents of ../../apps/llm_transaction/views/llm_transaction/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_transactions_views import *


Contents of ../../apps/llm_transaction/views/llm_transaction/list_transactions_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_transactions_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.utils import timezone
from django.views.generic import TemplateView
from datetime import timedelta

from apps.llm_transaction.models import LLMTransaction
from apps.llm_transaction.utils import INTERNAL_TIME_FILTER_TYPES, sum_costs, TXS_PAGINATION_ITEMS_PER_PAGE, \
    MAXIMUM_PAGES_POSSIBLE_TO_SHOW
from apps.organization.models import Organization
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class Transactions_TransactionList(TemplateView, LoginRequiredMixin):
    def post(self, request, *args, **kwargs):
        filter_value = request.POST.get('filter')
        delta_specifier = request.POST.get('delta_specifier', "30")
        time_specifier = request.POST.get('time_specifier', 'days')
        context = self.get_context_data(filter_value=filter_value, **kwargs)
        context['filter'] = filter_value
        context['filter_types'] = INTERNAL_TIME_FILTER_TYPES
        context['delta_specifier'] = delta_specifier
        context['time_specifier'] = time_specifier
        logger.info(f"User {self.request.user} fetched transaction list.")
        return self.render_to_response(context)

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context_user = self.request.user
        orgs = Organization.objects.filter(users__in=[context_user])
        filter_value = self.request.POST.get('filter', 'specific')
        delta = self.request.POST.get('delta_specifier', "30")
        time_spec = self.request.POST.get('time_specifier', 'days')
        filter_date = self.get_filter_date(filter_value, delta, time_spec)

        data = []
        for org in orgs:
            llms = org.llm_cores.all()
            org_data = {'organization': org, 'llm_models': [],
                        'cost_sums': sum_costs(LLMTransaction.objects.defer("transaction_context_content").filter(
                            organization=org, created_at__gte=filter_date))}
            for model in llms:
                txs = LLMTransaction.objects.filter(
                    organization=org,
                    model=model,
                    created_at__gte=filter_date)[:(TXS_PAGINATION_ITEMS_PER_PAGE * MAXIMUM_PAGES_POSSIBLE_TO_SHOW)]
                paginator = Paginator(txs, TXS_PAGINATION_ITEMS_PER_PAGE)
                page_number = self.request.GET.get('page')
                page_obj = paginator.get_page(page_number)
                llm_data = {'model': model, 'transactions': page_obj,
                            'cost_sums': sum_costs(LLMTransaction.objects.filter(
                                organization=org, model=model, created_at__gte=filter_date))}
                org_data['llm_models'].append(llm_data)
            data.append(org_data)

        context['data'] = data
        context['user'] = context_user
        context["cost_sums"] = sum_costs(
            LLMTransaction.objects.filter(organization__in=orgs, created_at__gte=filter_date))
        context['filter_types'] = INTERNAL_TIME_FILTER_TYPES
        context['filter'] = filter_value
        context['delta_specifier'] = delta
        context['time_specifier'] = time_spec
        context['user_organizations'] = orgs
        return context

    def get_filter_date(self, filter_value, delta_specifier, time_specifier):
        now = timezone.now()
        if filter_value == 'all':
            return now - timedelta(hours=100_000)
        else:
            delta = int(delta_specifier.lower().strip())
            time_specifier = time_specifier.lower().strip()
            if time_specifier == 'seconds':
                return now - timedelta(seconds=delta)
            elif time_specifier == 'minutes':
                return now - timedelta(minutes=delta)
            elif time_specifier == 'hours':
                return now - timedelta(hours=delta)
            elif time_specifier == 'days':
                return now - timedelta(days=delta)
            elif time_specifier == 'weeks':
                return now - timedelta(weeks=delta)
            elif time_specifier == 'months':
                return now - timedelta(days=30 * delta)
            elif time_specifier == 'years':
                return now - timedelta(days=365 * delta)
            else:
                raise ValueError('Invalid time specifier: {}'.format(time_specifier))


Contents of ../../apps/llm_transaction/views/invoice/list_invoices_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_invoices_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.views.generic import TemplateView

from apps.llm_transaction.models import TransactionInvoice
from apps.organization.models import Organization
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class Transactions_InvoiceList(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        orgs = Organization.objects.filter(users__in=[self.request.user]).all()
        invoices = TransactionInvoice.objects.filter(organization__in=orgs).select_related(
            'organization', 'responsible_user').order_by('-transaction_date')

        paginator = Paginator(invoices, 10)
        page = self.request.GET.get('page')
        paginated_invoices = paginator.get_page(page)
        context['invoices'] = paginated_invoices
        context['organizations'] = orgs
        logger.info(f"Invoices were listed by User: {self.request.user.id}.")
        return context


Contents of ../../apps/llm_transaction/views/invoice/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:43
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_invoices_views import *


Contents of ../../apps/mm_scheduled_jobs/views/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .scheduled_job import *
from .log import *


Contents of ../../apps/mm_scheduled_jobs/views/scheduled_job/delete_orchestration_scheduled_jobs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_orchestration_scheduled_jobs_views.py
#  Last Modified: 2024-11-14 06:15:54
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 06:15:54
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.models import OrchestrationScheduledJob
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ScheduledJobView_OrchestrationDelete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        scheduled_job_id = self.kwargs.get('pk')
        scheduled_job = get_object_or_404(OrchestrationScheduledJob, id=scheduled_job_id)
        context['scheduled_job'] = scheduled_job
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_ORCHESTRATION_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_ORCHESTRATION_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to delete Orchestration scheduled jobs.")
            return redirect('mm_scheduled_jobs:orchestration_list')
        ##############################

        scheduled_job_id = self.kwargs.get('pk')
        scheduled_job = get_object_or_404(OrchestrationScheduledJob, id=scheduled_job_id)

        try:
            scheduled_job.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the Orchestration Scheduled Job: " + str(e))
            return redirect("mm_scheduled_jobs:orchestration_list")

        logger.info(f"Orchestration Scheduled Job was deleted by User: {self.request.user.id}.")
        messages.success(request, "Orchestration Scheduled Job deleted successfully.")
        return redirect('mm_scheduled_jobs:orchestration_list')


Contents of ../../apps/mm_scheduled_jobs/views/scheduled_job/list_scheduled_jobs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_scheduled_jobs_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.models import ScheduledJob
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ScheduledJobView_List(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to list scheduled jobs.")
            return context
        ##############################

        search_query = self.request.GET.get('search', '')
        user_orgs = self.request.user.organizations.all()
        org_agents = user_orgs.values_list('assistants', flat=True)
        scheduled_jobs_list = ScheduledJob.objects.filter(assistant__in=org_agents)
        if search_query:
            scheduled_jobs_list = scheduled_jobs_list.filter(
                Q(name__icontains=search_query) | Q(task_description__icontains=search_query))
        paginator = Paginator(scheduled_jobs_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['scheduled_jobs'] = page_obj.object_list
        context['total_scheduled_jobs'] = ScheduledJob.objects.count()
        context['search_query'] = search_query
        logger.info(f"Scheduled Jobs list was fetched by User: {self.request.user.id}.")
        return context


Contents of ../../apps/mm_scheduled_jobs/views/scheduled_job/list_orchestration_scheduled_jobs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_orchestration_scheduled_jobs_views.py
#  Last Modified: 2024-11-14 06:16:03
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 06:16:04
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.models import OrchestrationScheduledJob
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ScheduledJobView_OrchestrationList(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ORCHESTRATION_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ORCHESTRATION_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to list Orchestration scheduled jobs.")
            return context
        ##############################

        search_query = self.request.GET.get('search', '')
        user_orgs = self.request.user.organizations.all()
        org_orchestrators = user_orgs.values_list('maestros', flat=True)
        scheduled_jobs_list = OrchestrationScheduledJob.objects.filter(maestro__in=org_orchestrators)
        if search_query:
            scheduled_jobs_list = scheduled_jobs_list.filter(
                Q(name__icontains=search_query) | Q(task_description__icontains=search_query))
        paginator = Paginator(scheduled_jobs_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['scheduled_jobs'] = page_obj.object_list
        context['total_scheduled_jobs'] = OrchestrationScheduledJob.objects.count()
        context['search_query'] = search_query
        logger.info(f"Orchestration Scheduled Jobs list was fetched by User: {self.request.user.id}.")
        return context


Contents of ../../apps/mm_scheduled_jobs/views/scheduled_job/create_scheduled_job_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_scheduled_job_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.assistants.models import Assistant
from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.forms import ScheduledJobForm
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ScheduledJobView_Create(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = ScheduledJobForm()
        context["user"] = self.request.user
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['assistants'] = Assistant.objects.filter(organization__in=user_orgs)
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to add scheduled jobs.")
            return redirect('mm_scheduled_jobs:list')
        ##############################

        form = ScheduledJobForm(request.POST)
        assistant_id = request.POST.get('assistant')
        assistant = Assistant.objects.get(id=assistant_id)
        if form.is_valid():
            scheduled_job = form.save(commit=False)
            scheduled_job.assistant = assistant
            scheduled_job.created_by_user = request.user
            step_guide = request.POST.getlist('step_guide[]')
            scheduled_job.step_guide = step_guide
            scheduled_job.save()
            logger.info(f"Scheduled Job was created by User: {self.request.user.id}.")
            messages.success(request, "Scheduled Job created successfully!")
            return redirect('mm_scheduled_jobs:list')
        else:
            logger.error(f"Error creating Scheduled Job by User: {self.request.user.id}: {form.errors}")
            messages.error(request, "There was an error creating the scheduled job.")
            return self.render_to_response({'form': form})


Contents of ../../apps/mm_scheduled_jobs/views/scheduled_job/create_orchestration_scheduled_job_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: create_orchestration_scheduled_job_views.py
#  Last Modified: 2024-11-14 06:15:41
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 06:15:42
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.forms.orchestration_scheduled_job_forms import OrchestrationScheduledJobForm
from apps.orchestrations.models import Maestro
from apps.organization.models import Organization
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ScheduledJobView_OrchestrationCreate(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        context['form'] = OrchestrationScheduledJobForm()
        context["user"] = self.request.user
        user_orgs = Organization.objects.filter(users__in=[self.request.user])
        context['maestros'] = Maestro.objects.filter(organization__in=user_orgs)
        logger.error(context['maestros'])
        return context

    def post(self, request, *args, **kwargs):

        ##############################
        # PERMISSION CHECK FOR - ADD_ORCHESTRATION_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.ADD_ORCHESTRATION_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to add orchestration scheduled jobs.")
            return redirect('mm_scheduled_jobs:orchestration_list')
        ##############################

        form = OrchestrationScheduledJobForm(request.POST)
        maestro_id = request.POST.get('maestro')
        maestro = Maestro.objects.get(id=maestro_id)
        if form.is_valid():
            scheduled_job = form.save(commit=False)
            scheduled_job.maestro = maestro
            scheduled_job.created_by_user = request.user
            step_guide = request.POST.getlist('step_guide[]')
            scheduled_job.step_guide = step_guide
            scheduled_job.save()
            logger.info(f"Orchestration Scheduled Job was created by User: {self.request.user.id}.")
            messages.success(request, "Orchestration Scheduled Job created successfully!")
            return redirect('mm_scheduled_jobs:orchestration_list')
        else:
            logger.error(f"Error creating Orchestration Scheduled Job by User: {self.request.user.id}.")
            messages.error(request, "There was an error creating the Orchestration scheduled job.")
            return self.render_to_response({'form': form})


Contents of ../../apps/mm_scheduled_jobs/views/scheduled_job/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_scheduled_jobs_views import *
from .create_scheduled_job_views import *
from .delete_scheduled_jobs_views import *


Contents of ../../apps/mm_scheduled_jobs/views/scheduled_job/delete_scheduled_jobs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: delete_scheduled_jobs_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import get_object_or_404, redirect
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.models import ScheduledJob
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ScheduledJobView_Delete(LoginRequiredMixin, TemplateView):
    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))
        scheduled_job_id = self.kwargs.get('pk')
        scheduled_job = get_object_or_404(ScheduledJob, id=scheduled_job_id)
        context['scheduled_job'] = scheduled_job
        return context

    def post(self, request, *args, **kwargs):
        ##############################
        # PERMISSION CHECK FOR - DELETE_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.DELETE_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to delete scheduled jobs.")
            return redirect('mm_scheduled_jobs:list')
        ##############################

        scheduled_job_id = self.kwargs.get('pk')
        scheduled_job = get_object_or_404(ScheduledJob, id=scheduled_job_id)

        try:
            scheduled_job.delete()
        except Exception as e:
            messages.error(request, "An error occurred while deleting the Scheduled Job: " + str(e))
            return redirect("mm_scheduled_jobs:list")

        logger.info(f"Scheduled Job was deleted by User: {self.request.user.id}.")
        messages.success(request, "Scheduled Job deleted successfully.")
        return redirect('mm_scheduled_jobs:list')


Contents of ../../apps/mm_scheduled_jobs/views/log/list_orchestration_scheduled_job_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_orchestration_scheduled_job_logs_views.py
#  Last Modified: 2024-11-14 06:16:14
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-11-14 06:16:14
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.models import OrchestrationScheduledJob, OrchestrationScheduledJobInstance
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout

logger = logging.getLogger(__name__)


class ScheduledJobView_OrchestrationLogList(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_ORCHESTRATION_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_ORCHESTRATION_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to list orchestration scheduled jobs.")
            return context
        ##############################

        scheduled_job_id = self.kwargs.get('pk')
        scheduled_job = get_object_or_404(OrchestrationScheduledJob, id=scheduled_job_id)
        context['scheduled_job'] = scheduled_job
        search_query = self.request.GET.get('search', '')
        job_instances_list = OrchestrationScheduledJobInstance.objects.filter(scheduled_job=scheduled_job)
        if search_query:
            job_instances_list = job_instances_list.filter(Q(status__icontains=search_query) | Q(logs__icontains=search_query) | Q(scheduled_job__name__icontains=search_query))
        paginator = Paginator(job_instances_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['scheduled_job_instances'] = page_obj.object_list
        context['total_scheduled_job_instances'] = job_instances_list.count()
        context['search_query'] = search_query
        logger.info(
            f"User: {self.request.user.id} listed Orchestration scheduled job logs for Scheduled Job: {scheduled_job.id}.")
        return context


Contents of ../../apps/mm_scheduled_jobs/views/log/__init__.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: __init__.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#
#
#
#

from .list_scheduled_job_logs_views import *


Contents of ../../apps/mm_scheduled_jobs/views/log/list_scheduled_job_logs_views.py:
#  Copyright (c) 2024 BMD™ Autonomous Holdings. All rights reserved.
#
#  Project: Bimod.io™
#  File: list_scheduled_job_logs_views.py
#  Last Modified: 2024-10-05 01:39:48
#  Author: Ege Dogan Dursun (Co-Founder & Chief Executive Officer / CEO @ BMD™ Autonomous Holdings)
#  Created: 2024-10-05 14:42:45
#
#  This software is proprietary and confidential. Unauthorized copying,
#  distribution, modification, or use of this software, whether for
#  commercial, academic, or any other purpose, is strictly prohibited
#  without the prior express written permission of BMD™ Autonomous
#  Holdings.
#
#   For permission inquiries, please contact: admin@Bimod.io.
#

import logging

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

from apps.core.user_permissions.permission_manager import UserPermissionManager
from apps.mm_scheduled_jobs.models import ScheduledJob, ScheduledJobInstance
from apps.user_permissions.utils import PermissionNames
from web_project import TemplateLayout


logger = logging.getLogger(__name__)


class ScheduledJobView_LogList(LoginRequiredMixin, TemplateView):
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = TemplateLayout.init(self, super().get_context_data(**kwargs))

        ##############################
        # PERMISSION CHECK FOR - LIST_SCHEDULED_JOBS
        if not UserPermissionManager.is_authorized(user=self.request.user,
                                                   operation=PermissionNames.LIST_SCHEDULED_JOBS):
            messages.error(self.request, "You do not have permission to list scheduled jobs.")
            return context
        ##############################

        scheduled_job_id = self.kwargs.get('pk')
        scheduled_job = get_object_or_404(ScheduledJob, id=scheduled_job_id)
        context['scheduled_job'] = scheduled_job
        search_query = self.request.GET.get('search', '')
        job_instances_list = ScheduledJobInstance.objects.filter(scheduled_job=scheduled_job)
        if search_query:
            job_instances_list = job_instances_list.filter(Q(status__icontains=search_query) | Q(logs__icontains=search_query) | Q(scheduled_job__name__icontains=search_query))
        paginator = Paginator(job_instances_list, self.paginate_by)
        page_number = self.request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        context['page_obj'] = page_obj
        context['scheduled_job_instances'] = page_obj.object_list
        context['total_scheduled_job_instances'] = job_instances_list.count()
        context['search_query'] = search_query
        logger.info(f"User: {self.request.user.id} listed scheduled job logs for Scheduled Job: {scheduled_job.id}.")
        return context


